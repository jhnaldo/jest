[{
  "algo": "ReturnStatement1Evaluation0",
  "cond": "(= __x2__ CONST_async)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (= __x2__ CONST_async) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "var __evaluated  ; var __condition = 0 , __odds = 0 ; __evaluated = eval ( \"do { __condition++; if (((''+__condition/2).split('.')).length>1) continue; __odds++;} while(__condition < 10)\" ) ; if ( __odds !== 5 ) { $ERROR ( '#1: __odds === 5. Actual:  __odds ===' + __odds ) ; } if ( __evaluated !== 4 ) { $ERROR ( '#2: __evaluated === 4. Actual:  __evaluated ===' + __evaluated ) ; }",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "var __evaluated  ; var __condition = 0 , __odds = 0 ; __evaluated = eval ( \"do { __condition++; if (((''+__condition/2).split('.')).length>1) continue; __odds++;} while(__condition < 10)\" ) ; if ( __odds !== 5 ) { $ERROR ( '#1: __odds === 5. Actual:  __odds ===' + __odds ) ; } if ( __evaluated !== 4 ) { $ERROR ( '#2: __evaluated === 4. Actual:  __evaluated ===' + __evaluated ) ; }",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "var __evaluated  ; var __condition = 0 , __odds = 0 ; __evaluated = eval ( \"do { __condition++; if (((''+__condition/2).split('.')).length>1) continue; __odds++;} while(__condition < 10)\" ) ; if ( __odds !== 5 ) { $ERROR ( '#1: __odds === 5. Actual:  __odds ===' + __odds ) ; } if ( __evaluated !== 4 ) { $ERROR ( '#2: __evaluated === 4. Actual:  __evaluated ===' + __evaluated ) ; }",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "var __evaluated  ; var __condition = 0 , __odds = 0 ; __evaluated = eval ( \"do { __condition++; if (((''+__condition/2).split('.')).length>1) continue; __odds++;} while(__condition < 10)\" ) ; if ( __odds !== 5 ) { $ERROR ( '#1: __odds === 5. Actual:  __odds ===' + __odds ) ; } if ( __evaluated !== 4 ) { $ERROR ( '#2: __evaluated === 4. Actual:  __evaluated ===' + __evaluated ) ; }",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( 'var a; 1; for (a in { x: 0 }) { break; }' ) , undefined ) ; assert . sameValue ( eval ( 'var b; 2; for (b in { x: 0 }) { 3; break; }' ) , 3 ) ; assert . sameValue ( eval ( 'var a; 4; outer: do { for (a in { x: 0 }) { continue outer; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( 'var b; 5; outer: do { for (b in { x: 0 }) { 6; continue outer; } } while (false)' ) , 6 ) ;",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( 'var a; 1; for (a in { x: 0 }) { break; }' ) , undefined ) ; assert . sameValue ( eval ( 'var b; 2; for (b in { x: 0 }) { 3; break; }' ) , 3 ) ; assert . sameValue ( eval ( 'var a; 4; outer: do { for (a in { x: 0 }) { continue outer; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( 'var b; 5; outer: do { for (b in { x: 0 }) { 6; continue outer; } } while (false)' ) , 6 ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( 'var a; 1; for (a in { x: 0 }) { break; }' ) , undefined ) ; assert . sameValue ( eval ( 'var b; 2; for (b in { x: 0 }) { 3; break; }' ) , 3 ) ; assert . sameValue ( eval ( 'var a; 4; outer: do { for (a in { x: 0 }) { continue outer; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( 'var b; 5; outer: do { for (b in { x: 0 }) { 6; continue outer; } } while (false)' ) , 6 ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "Literal1Evaluation0",
  "cond": "(= (get-syntax BooleanLiteral) \"true\")",
  "covered": true,
  "inst": "if (= (get-syntax BooleanLiteral) \"true\") ... else ...",
  "thenCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;"
}, {
  "algo": "CallExpression0Evaluation0",
  "cond": "(= __x10__ true)",
  "covered": true,
  "inst": "if (= __x10__ true) ... else ...",
  "thenCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;"
}, {
  "algo": "AssignmentExpression5Evaluation0",
  "cond": "(= op \"*\")",
  "covered": true,
  "inst": "if (= op \"*\") ... else ...",
  "thenCovered": "var _11_13_2_12 = 5 ; _11_13_2_12 *= 2 ; assert . sameValue ( _11_13_2_12 , 10 , '_11_13_2_12' ) ;"
}, {
  "algo": "PrimaryExpression12HasName0",
  "cond": "(= __x1__ false)",
  "covered": true,
  "elseCovered": "var callCount = 0 ; class C  { * method ( [  cover = ( function  (  ) {  } ) ,  xCover = ( 0 , function  (  ) {  } ) ] = [  ] ) { assert . sameValue ( cover . name , 'cover' ) ; assert . notSameValue ( xCover . name , 'xCover' ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) . next ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if (= __x1__ false) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "IfStatement0HasCallInTailPosition0",
  "cond": "(= has true)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (= has true) ... else ..."
}, {
  "algo": "ArrowFunction0Contains0",
  "cond": "(! (|| (|| (|| (|| (is-instance-of symbol NewTarget) (is-instance-of symbol SuperProperty)) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\")))",
  "covered": true,
  "elseCovered": "var result = eval ( 'function fn() {}() => { return 42; };;' ) ; assert . sameValue ( result ( ) , 42 ) ;",
  "inst": "if (! (|| (|| (|| (|| (is-instance-of symbol NewTarget) (is-instance-of symbol SuperProperty)) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\"))) ... else ..."
}, {
  "algo": "ArrowFunction0Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "var result = eval ( 'function fn() {}() => { return 42; };;' ) ; assert . sameValue ( result ( ) , 42 ) ;",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "UnaryExpression1Evaluation0",
  "cond": "(= __x3__ true)",
  "covered": true,
  "elseCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;",
  "inst": "if (= __x3__ true) ... else ..."
}, {
  "algo": "UnaryExpression1Evaluation0",
  "cond": "(= __x6__ true)",
  "covered": true,
  "inst": "if (= __x6__ true) ... else ...",
  "thenCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;"
}, {
  "algo": "ArrowParameters0IteratorBindingInitialization0",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "var af = x => x ; assert . sameValue ( typeof af , \"function\" ) ; assert . sameValue ( af ( 1 ) , 1 ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "ArrowParameters0IteratorBindingInitialization0",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "var af = x => x ; assert . sameValue ( typeof af , \"function\" ) ; assert . sameValue ( af ( 1 ) , 1 ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "var doneCallCount = 0 ; var iter = { } ; iter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { value : null , done : false } ; } , return : function  (  ) { doneCallCount += 1 ; return { } ; } } ; } ; var callCount = 0 ; var f  ; f = function *  ( [  x  ] = iter ) { assert . sameValue ( doneCallCount , 1 ) ; callCount = callCount + 1 ; } ; f ( ) . next ( ) ; assert . sameValue ( callCount , 1 , 'generator function invoked exactly once' ) ;"
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "var doneCallCount = 0 ; var iter = { } ; iter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { value : null , done : false } ; } , return : function  (  ) { doneCallCount += 1 ; return { } ; } } ; } ; var callCount = 0 ; var f  ; f = function *  ( [  x  ] = iter ) { assert . sameValue ( doneCallCount , 1 ) ; callCount = callCount + 1 ; } ; f ( ) . next ( ) ; assert . sameValue ( callCount , 1 , 'generator function invoked exactly once' ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "var callCount = 0 ; class C  { static method ( { gen = function *  (  ) {  } , xGen = function * x (  ) {  } }  ) { assert . sameValue ( gen . name , 'gen' ) ; assert . notSameValue ( xGen . name , 'xGen' ) ; callCount = callCount + 1 ; } } ; C . method ( { } ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "ArrayCreate",
  "cond": "(= length -0.0)",
  "covered": true,
  "elseCovered": "var uriReserved = [  \"%3B\" ,  \"%2F\" ,  \"%3F\" ,  \"%3A\" ,  \"%40\" ,  \"%26\" ,  \"%3D\" ,  \"%2B\" ,  \"%24\" ,  \"%2C\" ] ; var uriReserved_ = [  \";\" ,  \"/\" ,  \"?\" ,  \":\" ,  \"@\" ,  \"&\" ,  \"=\" ,  \"+\" ,  \"$\" ,  \",\" ] ; for ( var indexC = 0 ; indexC < 10 ; indexC ++ ) { var str = uriReserved_ [ indexC ] ; if ( encodeURIComponent ( str ) !== uriReserved [ indexC ] ) { $ERROR ( '#' + ( indexC + 1 ) + ': unescapedURIComponentSet not containing' + str ) ; } }",
  "inst": "if (= length -0.0) ... else ..."
}, {
  "algo": "ArraySetLength",
  "cond": "(= succeeded false)",
  "covered": true,
  "elseCovered": "var arrObj = [  0 ,  1 ] ; Object . defineProperty ( arrObj , \"length\" , { value : - 0 } ) ; assert . sameValue ( arrObj . length , 0 , 'arrObj.length' ) ;",
  "inst": "if (= succeeded false) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(= length -0.0)",
  "covered": true,
  "elseCovered": "function callbackfn ( val  , idx  , obj  ) { return val < 10 ; } var obj = { 0 : 11 , 1 : 9 , 2 : 12 , length : \"2.5\" } ; var newArr = Array . prototype . map . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ;",
  "inst": "if (= length -0.0) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(! (= thisRealm realmC))",
  "covered": true,
  "elseCovered": "testWithTypedArrayConstructors ( function  ( TA  ) { var sample = new TA ( [  42 ] ) ; assert . sameValue ( Reflect . set ( sample , \"-1\" , 1 ) , false , \"-1\" ) ; assert . sameValue ( Reflect . set ( sample , \"1\" , 1 ) , false , \"1\" ) ; assert . sameValue ( Reflect . set ( sample , \"2\" , 1 ) , false , \"2\" ) ; assert . sameValue ( sample . hasOwnProperty ( \"-1\" ) , false , \"has no property [-1]\" ) ; assert . sameValue ( sample . hasOwnProperty ( \"1\" ) , false , \"has no property [1]\" ) ; assert . sameValue ( sample . hasOwnProperty ( \"2\" ) , false , \"has no property [2]\" ) ; } ) ;",
  "inst": "if (! (= thisRealm realmC)) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(= __x7__ true)",
  "covered": false,
  "inst": "if (= __x7__ true) ... else ..."
}, {
  "algo": "AssignmentElement0IteratorDestructuringAssignmentEvaluation1",
  "cond": "__x4__",
  "covered": true,
  "elseCovered": "var nextCount = 0 ; var returnCount = 0 ; var iterable = { } ; var thrower = function  (  ) { throw new Test262Error ( ) ; } ; var x  ; var iterator = { next : function  (  ) { nextCount += 1 ; return { done : nextCount > 10 } ; } , return : function  (  ) { returnCount += 1 ; throw new Test262Error ( ) ; } } ; iterable [ Symbol . iterator ] = function  (  ) { return iterator ; } ; assert . throws ( Test262Error , function  (  ) { 0 , [  x ,  ] = iterable ; } ) ; assert . sameValue ( nextCount , 1 ) ; assert . sameValue ( returnCount , 1 ) ;",
  "inst": "if __x4__ ... else ..."
}, {
  "algo": "AssignmentRestElement0IteratorDestructuringAssignmentEvaluation0",
  "cond": "__x5__",
  "covered": true,
  "elseCovered": "var x  ; var counter = 0 ; for ( [ , ... x ] of [  [  1 ,  2 ,  3 ] ] ) { assert . sameValue ( x . length , 2 ) ; assert . sameValue ( x [ 0 ] , 2 ) ; assert . sameValue ( x [ 1 ] , 3 ) ; counter += 1 ; } assert . sameValue ( counter , 1 ) ;",
  "inst": "if __x5__ ... else ..."
}, {
  "algo": "AsyncFunctionBody0EvaluateBody0",
  "cond": "(! __x2__)",
  "covered": true,
  "inst": "if (! __x2__) ... else ...",
  "thenCovered": "var await  ; async function foo (  ) { function bar (  ) { await = 1 ; } bar ( ) ; } foo ( ) ; assert . sameValue ( await , 1 ) ;"
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext) ... else ...",
  "thenCovered": "var await  ; async function foo (  ) { function bar (  ) { await = 1 ; } bar ( ) ; } foo ( ) ; assert . sameValue ( await , 1 ) ;"
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= result[\"Type\"] CONST_return)",
  "covered": true,
  "elseCovered": "let called  ; async function foo (  ) { called = true ; await new Promise ( ) ; } foo ( ) ; assert ( called ) ;",
  "inst": "if (= result[\"Type\"] CONST_return) ... else ..."
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= asyncContext[\"ReturnCont\"] absent)",
  "covered": true,
  "inst": "if (= asyncContext[\"ReturnCont\"] absent) ... else ...",
  "thenCovered": "var await  ; async function foo (  ) { function bar (  ) { await = 1 ; } bar ( ) ; } foo ( ) ; assert . sameValue ( await , 1 ) ;"
}, {
  "algo": "AsyncGeneratorEnqueue",
  "cond": "(|| (! (= __x1__ Object)) (= generator[\"AsyncGeneratorState\"] absent))",
  "covered": true,
  "elseCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (|| (! (= __x1__ Object)) (= generator[\"AsyncGeneratorState\"] absent)) ... else ..."
}, {
  "algo": "AsyncGeneratorEnqueue",
  "cond": "(! (= state CONST_executing))",
  "covered": true,
  "inst": "if (! (= state CONST_executing)) ... else ...",
  "thenCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_awaitingreturn)",
  "covered": true,
  "elseCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= state CONST_awaitingreturn) ... else ..."
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_suspendedStart)",
  "covered": true,
  "inst": "if (= state CONST_suspendedStart) ... else ...",
  "thenCovered": "async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_completed)",
  "covered": true,
  "inst": "if (= state CONST_completed) ... else ...",
  "thenCovered": "async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= completion[\"Type\"] CONST_return)",
  "covered": true,
  "inst": "if (= completion[\"Type\"] CONST_return) ... else ...",
  "thenCovered": "async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_completed)",
  "covered": true,
  "elseCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= state CONST_completed) ... else ..."
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= genContext[\"ReturnCont\"] absent)",
  "covered": true,
  "inst": "if (= genContext[\"ReturnCont\"] absent) ... else ...",
  "thenCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorStart",
  "cond": "(! (= result[\"Type\"] CONST_return))",
  "covered": false,
  "inst": "if (! (= result[\"Type\"] CONST_return)) ... else ..."
}, {
  "algo": "Await",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext) ... else ...",
  "thenCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "BigIntCOLONCOLONremainder",
  "cond": "(= n 0n)",
  "covered": true,
  "elseCovered": "function err (  ) { throw new Test262Error ( ) ; } function MyError (  ) {  } assert . sameValue ( { [ Symbol . toPrimitive ] : function  (  ) { return 2n ; } , valueOf : err , toString : err } % 2n , 0n , 'The result of (({[Symbol.toPrimitive]: function() {return 2n;}, valueOf: err, toString: err}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { [ Symbol . toPrimitive ] : function  (  ) { return 2n ; } , valueOf : err , toString : err } , 0n , 'The result of (2n % {[Symbol.toPrimitive]: function() {return 2n;}, valueOf: err, toString: err}) is 0n' ) ; assert . sameValue ( { valueOf : function  (  ) { return 2n ; } , toString : err } % 2n , 0n , 'The result of (({valueOf: function() {return 2n;}, toString: err}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : function  (  ) { return 2n ; } , toString : err } , 0n , 'The result of (2n % {valueOf: function() {return 2n;}, toString: err}) is 0n' ) ; assert . sameValue ( { toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { [ Symbol . toPrimitive ] : undefined , valueOf : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({[Symbol.toPrimitive]: undefined, valueOf: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { [ Symbol . toPrimitive ] : undefined , valueOf : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {[Symbol.toPrimitive]: undefined, valueOf: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { [ Symbol . toPrimitive ] : null , valueOf : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({[Symbol.toPrimitive]: null, valueOf: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { [ Symbol . toPrimitive ] : null , valueOf : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {[Symbol.toPrimitive]: null, valueOf: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : null , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: null, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : null , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: null, toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : 1 , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: 1, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : 1 , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: 1, toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : { } , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: {}, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : { } , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: {}, toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : function  (  ) { return { } ; } , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: function() {return {};}, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : function  (  ) { return { } ; } , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: function() {return {};}, toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : function  (  ) { return Object ( 12345 ) ; } , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: function() {return Object(12345);}, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : function  (  ) { return Object ( 12345 ) ; } , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: function() {return Object(12345);}, toString: function() {return 2n;}}) is 0n' ) ; assert . throws ( TypeError , function  (  ) { ( { [ Symbol . toPrimitive ] : 1 } ) % 1n ; } , '({[Symbol.toPrimitive]: 1}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : 1 } ; } , '0n % {[Symbol.toPrimitive]: 1} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { [ Symbol . toPrimitive ] : { } } ) % 1n ; } , '({[Symbol.toPrimitive]: {}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : { } } ; } , '0n % {[Symbol.toPrimitive]: {}} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { [ Symbol . toPrimitive ] : function  (  ) { return Object ( 1 ) ; } } ) % 1n ; } , '({[Symbol.toPrimitive]: function() {return Object(1);}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : function  (  ) { return Object ( 1 ) ; } } ; } , '0n % {[Symbol.toPrimitive]: function() {return Object(1);}} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { [ Symbol . toPrimitive ] : function  (  ) { return { } ; } } ) % 1n ; } , '({[Symbol.toPrimitive]: function() {return {};}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : function  (  ) { return { } ; } } ; } , '0n % {[Symbol.toPrimitive]: function() {return {};}} throws TypeError' ) ; assert . throws ( MyError , function  (  ) { ( { [ Symbol . toPrimitive ] : function  (  ) { throw new MyError ( ) ; } } ) % 1n ; } , '({[Symbol.toPrimitive]: function() {throw new MyError();}}) % 1n throws MyError' ) ; assert . throws ( MyError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : function  (  ) { throw new MyError ( ) ; } } ; } , '0n % {[Symbol.toPrimitive]: function() {throw new MyError();}} throws MyError' ) ; assert . throws ( MyError , function  (  ) { ( { valueOf : function  (  ) { throw new MyError ( ) ; } } ) % 1n ; } , '({valueOf: function() {throw new MyError();}}) % 1n throws MyError' ) ; assert . throws ( MyError , function  (  ) { 0n % { valueOf : function  (  ) { throw new MyError ( ) ; } } ; } , '0n % {valueOf: function() {throw new MyError();}} throws MyError' ) ; assert . throws ( MyError , function  (  ) { ( { toString : function  (  ) { throw new MyError ( ) ; } } ) % 1n ; } , '({toString: function() {throw new MyError();}}) % 1n throws MyError' ) ; assert . throws ( MyError , function  (  ) { 0n % { toString : function  (  ) { throw new MyError ( ) ; } } ; } , '0n % {toString: function() {throw new MyError();}} throws MyError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : null , toString : null } ) % 1n ; } , '({valueOf: null, toString: null}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : null , toString : null } ; } , '0n % {valueOf: null, toString: null} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : 1 , toString : 1 } ) % 1n ; } , '({valueOf: 1, toString: 1}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : 1 , toString : 1 } ; } , '0n % {valueOf: 1, toString: 1} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : { } , toString : { } } ) % 1n ; } , '({valueOf: {}, toString: {}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : { } , toString : { } } ; } , '0n % {valueOf: {}, toString: {}} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : function  (  ) { return Object ( 1 ) ; } , toString : function  (  ) { return Object ( 1 ) ; } } ) % 1n ; } , '({valueOf: function() {return Object(1);}, toString: function() {return Object(1);}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : function  (  ) { return Object ( 1 ) ; } , toString : function  (  ) { return Object ( 1 ) ; } } ; } , '0n % {valueOf: function() {return Object(1);}, toString: function() {return Object(1);}} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : function  (  ) { return { } ; } , toString : function  (  ) { return { } ; } } ) % 1n ; } , '({valueOf: function() {return {};}, toString: function() {return {};}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : function  (  ) { return { } ; } , toString : function  (  ) { return { } ; } } ; } , '0n % {valueOf: function() {return {};}, toString: function() {return {};}} throws TypeError' ) ;",
  "inst": "if (= n 0n) ... else ..."
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "var callCount = 0 ; var obj = { * method ( [  ... { length  } ] = [  1 ,  2 ,  3 ] ) { assert . sameValue ( length , 3 ) ; callCount = callCount + 1 ; } } ; obj . method ( ) . next ( ) ; assert . sameValue ( callCount , 1 , 'generator method invoked exactly once' ) ;"
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "var callCount = 0 ; var obj = { * method ( [  ... { length  } ] = [  1 ,  2 ,  3 ] ) { assert . sameValue ( length , 3 ) ; callCount = callCount + 1 ; } } ; obj . method ( ) . next ( ) ; assert . sameValue ( callCount , 1 , 'generator method invoked exactly once' ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "__x7__",
  "covered": true,
  "elseCovered": "var callCount = 0 ; var obj = { * method ( [  ... { length  } ] = [  1 ,  2 ,  3 ] ) { assert . sameValue ( length , 3 ) ; callCount = callCount + 1 ; } } ; obj . method ( ) . next ( ) ; assert . sameValue ( callCount , 1 , 'generator method invoked exactly once' ) ;",
  "inst": "if __x7__ ... else ..."
}, {
  "algo": "BreakableStatement1LabelledEvaluation0",
  "cond": "(= stmtResult[\"Target\"] CONST_empty)",
  "covered": true,
  "inst": "if (= stmtResult[\"Target\"] CONST_empty) ... else ...",
  "thenCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { case \"a\": 2; default: 3; break; }' ) , 3 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '4; switch (\"a\") { case \"a\": default: 5; break; }' ) , 5 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '6; switch (\"a\") { case \"a\": 7; default: break; }' ) , 7 , 'Empty value does not replace previous non-empty value' ) ; assert . sameValue ( eval ( '8; do { switch (\"a\") { case \"a\": 9; default: 10; continue; } } while (false)' ) , 10 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '11; do { switch (\"a\") { case \"a\": default: 12; continue; } } while (false)' ) , 12 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '13; do { switch (\"a\") { case \"a\": 14; default: continue; } } while (false)' ) , 14 , 'Empty value does not replace previous non-empty value' ) ;"
}, {
  "algo": "BreakableStatement1LabelledEvaluation0",
  "cond": "(= stmtResult[\"Value\"] CONST_empty)",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { case \"a\": 2; default: 3; break; }' ) , 3 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '4; switch (\"a\") { case \"a\": default: 5; break; }' ) , 5 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '6; switch (\"a\") { case \"a\": 7; default: break; }' ) , 7 , 'Empty value does not replace previous non-empty value' ) ; assert . sameValue ( eval ( '8; do { switch (\"a\") { case \"a\": 9; default: 10; continue; } } while (false)' ) , 10 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '11; do { switch (\"a\") { case \"a\": default: 12; continue; } } while (false)' ) , 12 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '13; do { switch (\"a\") { case \"a\": 14; default: continue; } } while (false)' ) , 14 , 'Empty value does not replace previous non-empty value' ) ;",
  "inst": "if (= stmtResult[\"Value\"] CONST_empty) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTCall",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTConstruct",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTConstruct",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] calleeContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] calleeContext) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "CanonicalNumericIndexString",
  "cond": "(= argument \"-0\")",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= argument \"-0\") ... else ..."
}, {
  "algo": "CaseBlock1HasCallInTailPosition3",
  "cond": "(! (= CaseClauses1 absent))",
  "covered": true,
  "inst": "if (! (= CaseClauses1 absent)) ... else ...",
  "thenCovered": "function SwitchTest ( value  ) { var result = 0 ; switch ( value ) { case 0 : result += 2 ; case 1 : result += 4 ; break ; case 2 : result += 8 ; case isNaN ( value ) : result += 16 ; default : result += 32 ; break ; case null : result += 64 ; case isNaN : result += 128 ; break ; case Infinity : result += 256 ; case 2 + 3 : result += 512 ; break ; case undefined : result += 1024 ; } return result ; } var n = Number ( false ) ; if ( ! ( SwitchTest ( n ) === 6 ) ) { $ERROR ( \"#1: SwitchTest(Number(false)) === 6. Actual:  SwitchTest(Number(false)) ===\" + SwitchTest ( n ) ) ; } if ( ! ( SwitchTest ( parseInt ) === 32 ) ) { $ERROR ( \"#2: SwitchTest(parseInt) === 32. Actual:  SwitchTest(parseInt) ===\" + SwitchTest ( parseInt ) ) ; } if ( ! ( SwitchTest ( isNaN ) === 128 ) ) { $ERROR ( \"#3: SwitchTest(isNaN) === 128. Actual:  SwitchTest(isNaN) ===\" + SwitchTest ( isNaN ) ) ; } if ( ! ( SwitchTest ( true ) === 32 ) ) { $ERROR ( \"#6: SwitchTest(true) === 32. Actual:  SwitchTest(true) ===\" + SwitchTest ( true ) ) ; } if ( ! ( SwitchTest ( false ) === 48 ) ) { $ERROR ( \"#7: SwitchTest(false) === 48. Actual:  SwitchTest(false) ===\" + SwitchTest ( false ) ) ; } if ( ! ( SwitchTest ( null ) === 192 ) ) { $ERROR ( \"#8: SwitchTest(null) === 192. Actual:  SwitchTest(null) ===\" + SwitchTest ( null ) ) ; } if ( ! ( SwitchTest ( void 0 ) === 1024 ) ) { $ERROR ( \"#9: SwitchTest(void 0) === 1024. Actual:  SwitchTest(void 0) ===\" + SwitchTest ( void 0 ) ) ; } if ( ! ( SwitchTest ( NaN ) === 32 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 32. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; } if ( ! ( SwitchTest ( Infinity ) === 768 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 768. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; }"
}, {
  "algo": "CaseBlock1LexicallyScopedDeclarations3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"b\": }' ) , undefined , 'empty StatementList (lone case)' ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"b\": 3; }' ) , 3 , 'non-empy StatementList (lone case)' ) ; assert . sameValue ( eval ( '4; switch (\"a\") { default: case \"b\": case \"c\": }' ) , undefined , 'empty StatementList (following an empty case)' ) ; assert . sameValue ( eval ( '5; switch (\"a\") { default: case \"b\": case \"c\": 6; }' ) , 6 , 'non-empty StatementList (following an empty case)' ) ; assert . sameValue ( eval ( '7; switch (\"a\") { default: case \"b\": 8; case \"c\": }' ) , 8 , 'empty StatementList (following a non-empty case)' ) ; assert . sameValue ( eval ( '9; switch (\"a\") { default: case \"b\": 10; case \"c\": 11; }' ) , 11 , 'non-empty StatementList (following a non-empty case)' ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseBlock1VarDeclaredNames3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"b\": }' ) , undefined , 'empty StatementList (lone case)' ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"b\": 3; }' ) , 3 , 'non-empy StatementList (lone case)' ) ; assert . sameValue ( eval ( '4; switch (\"a\") { default: case \"b\": case \"c\": }' ) , undefined , 'empty StatementList (following an empty case)' ) ; assert . sameValue ( eval ( '5; switch (\"a\") { default: case \"b\": case \"c\": 6; }' ) , 6 , 'non-empty StatementList (following an empty case)' ) ; assert . sameValue ( eval ( '7; switch (\"a\") { default: case \"b\": 8; case \"c\": }' ) , 8 , 'empty StatementList (following a non-empty case)' ) ; assert . sameValue ( eval ( '9; switch (\"a\") { default: case \"b\": 10; case \"c\": 11; }' ) , 11 , 'non-empty StatementList (following a non-empty case)' ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseBlock1VarScopedDeclarations3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"b\": }' ) , undefined , 'empty StatementList (lone case)' ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"b\": 3; }' ) , 3 , 'non-empy StatementList (lone case)' ) ; assert . sameValue ( eval ( '4; switch (\"a\") { default: case \"b\": case \"c\": }' ) , undefined , 'empty StatementList (following an empty case)' ) ; assert . sameValue ( eval ( '5; switch (\"a\") { default: case \"b\": case \"c\": 6; }' ) , 6 , 'non-empty StatementList (following an empty case)' ) ; assert . sameValue ( eval ( '7; switch (\"a\") { default: case \"b\": 8; case \"c\": }' ) , 8 , 'empty StatementList (following a non-empty case)' ) ; assert . sameValue ( eval ( '9; switch (\"a\") { default: case \"b\": 10; case \"c\": 11; }' ) , 11 , 'non-empty StatementList (following a non-empty case)' ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseClause0HasCallInTailPosition1",
  "cond": "(! (= StatementList absent))",
  "covered": true,
  "inst": "if (! (= StatementList absent)) ... else ...",
  "thenCovered": "var callCount = 0 ; ( function f ( n  ) { if ( n === 0 ) { callCount += 1 ; return ; } switch ( 0 ) { case 0 : return f ( n - 1 ) ; default :   } } ( $MAX_ITERATIONS ) ) ; assert . sameValue ( callCount , 1 ) ;"
}, {
  "algo": "CaseClauses1HasCallInTailPosition0",
  "cond": "(= has true)",
  "covered": true,
  "elseCovered": "function SwitchTest ( value  ) { var result = 0 ; switch ( value ) { case 0 : result += 2 ; case 1 : result += 4 ; break ; case 2 : result += 8 ; case isNaN ( value ) : result += 16 ; default : result += 32 ; break ; case null : result += 64 ; case isNaN : result += 128 ; break ; case Infinity : result += 256 ; case 2 + 3 : result += 512 ; break ; case undefined : result += 1024 ; } return result ; } var n = Number ( false ) ; if ( ! ( SwitchTest ( n ) === 6 ) ) { $ERROR ( \"#1: SwitchTest(Number(false)) === 6. Actual:  SwitchTest(Number(false)) ===\" + SwitchTest ( n ) ) ; } if ( ! ( SwitchTest ( parseInt ) === 32 ) ) { $ERROR ( \"#2: SwitchTest(parseInt) === 32. Actual:  SwitchTest(parseInt) ===\" + SwitchTest ( parseInt ) ) ; } if ( ! ( SwitchTest ( isNaN ) === 128 ) ) { $ERROR ( \"#3: SwitchTest(isNaN) === 128. Actual:  SwitchTest(isNaN) ===\" + SwitchTest ( isNaN ) ) ; } if ( ! ( SwitchTest ( true ) === 32 ) ) { $ERROR ( \"#6: SwitchTest(true) === 32. Actual:  SwitchTest(true) ===\" + SwitchTest ( true ) ) ; } if ( ! ( SwitchTest ( false ) === 48 ) ) { $ERROR ( \"#7: SwitchTest(false) === 48. Actual:  SwitchTest(false) ===\" + SwitchTest ( false ) ) ; } if ( ! ( SwitchTest ( null ) === 192 ) ) { $ERROR ( \"#8: SwitchTest(null) === 192. Actual:  SwitchTest(null) ===\" + SwitchTest ( null ) ) ; } if ( ! ( SwitchTest ( void 0 ) === 1024 ) ) { $ERROR ( \"#9: SwitchTest(void 0) === 1024. Actual:  SwitchTest(void 0) ===\" + SwitchTest ( void 0 ) ) ; } if ( ! ( SwitchTest ( NaN ) === 32 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 32. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; } if ( ! ( SwitchTest ( Infinity ) === 768 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 768. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; }",
  "inst": "if (= has true) ... else ..."
}, {
  "algo": "CaseClauses1LexicallyScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { case \"a\": 2; case \"b\": 3; break; default: }' ) , 3 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '4; switch (\"a\") { case \"a\": case \"b\": 5; break; default: }' ) , 5 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '6; switch (\"a\") { case \"a\": 7; case \"b\": break; default: }' ) , 7 , 'Empty value does not replace previous non-empty value' ) ; assert . sameValue ( eval ( '8; do { switch (\"a\") { case \"a\": 9; case \"b\": 10; continue; default: } } while (false)' ) , 10 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '11; do { switch (\"a\") { case \"a\": case \"b\": 12; continue; default: } } while (false)' ) , 12 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '13; do { switch (\"a\") { case \"a\": 14; case \"b\": continue; default: } } while (false)' ) , 14 , 'Empty value does not replace previous non-empty value' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "CaseClauses1VarDeclaredNames0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { case \"a\": 2; case \"b\": 3; break; default: }' ) , 3 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '4; switch (\"a\") { case \"a\": case \"b\": 5; break; default: }' ) , 5 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '6; switch (\"a\") { case \"a\": 7; case \"b\": break; default: }' ) , 7 , 'Empty value does not replace previous non-empty value' ) ; assert . sameValue ( eval ( '8; do { switch (\"a\") { case \"a\": 9; case \"b\": 10; continue; default: } } while (false)' ) , 10 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '11; do { switch (\"a\") { case \"a\": case \"b\": 12; continue; default: } } while (false)' ) , 12 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '13; do { switch (\"a\") { case \"a\": 14; case \"b\": continue; default: } } while (false)' ) , 14 , 'Empty value does not replace previous non-empty value' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "CaseClauses1VarScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( '1; switch (\"a\") { case \"a\": 2; case \"b\": 3; break; default: }' ) , 3 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '4; switch (\"a\") { case \"a\": case \"b\": 5; break; default: }' ) , 5 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '6; switch (\"a\") { case \"a\": 7; case \"b\": break; default: }' ) , 7 , 'Empty value does not replace previous non-empty value' ) ; assert . sameValue ( eval ( '8; do { switch (\"a\") { case \"a\": 9; case \"b\": 10; continue; default: } } while (false)' ) , 10 , 'Non-empty value replaces previous non-empty value' ) ; assert . sameValue ( eval ( '11; do { switch (\"a\") { case \"a\": case \"b\": 12; continue; default: } } while (false)' ) , 12 , 'Non-empty value replaces empty value' ) ; assert . sameValue ( eval ( '13; do { switch (\"a\") { case \"a\": 14; case \"b\": continue; default: } } while (false)' ) , 14 , 'Empty value does not replace previous non-empty value' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "ClassElementList0ConstructorMethod0",
  "cond": "(is-instance-of ClassElement ClassElement2)",
  "covered": true,
  "elseCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;",
  "inst": "if (is-instance-of ClassElement ClassElement2) ... else ..."
}, {
  "algo": "ClassElementList0NonConstructorMethodDefinitions0",
  "cond": "(is-instance-of ClassElement ClassElement2)",
  "covered": true,
  "elseCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;",
  "inst": "if (is-instance-of ClassElement ClassElement2) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(is-instance-of symbol ClassBody)",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function  (  ) { eval ( 'typeof C; class C {}' ) ; } ) ;",
  "inst": "if (is-instance-of symbol ClassBody) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(is-instance-of symbol ClassHeritage)",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function  (  ) { eval ( 'typeof C; class C {}' ) ; } ) ;",
  "inst": "if (is-instance-of symbol ClassHeritage) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(! (= ClassHeritage absent))",
  "covered": false,
  "inst": "if (! (= ClassHeritage absent)) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= ClassHeritage absent)",
  "covered": true,
  "inst": "if (= ClassHeritage absent) ... else ...",
  "thenCovered": "assert . throws ( ReferenceError , function  (  ) { eval ( 'typeof C; class C {}' ) ; } ) ;"
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= inHeritage true)",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function  (  ) { eval ( 'typeof C; class C {}' ) ; } ) ;",
  "inst": "if (= inHeritage true) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= ClassBody absent)",
  "covered": true,
  "inst": "if (= ClassBody absent) ... else ...",
  "thenCovered": "assert . throws ( ReferenceError , function  (  ) { eval ( 'typeof C; class C {}' ) ; } ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= realm absent)",
  "covered": true,
  "inst": "if (= realm absent) ... else ...",
  "thenCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= prototype absent)",
  "covered": true,
  "inst": "if (= prototype absent) ... else ...",
  "thenCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= steps[\"length\"] absent)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (= steps[\"length\"] absent) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= newTarget undefined)",
  "covered": false,
  "inst": "if (= newTarget undefined) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= kind CONST_generator)",
  "covered": false,
  "inst": "if (= kind CONST_generator) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= kind CONST_async)",
  "covered": false,
  "inst": "if (= kind CONST_async) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(== argCount 0i)",
  "covered": false,
  "inst": "if (== argCount 0i) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(== argCount 1i)",
  "covered": false,
  "inst": "if (== argCount 1i) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(< k (- argCount 1i))",
  "covered": false,
  "inst": "while (< k (- argCount 1i)) { ... }"
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= parameters absent)",
  "covered": false,
  "inst": "if (= parameters absent) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= body absent)",
  "covered": false,
  "inst": "if (= body absent) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x6__ false)",
  "covered": false,
  "inst": "if (= __x6__ false) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(< idx len)",
  "covered": false,
  "inst": "while (< idx len) { ... }"
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(contains declNames name)",
  "covered": false,
  "inst": "if (contains declNames name) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x9__ true)",
  "covered": false,
  "inst": "if (= __x9__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x12__ true)",
  "covered": false,
  "inst": "if (= __x12__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x15__ true)",
  "covered": false,
  "inst": "if (= __x15__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x18__ true)",
  "covered": false,
  "inst": "if (= __x18__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(|| (= kind CONST_generator) (= kind CONST_asyncGenerator))",
  "covered": false,
  "inst": "if (|| (= kind CONST_generator) (= kind CONST_asyncGenerator)) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x21__ true)",
  "covered": false,
  "inst": "if (= __x21__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(|| (= kind CONST_async) (= kind CONST_asyncGenerator))",
  "covered": false,
  "inst": "if (|| (= kind CONST_async) (= kind CONST_asyncGenerator)) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x24__ true)",
  "covered": false,
  "inst": "if (= __x24__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(< idx len)",
  "covered": false,
  "inst": "while (< idx len) { ... }"
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(contains tempList name)",
  "covered": false,
  "inst": "if (contains tempList name) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= kind CONST_generator)",
  "covered": false,
  "inst": "if (= kind CONST_generator) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= kind CONST_asyncGenerator)",
  "covered": false,
  "inst": "if (= kind CONST_asyncGenerator) ... else ..."
}, {
  "algo": "CreateListFromArrayLike",
  "cond": "(= elementTypes absent)",
  "covered": true,
  "inst": "if (= elementTypes absent) ... else ...",
  "thenCovered": "function af ( ... a ) { return a . length ; } assert . sameValue ( af . apply ( null , [  ] ) , 0 , \"`af.apply(null, [])` returns `0`\" ) ; assert . sameValue ( af . apply ( null , [  1 ] ) , 1 , \"`af.apply(null, [1])` returns `1`\" ) ; assert . sameValue ( af . apply ( null , [  1 ,  2 ] ) , 2 , \"`af.apply(null, [1, 2])` returns `2`\" ) ; assert . sameValue ( af . apply ( null , [  1 , , 2 ] ) , 3 , \"`af.apply(null, [1, ,2])` returns `3`\" ) ;"
}, {
  "algo": "CreateListFromArrayLike",
  "cond": "(! (contains elementTypes __x5__))",
  "covered": true,
  "elseCovered": "function af ( ... a ) { return a . length ; } assert . sameValue ( af . apply ( null , [  ] ) , 0 , \"`af.apply(null, [])` returns `0`\" ) ; assert . sameValue ( af . apply ( null , [  1 ] ) , 1 , \"`af.apply(null, [1])` returns `1`\" ) ; assert . sameValue ( af . apply ( null , [  1 ,  2 ] ) , 2 , \"`af.apply(null, [1, 2])` returns `2`\" ) ; assert . sameValue ( af . apply ( null , [  1 , , 2 ] ) , 3 , \"`af.apply(null, [1, ,2])` returns `3`\" ) ;",
  "inst": "if (! (contains elementTypes __x5__)) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTInitializeBinding",
  "cond": "(! (= envRec[\"SubMap\"][N] absent))",
  "covered": true,
  "inst": "if (! (= envRec[\"SubMap\"][N] absent)) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= absent envRec[\"SubMap\"][N])",
  "covered": true,
  "elseCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;",
  "inst": "if (= absent envRec[\"SubMap\"][N]) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= S true)",
  "covered": false,
  "inst": "if (= S true) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= S true)",
  "covered": true,
  "inst": "if (= S true) ... else ...",
  "thenCovered": "const c = null ; assert . throws ( TypeError , function  (  ) { 0 , [  c ] = [  1 ] ; } ) ;"
}, {
  "algo": "DefaultClause0HasCallInTailPosition1",
  "cond": "(! (= StatementList absent))",
  "covered": true,
  "inst": "if (! (= StatementList absent)) ... else ...",
  "thenCovered": "function SwitchTest ( value  ) { var result = 0 ; switch ( value ) { case 0 : result += 2 ; case 1 : result += 4 ; break ; case 2 : result += 8 ; case isNaN ( value ) : result += 16 ; default : result += 32 ; break ; case null : result += 64 ; case isNaN : result += 128 ; break ; case Infinity : result += 256 ; case 2 + 3 : result += 512 ; break ; case undefined : result += 1024 ; } return result ; } var n = Number ( false ) ; if ( ! ( SwitchTest ( n ) === 6 ) ) { $ERROR ( \"#1: SwitchTest(Number(false)) === 6. Actual:  SwitchTest(Number(false)) ===\" + SwitchTest ( n ) ) ; } if ( ! ( SwitchTest ( parseInt ) === 32 ) ) { $ERROR ( \"#2: SwitchTest(parseInt) === 32. Actual:  SwitchTest(parseInt) ===\" + SwitchTest ( parseInt ) ) ; } if ( ! ( SwitchTest ( isNaN ) === 128 ) ) { $ERROR ( \"#3: SwitchTest(isNaN) === 128. Actual:  SwitchTest(isNaN) ===\" + SwitchTest ( isNaN ) ) ; } if ( ! ( SwitchTest ( true ) === 32 ) ) { $ERROR ( \"#6: SwitchTest(true) === 32. Actual:  SwitchTest(true) ===\" + SwitchTest ( true ) ) ; } if ( ! ( SwitchTest ( false ) === 48 ) ) { $ERROR ( \"#7: SwitchTest(false) === 48. Actual:  SwitchTest(false) ===\" + SwitchTest ( false ) ) ; } if ( ! ( SwitchTest ( null ) === 192 ) ) { $ERROR ( \"#8: SwitchTest(null) === 192. Actual:  SwitchTest(null) ===\" + SwitchTest ( null ) ) ; } if ( ! ( SwitchTest ( void 0 ) === 1024 ) ) { $ERROR ( \"#9: SwitchTest(void 0) === 1024. Actual:  SwitchTest(void 0) ===\" + SwitchTest ( void 0 ) ) ; } if ( ! ( SwitchTest ( NaN ) === 32 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 32. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; } if ( ! ( SwitchTest ( Infinity ) === 768 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 768. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; }"
}, {
  "algo": "ElementList1ArrayAccumulation1",
  "cond": "(! (= Elision absent))",
  "covered": true,
  "elseCovered": "var arr = [  'a' ,  'b' ,  'c' ] ; var callCount = 0 ; var gen = function *  (  ) { callCount += 1 ; yield [  ... yield ] ; } ; var iter = gen ( ) ; iter . next ( false ) ; var item = iter . next ( arr ) ; var value = item . value ; assert . notSameValue ( value , arr , 'value is a new array' ) ; assert ( Array . isArray ( value ) , 'value is an Array exotic object' ) ; assert . sameValue ( value . length , 3 ) ; assert . sameValue ( value [ 0 ] , 'a' ) ; assert . sameValue ( value [ 1 ] , 'b' ) ; assert . sameValue ( value [ 2 ] , 'c' ) ; assert . sameValue ( item . done , false ) ; assert . sameValue ( callCount , 1 ) ;",
  "inst": "if (! (= Elision absent)) ... else ..."
}, {
  "algo": "ElementList3ArrayAccumulation1",
  "cond": "(! (= Elision absent))",
  "covered": true,
  "elseCovered": "var iter = { } ; iter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { throw new Test262Error ( ) ; } } ; } ; assert . throws ( Test262Error , function  (  ) { [  0 ,  ... iter ] ; } ) ;",
  "inst": "if (! (= Elision absent)) ... else ..."
}, {
  "algo": "Elision0IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "var following = 0 ; var iter = function *  (  ) { throw new Test262Error ( ) ; following += 1 ; } ( ) ; var C = class   { * method ( [ ,  ] = iter ) {  } } ; var c = new C ( ) ; assert . throws ( Test262Error , function  (  ) { c . method ( ) ; } ) ; iter . next ( ) ; assert . sameValue ( following , 0 , 'Iterator was properly closed.' ) ;"
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "var callCount = 0 ; var C = class   { method ( [ , , ... x ] = [  1 ,  2 ] ) { assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 0 ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;"
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "var callCount = 0 ; var C = class   { method ( [ , , ... x ] = [  1 ,  2 ] ) { assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 0 ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= next false)",
  "covered": true,
  "elseCovered": "var callCount = 0 ; var C = class   { method ( [ , , ... x ] = [  1 ,  2 ] ) { assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 0 ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if (= next false) ... else ..."
}, {
  "algo": "EqualityExpression2Evaluation0",
  "cond": "(= r true)",
  "covered": false,
  "inst": "if (= r true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= strict false)",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;",
  "inst": "if (= strict false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": false,
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": false,
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= __x4__ true)",
  "covered": false,
  "inst": "if (= __x4__ true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (= thisLex varEnv))",
  "covered": false,
  "inst": "while (! (= thisLex varEnv)) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (= (typeof thisEnvRec) \"ObjectEnvironmentRecord\"))",
  "covered": false,
  "inst": "if (! (= (typeof thisEnvRec) \"ObjectEnvironmentRecord\")) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": false,
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= __x8__ true)",
  "covered": false,
  "inst": "if (= __x8__ true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredFunctionNames fn))",
  "covered": true,
  "inst": "if (! (contains declaredFunctionNames fn)) ... else ...",
  "thenCovered": "var result = eval ( 'function fn() {}() => { return 42; };;' ) ; assert . sameValue ( result ( ) , 42 ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "var result = eval ( 'function fn() {}() => { return 42; };;' ) ; assert . sameValue ( result ( ) , 42 ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= fnDefinable false)",
  "covered": false,
  "inst": "if (= fnDefinable false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredFunctionNames vn))",
  "covered": true,
  "inst": "if (! (contains declaredFunctionNames vn)) ... else ...",
  "thenCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= vnDefinable false)",
  "covered": false,
  "inst": "if (= vnDefinable false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredVarNames vn))",
  "covered": true,
  "inst": "if (! (contains declaredVarNames vn)) ... else ...",
  "thenCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "var result = eval ( 'function fn() {}() => { return 42; };;' ) ; assert . sameValue ( result ( ) , 42 ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= bindingExists false)",
  "covered": true,
  "inst": "if (= bindingExists false) ... else ...",
  "thenCovered": "var result = eval ( 'function fn() {}() => { return 42; };;' ) ; assert . sameValue ( result ( ) , 42 ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= bindingExists false)",
  "covered": true,
  "inst": "if (= bindingExists false) ... else ...",
  "thenCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;"
}, {
  "algo": "FlattenIntoArray",
  "cond": "(! (< targetIndex (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "var a = [  [  0 ] ,  [  1 ] ] ; var actual = [  ] . flat . bind ( a ) ( ) ; assert . compareArray ( actual , [  0 ,  1 ] , 'bound flat' ) ;",
  "inst": "if (! (< targetIndex (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind absent)",
  "covered": true,
  "inst": "if (= iteratorKind absent) ... else ...",
  "thenCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;"
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(! (= __x3__ Object))",
  "covered": true,
  "elseCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;",
  "inst": "if (! (= __x3__ Object)) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "__x15__",
  "covered": true,
  "elseCovered": "var expectedValue = { valueOf (  ) { throw new Test262Error ( \"expectedValue coerced\" ) ; } } ; var badArrayTypes = [  Uint8ClampedArray ,  Float32Array ,  Float64Array ] ; for ( var badArrayType of badArrayTypes ) { var typedArray = new badArrayType ( new SharedArrayBuffer ( 8 ) ) ; assert . throws ( TypeError , function  (  ) { Atomics . compareExchange ( typedArray , 0 , expectedValue , 0 ) ; } ) ; }",
  "inst": "if __x15__ ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "var x  ; var counter = 0 ; assert . throws ( TypeError , function  (  ) { for ( { x : { x } } of [  { x : null } ] ) { counter += 1 ; } counter += 1 ; } ) ; assert . sameValue ( counter , 0 ) ;",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iterationKind CONST_enumerate)",
  "covered": true,
  "elseCovered": "var x  ; var counter = 0 ; assert . throws ( TypeError , function  (  ) { for ( { x : { x } } of [  { x : null } ] ) { counter += 1 ; } counter += 1 ; } ) ; assert . sameValue ( counter , 0 ) ;",
  "inst": "if (= iterationKind CONST_enumerate) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "function * values (  ) { yield 1 ; $ERROR ( 'This code is unreachable (following `yield` statement).' ) ; } var iterator = values ( ) ; var i = 0 ; var result = ( function  (  ) { for ( var x of iterator ) { i ++ ; return 34 ; $ERROR ( 'This code is unreachable (following `return` statement).' ) ; } $ERROR ( 'This code is unreachable (following `for..of` statement).' ) ; } ) ( ) ; assert . sameValue ( result , 34 ) ; assert . sameValue ( i , 1 ) ;",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfHeadEvaluation",
  "cond": "(= iterationKind CONST_asynciterate)",
  "covered": true,
  "elseCovered": "var expectedValue = { valueOf (  ) { throw new Test262Error ( \"expectedValue coerced\" ) ; } } ; var badArrayTypes = [  Uint8ClampedArray ,  Float32Array ,  Float64Array ] ; for ( var badArrayType of badArrayTypes ) { var typedArray = new badArrayType ( new SharedArrayBuffer ( 8 ) ) ; assert . throws ( TypeError , function  (  ) { Atomics . compareExchange ( typedArray , 0 , expectedValue , 0 ) ; } ) ; }",
  "inst": "if (= iterationKind CONST_asynciterate) ... else ..."
}, {
  "algo": "FormalParameters4ContainsExpression0",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "var af = ( x , ... y ) => { return [  x ,  y . length ] ; } ; assert . sameValue ( typeof af , \"function\" ) ; assert . sameValue ( af ( 1 , 1 , 1 ) [ 0 ] , 1 ) ; assert . sameValue ( af ( 1 , 1 , 1 ) [ 1 ] , 2 ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "FromPropertyDescriptor",
  "cond": "(! (= Desc[\"Enumerable\"] absent))",
  "covered": true,
  "inst": "if (! (= Desc[\"Enumerable\"] absent)) ... else ...",
  "thenCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;"
}, {
  "algo": "FromPropertyDescriptor",
  "cond": "(! (= Desc[\"Configurable\"] absent))",
  "covered": true,
  "inst": "if (! (= Desc[\"Configurable\"] absent)) ... else ...",
  "thenCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(! (contains functionNames fn))",
  "covered": true,
  "inst": "if (! (contains functionNames fn)) ... else ...",
  "thenCovered": "( function  ( a  , b  , c  ) { function getFunc (  ) { return \"genericPropertyString\" ; } function setFunc ( value  ) { this . helpVerifyGet = value ; } Object . defineProperty ( arguments , \"genericProperty\" , { get : getFunc , set : setFunc , configurable : false } ) ; try { Object . defineProperty ( arguments , \"genericProperty\" , { get : function  (  ) { return \"overideGenericPropertyString\" ; } } ) ; $ERROR ( \"Expected an exception.\" ) ; } catch ( e ) { if ( a !== 1 ) { $ERROR ( 'Expected a === 1, actually ' + a ) ; } verifyEqualTo ( arguments , \"genericProperty\" , getFunc ( ) ) ; verifyWritable ( arguments , \"genericProperty\" , \"helpVerifyGet\" ) ; verifyNotEnumerable ( arguments , \"genericProperty\" ) ; verifyNotConfigurable ( arguments , \"genericProperty\" ) ; if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } } ( 1 , 2 , 3 ) ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(contains parameterNames \"arguments\")",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (contains parameterNames \"arguments\") ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (contains functionNames \"arguments\") (contains lexicalNames \"arguments\"))",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (|| (contains functionNames \"arguments\") (contains lexicalNames \"arguments\")) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (= strict true) (= hasParameterExpressions false))",
  "covered": true,
  "inst": "if (|| (= strict true) (= hasParameterExpressions false)) ... else ...",
  "thenCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= alreadyDeclared false)",
  "covered": true,
  "inst": "if (= alreadyDeclared false) ... else ...",
  "thenCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= hasDuplicates true)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (= hasDuplicates true) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (= strict true) (= simpleParameterList false))",
  "covered": true,
  "inst": "if (|| (= strict true) (= simpleParameterList false)) ... else ...",
  "thenCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= strict true)",
  "covered": true,
  "inst": "if (= strict true) ... else ...",
  "thenCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= hasDuplicates true)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (= hasDuplicates true) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(! (contains instantiatedVarNames n))",
  "covered": true,
  "inst": "if (! (contains instantiatedVarNames n)) ... else ...",
  "thenCovered": "var probe  ; class C  { static set a ( _ = null ) { var x = 'inside' ; probe = function  (  ) { return x ; } ; } } C . a = null ; var x = 'outside' ; assert . sameValue ( probe ( ) , 'inside' ) ; assert . sameValue ( x , 'outside' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (! (contains parameterBindings n)) (contains functionNames n))",
  "covered": true,
  "inst": "if (|| (! (contains parameterBindings n)) (contains functionNames n)) ... else ...",
  "thenCovered": "var probe  ; class C  { static set a ( _ = null ) { var x = 'inside' ; probe = function  (  ) { return x ; } ; } } C . a = null ; var x = 'outside' ; assert . sameValue ( probe ( ) , 'inside' ) ; assert . sameValue ( x , 'outside' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= strict false)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (= strict false) ... else ..."
}, {
  "algo": "FunctionEnvironmentRecordDOTGetSuperBase",
  "cond": "(= home undefined)",
  "covered": true,
  "elseCovered": "class B  { method (  ) { return 1 ; } get x ( ) { return 2 ; } } class C extends B { method (  ) { assert . sameValue ( super . x , 2 , \"The value of `super.x` is `2`\" ) ; return super . method ( ) ; } } assert . sameValue ( new C ( ) . method ( ) , 1 , \"`new C().method()` returns `1`\" ) ;",
  "inst": "if (= home undefined) ... else ..."
}, {
  "algo": "FunctionEnvironmentRecordDOTHasSuperBinding",
  "cond": "(= envRec[\"ThisBindingStatus\"] CONST_lexical)",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function  (  ) { eval ( '\"use strict\"; unresolvable = null;' ) ; } ) ;",
  "inst": "if (= envRec[\"ThisBindingStatus\"] CONST_lexical) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTfrom",
  "cond": "(! (< k (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "var thisVals = [  ] ; var nextResult = { done : false , value : { } } ; var nextNextResult = { done : false , value : { } } ; var mapFn = function  (  ) { thisVals . push ( this ) ; } ; var items = { } ; var thisVal = { } ; items [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { var result = nextResult ; nextResult = nextNextResult ; nextNextResult = { done : true } ; return result ; } } ; } ; Array . from ( items , mapFn , thisVal ) ; assert . sameValue ( thisVals . length , 2 ) ; assert . sameValue ( thisVals [ 0 ] , thisVal , 'First iteration `this` value' ) ; assert . sameValue ( thisVals [ 1 ] , thisVal , 'Second iteration `this` value' ) ;",
  "inst": "if (! (< k (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTfrom",
  "cond": "(= __x28__ true)",
  "covered": true,
  "inst": "if (= __x28__ true) ... else ...",
  "thenCovered": "var arrayIndex = - 1 ; var originalLength = 7 ; var obj = { length : originalLength , 0 : 2 , 1 : 4 , 2 : 8 , 3 : 16 , 4 : 32 , 5 : 64 , 6 : 128 } ; var array = [  2 ,  4 ,  8 ,  16 ,  32 ,  64 ,  128 ] ; function mapFn ( value  , index  ) { arrayIndex ++ ; assert . sameValue ( value , obj [ arrayIndex ] , \"Value mismatch in mapFn at index \" + index + \".\" ) ; assert . sameValue ( index , arrayIndex , \"Index mismatch in mapFn.\" ) ; obj [ originalLength + arrayIndex ] = 2 * arrayIndex + 1 ; return obj [ arrayIndex ] ; } var a = Array . from ( obj , mapFn ) ; assert . sameValue ( a . length , array . length , \"Length mismatch.\" ) ; for ( var j = 0 ; j < a . length ; j ++ ) { assert . sameValue ( a [ j ] , array [ j ] , \"Element mismatch for array at index \" + j + \".\" ) ; }"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTconcat",
  "cond": "(! (< n (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "var x = { } ; x . concat = Array . prototype . concat ; var y = new Object ( ) ; var z = new Array ( 1 , 2 ) ; var arr = x . concat ( y , z , - 1 , true , \"NaN\" ) ; arr . getClass = Object . prototype . toString ; if ( arr . getClass ( ) !== \"[object \" + \"Array\" + \"]\" ) { $ERROR ( '#0: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr is Array object. Actual: ' + ( arr . getClass ( ) ) ) ; } if ( arr [ 0 ] !== x ) { $ERROR ( '#1: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr[0] === x. Actual: ' + ( arr [ 0 ] ) ) ; } if ( arr [ 1 ] !== y ) { $ERROR ( '#2: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr[1] === y. Actual: ' + ( arr [ 1 ] ) ) ; } if ( arr [ 2 ] !== 1 ) { $ERROR ( '#3: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr[2] === 1. Actual: ' + ( arr [ 2 ] ) ) ; } if ( arr [ 3 ] !== 2 ) { $ERROR ( '#4: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr[3] === 2. Actual: ' + ( arr [ 3 ] ) ) ; } if ( arr [ 4 ] !== - 1 ) { $ERROR ( '#5: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr[4] === -1. Actual: ' + ( arr [ 4 ] ) ) ; } if ( arr [ 5 ] !== true ) { $ERROR ( '#6: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr[5] === true. Actual: ' + ( arr [ 5 ] ) ) ; } if ( arr [ 6 ] !== \"NaN\" ) { $ERROR ( '#7: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr[6] === \"NaN\". Actual: ' + ( arr [ 6 ] ) ) ; } if ( arr . length !== 7 ) { $ERROR ( '#8: var x = {}; x.concat = Array.prototype.concat; var y = new Object(); var z = new Array(1,2); var arr = x.concat(y,z, -1, true, \"NaN\"); arr.length === 7. Actual: ' + ( arr . length ) ) ; }",
  "inst": "if (! (< n (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTfind",
  "cond": "(= __x4__ false)",
  "covered": true,
  "elseCovered": "var o = { length : 1 } ; Object . defineProperty ( o , 0 , { get : function  (  ) { throw new Test262Error ( ) ; } } ) ; assert . throws ( Test262Error , function  (  ) { [  ] . find . call ( o , function  (  ) {  } ) ; } ) ;",
  "inst": "if (= __x4__ false) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTfindIndex",
  "cond": "(= __x4__ false)",
  "covered": true,
  "elseCovered": "var arr = [  'Mike' ,  'Rick' ,  'Leo' ] ; var results = [  ] ; arr . findIndex ( function  ( kValue  , k  , O  ) { results . push ( arguments ) ; } ) ; assert . sameValue ( results . length , 3 ) ; var result = results [ 0 ] ; assert . sameValue ( result [ 0 ] , 'Mike' ) ; assert . sameValue ( result [ 1 ] , 0 ) ; assert . sameValue ( result [ 2 ] , arr ) ; assert . sameValue ( result . length , 3 ) ; result = results [ 1 ] ; assert . sameValue ( result [ 0 ] , 'Rick' ) ; assert . sameValue ( result [ 1 ] , 1 ) ; assert . sameValue ( result [ 2 ] , arr ) ; assert . sameValue ( result . length , 3 ) ; result = results [ 2 ] ; assert . sameValue ( result [ 0 ] , 'Leo' ) ; assert . sameValue ( result [ 1 ] , 2 ) ; assert . sameValue ( result [ 2 ] , arr ) ; assert . sameValue ( result . length , 3 ) ;",
  "inst": "if (= __x4__ false) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTslice",
  "cond": "(= kPresent true)",
  "covered": true,
  "inst": "if (= kPresent true) ... else ...",
  "thenCovered": "testWithTypedArrayConstructors ( function  ( TA  ) { var sample = new TA ( [  42 ] ) ; assert . sameValue ( Reflect . set ( sample , \"-1\" , 1 ) , false , \"-1\" ) ; assert . sameValue ( Reflect . set ( sample , \"1\" , 1 ) , false , \"1\" ) ; assert . sameValue ( Reflect . set ( sample , \"2\" , 1 ) , false , \"2\" ) ; assert . sameValue ( sample . hasOwnProperty ( \"-1\" ) , false , \"has no property [-1]\" ) ; assert . sameValue ( sample . hasOwnProperty ( \"1\" ) , false , \"has no property [1]\" ) ; assert . sameValue ( sample . hasOwnProperty ( \"2\" ) , false , \"has no property [2]\" ) ; } ) ;"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTsplice",
  "cond": "(= fromPresent true)",
  "covered": true,
  "inst": "if (= fromPresent true) ... else ...",
  "thenCovered": "var a = [  1 ] ; a . constructor = { } ; a . constructor [ Symbol . species ] = function  ( len  ) { var q = new Array ( 0 ) ; Object . defineProperty ( q , 0 , { value : 0 , writable : false , configurable : true , enumerable : false , } ) ; return q ; } ; var r = a . splice ( 0 ) ; verifyProperty ( r , 0 , { value : 1 , writable : true , configurable : true , enumerable : true , } ) ;"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTtoString",
  "cond": "(= result false)",
  "covered": true,
  "elseCovered": "var __str = new String ( new Array ( 1 , 2 , 3 ) ) ; if ( typeof __str !== \"object\" ) { $ERROR ( '#1: __str = new String(new Array(1,2,3)); typeof __str === \"object\". Actual: typeof __str ===' + typeof __str ) ; } if ( __str . constructor !== String ) { $ERROR ( '#1.5: __str = new String(new Array(1,2,3)); __str.constructor === String. Actual: __str.constructor ===' + __str . constructor ) ; } if ( __str != \"1,2,3\" ) { $ERROR ( '#2: __str = new String(new Array(1,2,3)); __str ==\"1,2,3\". Actual: __str ==' + __str ) ; }",
  "inst": "if (= result false) ... else ..."
}, {
  "algo": "GLOBALDOTAwaitFulfilledFunctions",
  "cond": "(= asyncContext[\"ReturnCont\"] absent)",
  "covered": true,
  "elseCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= asyncContext[\"ReturnCont\"] absent) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x NaN)",
  "covered": true,
  "elseCovered": "for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x NaN) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x Infinity)",
  "covered": true,
  "elseCovered": "for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x Infinity)",
  "covered": true,
  "elseCovered": "for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTbind",
  "cond": "(= targetHasLength true)",
  "covered": true,
  "inst": "if (= targetHasLength true) ... else ...",
  "thenCovered": "function foo (  ) {  } var obj = foo . bind ( { } ) ; assert . throws ( TypeError , function  (  ) { obj . caller ; } ) ;"
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTbind",
  "cond": "(! (= __x6__ Number))",
  "covered": true,
  "elseCovered": "function foo (  ) {  } var obj = foo . bind ( { } ) ; assert . throws ( TypeError , function  (  ) { obj . caller ; } ) ;",
  "inst": "if (! (= __x6__ Number)) ... else ..."
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTtoString",
  "cond": "(&& (= T \"String\") available)",
  "covered": true,
  "inst": "if (&& (= T \"String\") available) ... else ...",
  "thenCovered": "if ( ~ ( { } ) !== - 1 ) { $ERROR ( '#1: ~({}) === -1. Actual: ' + ( ~ ( { } ) ) ) ; } if ( ~ ( function  (  ) { return 1 ; } ) !== - 1 ) { $ERROR ( '#2: ~(function(){return 1}) === -1. Actual: ' + ( ~ ( function  (  ) { return 1 ; } ) ) ) ; }"
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTtoString",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "var obj = { toString : Function . prototype . toString } ; assert . throws ( TypeError , function  (  ) { String ( obj ) ; } ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(! (= __x0__ Object))",
  "covered": true,
  "elseCovered": "var expectedValue = { valueOf (  ) { throw new Test262Error ( \"expectedValue coerced\" ) ; } } ; var badArrayTypes = [  Uint8ClampedArray ,  Float32Array ,  Float64Array ] ; for ( var badArrayType of badArrayTypes ) { var typedArray = new badArrayType ( new SharedArrayBuffer ( 8 ) ) ; assert . throws ( TypeError , function  (  ) { Atomics . compareExchange ( typedArray , 0 , expectedValue , 0 ) ; } ) ; }",
  "inst": "if (! (= __x0__ Object)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(! (= a[\"TypedArrayName\"] absent))",
  "covered": true,
  "elseCovered": "var expectedValue = { valueOf (  ) { throw new Test262Error ( \"expectedValue coerced\" ) ; } } ; var badArrayTypes = [  Uint8ClampedArray ,  Float32Array ,  Float64Array ] ; for ( var badArrayType of badArrayTypes ) { var typedArray = new badArrayType ( new SharedArrayBuffer ( 8 ) ) ; assert . throws ( TypeError , function  (  ) { Atomics . compareExchange ( typedArray , 0 , expectedValue , 0 ) ; } ) ; }",
  "inst": "if (! (= a[\"TypedArrayName\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(= __x5__ true)",
  "covered": false,
  "inst": "if (= __x5__ true) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_StringIteratorPrototypeDOTnext",
  "cond": "(! (= __x0__ Object))",
  "covered": true,
  "elseCovered": "var result  ; var vals = 'string literal' ; result = [ , ] = vals ; assert . sameValue ( result , vals ) ;",
  "inst": "if (! (= __x0__ Object)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_StringIteratorPrototypeDOTnext",
  "cond": "(= s undefined)",
  "covered": true,
  "elseCovered": "var result  ; var vals = 'string literal' ; result = [ , ] = vals ; assert . sameValue ( result , vals ) ;",
  "inst": "if (= s undefined) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTisSafeInteger",
  "cond": "(! (< (- 9007199254740992i 1i) __x2__))",
  "covered": true,
  "elseCovered": "assert . sameValue ( Number . isSafeInteger ( 9007199254740992 ) , false , \"2**53\" ) ; assert . sameValue ( Number . isSafeInteger ( - 9007199254740992 ) , false , \"-(2**53)\" ) ;",
  "inst": "if (! (< (- 9007199254740992i 1i) __x2__)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(< x 0i)",
  "covered": false,
  "inst": "if (< x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(== x Infinity)",
  "covered": false,
  "inst": "if (== x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(|| (< f 0i) (< 100i f))",
  "covered": false,
  "inst": "if (|| (< f 0i) (< 100i f)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(== x 0i)",
  "covered": false,
  "inst": "if (== x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(! (= fractionDigits undefined))",
  "covered": false,
  "inst": "if (! (= fractionDigits undefined)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(! (== f 0i))",
  "covered": false,
  "inst": "if (! (== f 0i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(== e 0i)",
  "covered": false,
  "inst": "if (== e 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(< 0i e)",
  "covered": false,
  "inst": "if (< 0i e) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(|| (< f 0i) (< 100i f))",
  "covered": false,
  "inst": "if (|| (< f 0i) (< 100i f)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(< x 0i)",
  "covered": false,
  "inst": "if (< x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(! (< x 9223372036854775807i))",
  "covered": false,
  "inst": "if (! (< x 9223372036854775807i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(! (== f 0i))",
  "covered": false,
  "inst": "if (! (== f 0i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(! (< f k))",
  "covered": false,
  "inst": "if (! (< f k)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(= precision undefined)",
  "covered": false,
  "inst": "if (= precision undefined) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(< x 0i)",
  "covered": false,
  "inst": "if (< x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(== x Infinity)",
  "covered": false,
  "inst": "if (== x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(|| (< p 1i) (< 100i p))",
  "covered": false,
  "inst": "if (|| (< p 1i) (< 100i p)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(== x 0i)",
  "covered": false,
  "inst": "if (== x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(|| (< e (- 6i)) (! (< e p)))",
  "covered": false,
  "inst": "if (|| (< e (- 6i)) (! (< e p))) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(! (== p 1i))",
  "covered": false,
  "inst": "if (! (== p 1i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(< 0i e)",
  "covered": false,
  "inst": "if (< 0i e) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(== e (- p 1i))",
  "covered": false,
  "inst": "if (== e (- p 1i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(! (< e 0i))",
  "covered": false,
  "inst": "if (! (< e 0i)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTfreeze",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "var funObj = function  (  ) {  } ; Object . freeze ( funObj ) ; assert ( Object . isFrozen ( funObj ) , 'Object.isFrozen(funObj) !== true' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTgetOwnPropertyDescriptors",
  "cond": "(! (= descriptor undefined))",
  "covered": true,
  "inst": "if (! (= descriptor undefined)) ... else ...",
  "thenCovered": "var F = function  (  ) {  } ; F . prototype . a = { } ; F . prototype . b = { } ; var f = new F ( ) ; var bValue = { } ; f . b = bValue ; Object . defineProperty ( f , 'c' , { enumerable : false , configurable : true , writable : false , value : { } } ) ; var result = Object . getOwnPropertyDescriptors ( f ) ; assert . sameValue ( ! ! result . b , true , 'b has a descriptor' ) ; assert . sameValue ( ! ! result . c , true , 'c has a descriptor' ) ; assert . sameValue ( result . b . enumerable , true , 'b is enumerable' ) ; assert . sameValue ( result . b . configurable , true , 'b is configurable' ) ; assert . sameValue ( result . b . writable , true , 'b is writable' ) ; assert . sameValue ( result . b . value , bValue , 'b’s value is `bValue`' ) ; assert . sameValue ( result . c . enumerable , false , 'c is enumerable' ) ; assert . sameValue ( result . c . configurable , true , 'c is configurable' ) ; assert . sameValue ( result . c . writable , false , 'c is writable' ) ; assert . sameValue ( result . c . value , f . c , 'c’s value is `f.c`' ) ; assert . sameValue ( Object . keys ( result ) . length , 2 , 'result has same number of own property names as f' ) ;"
}, {
  "algo": "GLOBALDOTObjectDOTpreventExtensions",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "var obj = { } ; var testResult1 = true ; var testResult2 = true ; var preCheck = Object . isExtensible ( obj ) ; Object . preventExtensions ( obj ) ; testResult1 = Object . isExtensible ( obj ) ; Object . preventExtensions ( obj ) ; testResult2 = Object . isExtensible ( obj ) ; assert ( preCheck , 'preCheck !== true' ) ; assert . sameValue ( testResult1 , false , 'testResult1' ) ; assert . sameValue ( testResult2 , false , 'testResult2' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTprototypeDOTtoString",
  "cond": "(! (= O[\"DateValue\"] absent))",
  "covered": true,
  "elseCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;",
  "inst": "if (! (= O[\"DateValue\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTprototypeDOTtoString",
  "cond": "(! (= O[\"RegExpMatcher\"] absent))",
  "covered": true,
  "elseCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;",
  "inst": "if (! (= O[\"RegExpMatcher\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTseal",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "var strObj = new String ( \"a\" ) ; var preCheck = Object . isExtensible ( strObj ) ; Object . seal ( strObj ) ; assert ( preCheck , 'preCheck !== true' ) ; assert ( Object . isSealed ( strObj ) , 'Object.isSealed(strObj) !== true' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTPromise",
  "cond": "__x7__",
  "covered": true,
  "elseCovered": "var constructorFunction  ; var promise = new class  extends Promise { constructor ( executor  ) { if ( constructorFunction ) { constructorFunction ( executor ) ; return { } ; } return super ( executor ) ; } } ( function  (  ) {  } ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; } ; promise . then ( ) ; } , \"executor not called at all\" ) ; assert . sameValue ( checkPoint , \"a\" , \"executor not called at all\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with no arguments\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with no arguments\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( undefined , undefined ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (undefined, undefined)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (undefined, undefined)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( undefined , function  (  ) {  } ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (undefined, function)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (undefined, function)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( function  (  ) {  } , undefined ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (function, undefined)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (function, undefined)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( 123 , \"invalid value\" ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (Number, String)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (Number, String)\" ) ;",
  "inst": "if __x7__ ... else ..."
}, {
  "algo": "GLOBALDOTPromiseDOTallSettledRejectElementFunctions",
  "cond": "(= alreadyCalled[\"Value\"] true)",
  "covered": true,
  "elseCovered": "var p1 = Promise . resolve ( 1 ) ; var p2 = Promise . resolve ( 1 ) ; var p3 = Promise . reject ( 1 ) ; var p4 = Promise . resolve ( 1 ) ; var resolve = Promise . resolve ; var getCount = 0 ; var callCount = 0 ; Object . defineProperty ( Promise , 'resolve' , { configurable : true , get (  ) { getCount += 1 ; return function  (  ) { callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; } } ) ; Promise . allSettled ( [  p1 ,  p2 ,  p3 ,  p4 ] ) ; assert . sameValue ( getCount , 1 , 'Got `resolve` only once for each iterated value' ) ; assert . sameValue ( callCount , 4 , '`resolve` invoked once for each iterated value' ) ;",
  "inst": "if (= alreadyCalled[\"Value\"] true) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseDOTallSettledRejectElementFunctions",
  "cond": "(= remainingElementsCount[\"Value\"] 0i)",
  "covered": true,
  "elseCovered": "var p1 = Promise . resolve ( 1 ) ; var p2 = Promise . resolve ( 1 ) ; var p3 = Promise . reject ( 1 ) ; var p4 = Promise . resolve ( 1 ) ; var resolve = Promise . resolve ; var getCount = 0 ; var callCount = 0 ; Object . defineProperty ( Promise , 'resolve' , { configurable : true , get (  ) { getCount += 1 ; return function  (  ) { callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; } } ) ; Promise . allSettled ( [  p1 ,  p2 ,  p3 ,  p4 ] ) ; assert . sameValue ( getCount , 1 , 'Got `resolve` only once for each iterated value' ) ; assert . sameValue ( callCount , 4 , '`resolve` invoked once for each iterated value' ) ;",
  "inst": "if (= remainingElementsCount[\"Value\"] 0i) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseResolveFunctions",
  "cond": "(= __x2__ true)",
  "covered": true,
  "elseCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= __x2__ true) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseResolveFunctions",
  "cond": "__x9__",
  "covered": true,
  "elseCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if __x9__ ... else ..."
}, {
  "algo": "GLOBALDOTSetDOTprototypeDOTdelete",
  "cond": "__x4__",
  "covered": true,
  "inst": "if __x4__ ... else ...",
  "thenCovered": "var s = new Set ( [  - 0 ] ) ; assert . sameValue ( s . size , 1 , \"The value of `s.size` is `1`\" ) ; var result = s . delete ( + 0 ) ; assert . sameValue ( s . size , 0 , \"The value of `s.size` is `0`, after executing `s.delete(-0)`\" ) ; assert . sameValue ( result , true , \"The result of `s.delete(+0)` is `true`\" ) ;"
}, {
  "algo": "GLOBALDOTStringDOTfromCharCode",
  "cond": "(< nextIndex length)",
  "covered": false,
  "inst": "while (< nextIndex length) { ... }"
}, {
  "algo": "GLOBALDOTStringDOTfromCodePoint",
  "cond": "(< nextIndex length)",
  "covered": false,
  "inst": "while (< nextIndex length) { ... }"
}, {
  "algo": "GLOBALDOTStringDOTfromCodePoint",
  "cond": "(= __x1__ false)",
  "covered": false,
  "inst": "if (= __x1__ false) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTfromCodePoint",
  "cond": "(|| (< nextCP 0i) (< 1114111i nextCP))",
  "covered": false,
  "inst": "if (|| (< nextCP 0i) (< 1114111i nextCP)) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTfromCodePoint",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": false,
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTcharCodeAt",
  "cond": "(|| (< position 0i) (! (< position size)))",
  "covered": false,
  "inst": "if (|| (< position 0i) (! (< position size))) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTendsWith",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "var str = 'The future is cool!' ; assert . sameValue ( str . endsWith ( 'is cool!' , str . length - 1 ) , false , 'str.endsWith(\"is cool!\", str.length - 1) === false' ) ; assert . sameValue ( str . endsWith ( '!' , 1 ) , false , 'str.endsWith(\"!\", 1) === false' ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTincludes",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "assert . sameValue ( 'word' . includes ( 'a' , 0 ) , false , '\"word\".includes(\"a\", 0)' ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "var obj = { } ; var returnVal = { } ; var callCount = 0 ; var thisVal  , args  ; obj [ Symbol . matchAll ] = function  (  ) { callCount ++ ; thisVal = this ; args = arguments ; return returnVal ; } ; var str = '' ; assert . sameValue ( str . matchAll ( obj ) , returnVal ) ; assert . sameValue ( callCount , 1 , 'Invokes the method exactly once' ) ; assert . sameValue ( thisVal , obj ) ; assert . notSameValue ( args , undefined ) ; assert . sameValue ( args . length , 1 ) ; assert . sameValue ( args [ 0 ] , str ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(! (contains __x5__ \"g\"))",
  "covered": false,
  "inst": "if (! (contains __x5__ \"g\")) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(! (= matcher undefined))",
  "covered": true,
  "inst": "if (! (= matcher undefined)) ... else ...",
  "thenCovered": "var obj = { } ; var returnVal = { } ; var callCount = 0 ; var thisVal  , args  ; obj [ Symbol . matchAll ] = function  (  ) { callCount ++ ; thisVal = this ; args = arguments ; return returnVal ; } ; var str = '' ; assert . sameValue ( str . matchAll ( obj ) , returnVal ) ; assert . sameValue ( callCount , 1 , 'Invokes the method exactly once' ) ; assert . sameValue ( thisVal , obj ) ; assert . notSameValue ( args , undefined ) ; assert . sameValue ( args . length , 1 ) ; assert . sameValue ( args [ 0 ] , str ) ;"
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTreplace",
  "cond": "(! (|| (= searchValue undefined) (= searchValue null)))",
  "covered": false,
  "inst": "if (! (|| (= searchValue undefined) (= searchValue null))) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTreplace",
  "cond": "(! (= replacer undefined))",
  "covered": false,
  "inst": "if (! (= replacer undefined)) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTreplace",
  "cond": "(= functionalReplace false)",
  "covered": false,
  "inst": "if (= functionalReplace false) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTreplace",
  "cond": "(= functionalReplace true)",
  "covered": false,
  "inst": "if (= functionalReplace true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTstartsWith",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "var str = 'The future is cool!' ; assert . sameValue ( str . startsWith ( 'Flash' ) , false , 'str.startsWith(\"Flash\") === false' ) ; assert . sameValue ( str . startsWith ( 'THE FUTURE' ) , false , 'startsWith is case sensitive' ) ; assert . sameValue ( str . startsWith ( 'future is cool!' ) , false , 'str.startsWith(\"future is cool!\") === false' ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTraw",
  "cond": "(! (< 0i literalSegments))",
  "covered": false,
  "inst": "if (! (< 0i literalSegments)) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTraw",
  "cond": "(== (+ nextIndex 1i) literalSegments)",
  "covered": false,
  "inst": "if (== (+ nextIndex 1i) literalSegments) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTraw",
  "cond": "(< nextIndex numberOfSubstitutions)",
  "covered": false,
  "inst": "if (< nextIndex numberOfSubstitutions) ... else ..."
}, {
  "algo": "GLOBALDOTSymbolDOTkeyFor",
  "cond": "(= cond true)",
  "covered": true,
  "inst": "if (= cond true) ... else ...",
  "thenCovered": "var canonical = Symbol . for ( 's' ) ; assert . sameValue ( Symbol . keyFor ( canonical ) , 's' ) ;"
}, {
  "algo": "GLOBALDOTSyntaxError",
  "cond": "(= NewTarget undefined)",
  "covered": true,
  "elseCovered": "assert . sameValue ( Object . getPrototypeOf ( new SyntaxError ) , SyntaxError . prototype ) ;",
  "inst": "if (= NewTarget undefined) ... else ..."
}, {
  "algo": "GLOBALDOTWeakMapDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "var map = new WeakMap ( ) ; var key = { } ; assert . sameValue ( map . get ( key ) , undefined , 'returns undefined if key is not on the weakmap' ) ; map . set ( key , 1 ) ; map . set ( { } , 2 ) ; map . delete ( key ) ; map . set ( { } , 3 ) ; assert . sameValue ( map . get ( key ) , undefined , 'returns undefined if key was deleted' ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTadd",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "var foo = { } ; var s = new WeakSet ( [  foo ] ) ; assert . sameValue ( s . add ( foo ) , s , '`s.add(foo)` returns `s`' ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "var foo = { } ; var bar = { } ; var s = new WeakSet ( ) ; assert . sameValue ( s . has ( foo ) , false ) ; s . add ( foo ) ; assert . sameValue ( s . has ( bar ) , false ) ; s . delete ( foo ) ; assert . sameValue ( s . has ( foo ) , false ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "var foo = { } ; var bar = { } ; var s = new WeakSet ( ) ; assert . sameValue ( s . has ( foo ) , false ) ; s . add ( foo ) ; assert . sameValue ( s . has ( bar ) , false ) ; s . delete ( foo ) ; assert . sameValue ( s . has ( foo ) , false ) ;"
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(! (== R 0i))",
  "covered": false,
  "inst": "if (! (== R 0i)) ... else ..."
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(|| (< R 2i) (< 36i R))",
  "covered": false,
  "inst": "if (|| (< R 2i) (< 36i R)) ... else ..."
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(! (== R 16i))",
  "covered": false,
  "inst": "if (! (== R 16i)) ... else ..."
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(= stripPrefix true)",
  "covered": false,
  "inst": "if (= stripPrefix true) ... else ..."
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(= Z[\"length\"] 0i)",
  "covered": false,
  "inst": "if (= Z[\"length\"] 0i) ... else ..."
}, {
  "algo": "GeneratorResumeAbrupt",
  "cond": "(= genContext[\"ReturnCont\"] absent)",
  "covered": true,
  "elseCovered": "function * values (  ) { yield 1 ; $ERROR ( 'This code is unreachable (following `yield` statement).' ) ; } var iterator = values ( ) ; var i = 0 ; var result = ( function  (  ) { for ( var x of iterator ) { i ++ ; return 34 ; $ERROR ( 'This code is unreachable (following `return` statement).' ) ; } $ERROR ( 'This code is unreachable (following `for..of` statement).' ) ; } ) ( ) ; assert . sameValue ( result , 34 ) ; assert . sameValue ( i , 1 ) ;",
  "inst": "if (= genContext[\"ReturnCont\"] absent) ... else ..."
}, {
  "algo": "GeneratorStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "var doneCallCount = 0 ; var iter = { } ; iter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { value : null , done : false } ; } , return : function  (  ) { doneCallCount += 1 ; return { } ; } } ; } ; var callCount = 0 ; var f  ; f = function *  ( [  x  ] = iter ) { assert . sameValue ( doneCallCount , 1 ) ; callCount = callCount + 1 ; } ; f ( ) . next ( ) ; assert . sameValue ( callCount , 1 , 'generator function invoked exactly once' ) ;"
}, {
  "algo": "GeneratorYield",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "function * g (  ) { actual = yield ; } var expected = { } ; var iter = g ( ) ; var actual  , result  ; result = iter . next ( ) ; assert . sameValue ( result . value , undefined , 'First result `value`' ) ; assert . sameValue ( result . done , false , 'First result `done` flag' ) ; assert . sameValue ( actual , undefined , 'Value of `yield` expression (prior to continuation)' ) ; result = iter . next ( expected ) ; assert . sameValue ( result . value , undefined , 'Second result `value`' ) ; assert . sameValue ( result . done , true , 'Second result `done` flag' ) ; assert . sameValue ( actual , expected , 'Value of `yield` expression (following continuation)' ) ;"
}, {
  "algo": "GetActiveScriptOrModule",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "GetActiveScriptOrModule",
  "cond": "(! (< k 0i))",
  "covered": true,
  "inst": "while (! (< k 0i)) { ... }",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= (typeof obj) \"BoundFunctionExoticObject\")",
  "covered": true,
  "elseCovered": "class FooPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . resolve ( ) . finally ( ( ) => FooPromise . resolve ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof FooPromise , false ) ;",
  "inst": "if (= (typeof obj) \"BoundFunctionExoticObject\") ... else ..."
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= (typeof obj) \"ProxyExoticObject\")",
  "covered": true,
  "elseCovered": "class FooPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . resolve ( ) . finally ( ( ) => FooPromise . resolve ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof FooPromise , false ) ;",
  "inst": "if (= (typeof obj) \"ProxyExoticObject\") ... else ..."
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= obj[\"ProxyHandler\"] null)",
  "covered": false,
  "inst": "if (= obj[\"ProxyHandler\"] null) ... else ..."
}, {
  "algo": "GetIterator",
  "cond": "(= method undefined)",
  "covered": true,
  "inst": "if (= method undefined) ... else ...",
  "thenCovered": "function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%String.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%String.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Array.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Array.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Boolean.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Boolean.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Number.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Number.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Map.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Map.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Set.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Set.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%WeakMap.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%WeakMap.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%WeakSet.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%WeakSet.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Error.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Error.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%EvalError.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%EvalError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%ReferenceError.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%ReferenceError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%SyntaxError.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%SyntaxError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%TypeError.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%TypeError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%URIError.prototype%\")",
  "covered": true,
  "elseCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;",
  "inst": "if (= intrinsicDefaultProto \"%URIError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%AsyncGenerator.prototype%\")",
  "covered": true,
  "inst": "if (= intrinsicDefaultProto \"%AsyncGenerator.prototype%\") ... else ...",
  "thenCovered": "var fn = async function *  (  ) {  } ; var AsyncGeneratorPrototype = Object . getPrototypeOf ( fn . prototype ) ; fn . prototype = undefined ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is undefined' ) ; fn . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is null' ) ; fn . prototype = false ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Boolean' ) ; fn . prototype = '' ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a String' ) ; fn . prototype = Symbol ( ) ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Symbol' ) ; fn . prototype = 1 ; assert . sameValue ( Object . getPrototypeOf ( fn ( ) ) , AsyncGeneratorPrototype , 'fn.prototype is a Number' ) ;"
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Promise.prototype%\")",
  "covered": false,
  "inst": "if (= intrinsicDefaultProto \"%Promise.prototype%\") ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x4__ true)",
  "covered": true,
  "elseCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;",
  "inst": "if (= __x4__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x6__ true)",
  "covered": true,
  "elseCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;",
  "inst": "if (= __x6__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= hasRestrictedGlobal true)",
  "covered": true,
  "elseCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;",
  "inst": "if (= hasRestrictedGlobal true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x12__ true)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= __x12__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= fnDefinable false)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= fnDefinable false) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= vnDefinable false)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= vnDefinable false) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCanDeclareGlobalFunction",
  "cond": "(= existingProp[\"Configurable\"] true)",
  "covered": true,
  "inst": "if (= existingProp[\"Configurable\"] true) ... else ...",
  "thenCovered": "function Array (  ) {  } var o = { x : 1 , y : 2 } ; var a = Object . keys ( o ) ; var s = Object . prototype . toString . call ( a ) ; assert . sameValue ( s , '[object Array]' , 's' ) ;"
}, {
  "algo": "GlobalEnvironmentRecordDOTCanDeclareGlobalFunction",
  "cond": "(&& (&& (= result true) (= existingProp[\"Writable\"] true)) (= existingProp[\"Enumerable\"] true))",
  "covered": false,
  "inst": "if (&& (&& (= result true) (= existingProp[\"Writable\"] true)) (= existingProp[\"Enumerable\"] true)) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(|| (= existingProp undefined) (= existingProp[\"Configurable\"] true))",
  "covered": true,
  "inst": "if (|| (= existingProp undefined) (= existingProp[\"Configurable\"] true)) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(! (= ObjRec[\"SubMap\"][N] absent))",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (! (= ObjRec[\"SubMap\"][N] absent)) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(! (contains varDeclaredNames N))",
  "covered": true,
  "inst": "if (! (contains varDeclaredNames N)) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalVarBinding",
  "cond": "(! (contains varDeclaredNames N))",
  "covered": true,
  "inst": "if (! (contains varDeclaredNames N)) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateImmutableBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "const buffer = new ArrayBuffer ( 16 ) ; const views = intArrayConstructors . slice ( ) ; testWithTypedArrayConstructors ( function  ( TA  ) { assert . throws ( TypeError , function  (  ) { Atomics . or ( new TA ( buffer ) , 0 , 0 ) ; } , '`Atomics.or(new TA(buffer), 0, 0)` throws TypeError' ) ; } , views ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateMutableBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTHasRestrictedGlobalProperty",
  "cond": "(= existingProp undefined)",
  "covered": true,
  "inst": "if (= existingProp undefined) ... else ...",
  "thenCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;"
}, {
  "algo": "GlobalEnvironmentRecordDOTHasRestrictedGlobalProperty",
  "cond": "(= existingProp[\"Configurable\"] true)",
  "covered": false,
  "inst": "if (= existingProp[\"Configurable\"] true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTHasVarDeclaration",
  "cond": "(contains varDeclaredNames N)",
  "covered": true,
  "elseCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;",
  "inst": "if (contains varDeclaredNames N) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTInitializeBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "inst": "if (= __x0__ true) ... else ...",
  "thenCovered": "var stringSet  ; class C  { static get 0b10 ( ) { return 'get string' ; } static set 0b10 ( param  ) { stringSet = param ; } } assert . sameValue ( C [ '2' ] , 'get string' ) ; C [ '2' ] = 'set string' ; assert . sameValue ( stringSet , 'set string' ) ;"
}, {
  "algo": "InitializeBoundName",
  "cond": "(! (= environment undefined))",
  "covered": true,
  "inst": "if (! (= environment undefined)) ... else ...",
  "thenCovered": "verifyProperty ( String . prototype . toString , 'length' , { value : 0 , writable : false , enumerable : false , configurable : true , } ) ;"
}, {
  "algo": "InstanceofOperator",
  "cond": "(= __x6__ false)",
  "covered": true,
  "inst": "if (= __x6__ false) ... else ...",
  "thenCovered": "try { ( { } ) instanceof this ; $ERROR ( '#1: Only Function objects implement [[HasInstance]] and consequently can be proper ShiftExpression for The instanceof operator' ) ; } catch ( e ) { if ( e instanceof TypeError !== true ) { $ERROR ( '#1: Only Function objects implement [[HasInstance]] and consequently can be proper ShiftExpression for The instanceof operator' ) ; } }"
}, {
  "algo": "IsAccessorDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsArray",
  "cond": "(= (typeof argument) \"ProxyExoticObject\")",
  "covered": true,
  "elseCovered": "function callbackfn ( val  , idx  , obj  ) { return val < 10 ; } var obj = { 0 : 11 , 1 : 9 , 2 : 12 , length : \"2.5\" } ; var newArr = Array . prototype . map . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ;",
  "inst": "if (= (typeof argument) \"ProxyExoticObject\") ... else ..."
}, {
  "algo": "IsArray",
  "cond": "(= argument[\"ProxyHandler\"] null)",
  "covered": false,
  "inst": "if (= argument[\"ProxyHandler\"] null) ... else ..."
}, {
  "algo": "IsDataDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsDuplicate",
  "cond": "(= list[i] list[j])",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (= list[i] list[j]) ... else ..."
}, {
  "algo": "IsGenericDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of __x1__ AsyncConciseBody)",
  "covered": true,
  "elseCovered": "var uriReserved = [  \"%3B\" ,  \"%2F\" ,  \"%3F\" ,  \"%3A\" ,  \"%40\" ,  \"%26\" ,  \"%3D\" ,  \"%2B\" ,  \"%24\" ,  \"%2C\" ] ; var uriReserved_ = [  \";\" ,  \"/\" ,  \"?\" ,  \":\" ,  \"@\" ,  \"&\" ,  \"=\" ,  \"+\" ,  \"$\" ,  \",\" ] ; for ( var indexC = 0 ; indexC < 10 ; indexC ++ ) { var str = uriReserved_ [ indexC ] ; if ( encodeURIComponent ( str ) !== uriReserved [ indexC ] ) { $ERROR ( '#' + ( indexC + 1 ) + ': unescapedURIComponentSet not containing' + str ) ; } }",
  "inst": "if (is-instance-of __x1__ AsyncConciseBody) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of __x3__ AsyncConciseBody)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (is-instance-of __x3__ AsyncConciseBody) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of body AsyncConciseBody)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (is-instance-of body AsyncConciseBody) ... else ..."
}, {
  "algo": "IsNonNegativeInteger",
  "cond": "(&& (= __x0__ true) (! (< argument 0i)))",
  "covered": true,
  "inst": "if (&& (= __x0__ true) (! (< argument 0i))) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "IsPropertyKey",
  "cond": "(= __x2__ Symbol)",
  "covered": true,
  "inst": "if (= __x2__ Symbol) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "IsRegExp",
  "cond": "(! (= matcher undefined))",
  "covered": true,
  "elseCovered": "var obj = { toString : function  (  ) { throw new Test262Error ( ) ; } } ; assert . throws ( Test262Error , function  (  ) { '' . includes ( obj ) ; } ) ;",
  "inst": "if (! (= matcher undefined)) ... else ..."
}, {
  "algo": "IsRegExp",
  "cond": "(! (= argument[\"RegExpMatcher\"] absent))",
  "covered": true,
  "elseCovered": "var obj = { toString : function  (  ) { throw new Test262Error ( ) ; } } ; assert . throws ( Test262Error , function  (  ) { '' . includes ( obj ) ; } ) ;",
  "inst": "if (! (= argument[\"RegExpMatcher\"] absent)) ... else ..."
}, {
  "algo": "LabelledItem0TopLevelVarDeclaredNames0",
  "cond": "(is-instance-of Statement Statement10)",
  "covered": true,
  "elseCovered": "function * values (  ) { yield 1 ; $ERROR ( 'This code is unreachable (following `yield` statement).' ) ; } var iterator = values ( ) ; var i = 0 ; outer : while ( true ) { for ( var x of iterator ) { try { i ++ ; break outer ; $ERROR ( 'This code is unreachable (following `break` statement).' ) ; } catch ( err ) {  } $ERROR ( 'This code is unreachable (following `try` statement).' ) ; } $ERROR ( 'This code is unreachable (following `for..of` statement).' ) ; } assert . sameValue ( i , 1 ) ;",
  "inst": "if (is-instance-of Statement Statement10) ... else ..."
}, {
  "algo": "LabelledItem0TopLevelVarScopedDeclarations0",
  "cond": "(is-instance-of Statement Statement10)",
  "covered": true,
  "elseCovered": "function * values (  ) { yield 1 ; $ERROR ( 'This code is unreachable (following `yield` statement).' ) ; } var iterator = values ( ) ; var i = 0 ; outer : while ( true ) { for ( var x of iterator ) { try { i ++ ; break outer ; $ERROR ( 'This code is unreachable (following `break` statement).' ) ; } catch ( err ) {  } $ERROR ( 'This code is unreachable (following `try` statement).' ) ; } $ERROR ( 'This code is unreachable (following `for..of` statement).' ) ; } assert . sameValue ( i , 1 ) ;",
  "inst": "if (is-instance-of Statement Statement10) ... else ..."
}, {
  "algo": "MakeBasicObject",
  "cond": "(contains internalSlotsList \"Extensible\")",
  "covered": true,
  "inst": "if (contains internalSlotsList \"Extensible\") ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "MemberExpression3HasCallInTailPosition0",
  "cond": "(= this call)",
  "covered": true,
  "inst": "if (= this call) ... else ...",
  "thenCovered": "( function  (  ) { var finished = false ; function f ( _  , n  ) { if ( n === 0 ) { finished = true ; return ; } return f `${ n - 1 }` ; } f ( null , $MAX_ITERATIONS ) ; return finished ; } ( ) ) ;"
}, {
  "algo": "ObjectEnvironmentRecordDOTGetBindingValue",
  "cond": "(= value false)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= value false) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTGetBindingValue",
  "cond": "(= S false)",
  "covered": false,
  "inst": "if (= S false) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= envRec[\"withEnvironment\"] false)",
  "covered": true,
  "inst": "if (= envRec[\"withEnvironment\"] false) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= __x4__ Object)",
  "covered": false,
  "inst": "if (= __x4__ Object) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= blocked true)",
  "covered": false,
  "inst": "if (= blocked true) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTInitializeBinding",
  "cond": "(! (= envRec[\"SubMap\"][N] absent))",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (! (= envRec[\"SubMap\"][N] absent)) ... else ..."
}, {
  "algo": "OrdinaryCallBindThis",
  "cond": "(= thisMode CONST_strict)",
  "covered": true,
  "inst": "if (= thisMode CONST_strict) ... else ...",
  "thenCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;"
}, {
  "algo": "OrdinaryCallBindThis",
  "cond": "(|| (= thisArgument undefined) (= thisArgument null))",
  "covered": false,
  "inst": "if (|| (= thisArgument undefined) (= thisArgument null)) ... else ..."
}, {
  "algo": "OrdinaryFunctionCreate",
  "cond": "(= Strict true)",
  "covered": true,
  "inst": "if (= Strict true) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "var proto = { method (  ) { return 42 ; } } ; var object = { * g (  ) { yield super . method ( ) ; } } ; Object . setPrototypeOf ( object , proto ) ; assert . sameValue ( object . g ( ) . next ( ) . value , 42 , \"The value of `object.g().next().value` is `42`, after executing `Object.setPrototypeOf(object, proto);`, where `object \" + String ( object ) + \"`\" ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(= __x3__ true)",
  "covered": true,
  "elseCovered": "var proto = { method (  ) { return 42 ; } } ; var object = { * g (  ) { yield super . method ( ) ; } } ; Object . setPrototypeOf ( object , proto ) ; assert . sameValue ( object . g ( ) . next ( ) . value , 42 , \"The value of `object.g().next().value` is `42`, after executing `Object.setPrototypeOf(object, proto);`, where `object \" + String ( object ) + \"`\" ) ;",
  "inst": "if (= __x3__ true) ... else ..."
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(! (= p[\"GetProtoTypeOf\"] OrdinaryObjectDOTGetPrototypeOf))",
  "covered": true,
  "inst": "if (! (= p[\"GetProtoTypeOf\"] OrdinaryObjectDOTGetPrototypeOf)) ... else ...",
  "thenCovered": "var proto = { method (  ) { return 42 ; } } ; var object = { * g (  ) { yield super . method ( ) ; } } ; Object . setPrototypeOf ( object , proto ) ; assert . sameValue ( object . g ( ) . next ( ) . value , 42 , \"The value of `object.g().next().value` is `42`, after executing `Object.setPrototypeOf(object, proto);`, where `object \" + String ( object ) + \"`\" ) ;"
}, {
  "algo": "OrdinarySetWithOwnDescriptor",
  "cond": "(= __x9__ true)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= __x9__ true) ... else ..."
}, {
  "algo": "OrdinarySetWithOwnDescriptor",
  "cond": "(= existingDescriptor[\"Writable\"] false)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= existingDescriptor[\"Writable\"] false) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "(= F[\"ConstructorKind\"] CONST_derived)",
  "covered": true,
  "elseCovered": "assert . throws ( ReferenceError , function  (  ) { eval ( '\"use strict\"; unresolvable = null;' ) ; } ) ;",
  "inst": "if (= F[\"ConstructorKind\"] CONST_derived) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "__x17__",
  "covered": true,
  "inst": "if __x17__ ... else ...",
  "thenCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= strictEval true)",
  "covered": true,
  "inst": "if (= strictEval true) ... else ...",
  "thenCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= runningContext null)",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;",
  "inst": "if (= runningContext null) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] evalContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] evalContext) ... else ...",
  "thenCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "assert . sameValue ( eval ( 'var test262id1;' ) , undefined , 'Single declaration without initializer' ) ; assert . sameValue ( eval ( 'var test262id2 = 2;' ) , undefined , 'Single declaration bearing initializer' ) ; assert . sameValue ( eval ( 'var test262id3 = 3, test262id4;' ) , undefined , 'Multiple declarations, final without initializer' ) ; assert . sameValue ( eval ( 'var test262id5, test262id6 = 6;' ) , undefined , 'Multiple declarations, final bearing initializer' ) ; assert . sameValue ( eval ( '7; var test262id8;' ) , 7 ) ; assert . sameValue ( eval ( '9; var test262id10 = 10;' ) , 9 ) ; assert . sameValue ( eval ( '11; var test262id12 = 12, test262id13;' ) , 11 ) ; assert . sameValue ( eval ( '14; var test262id15, test262id16 = 16;' ) , 14 ) ;",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "PerformPromiseAll",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "var checkPoint = \"\" ; function fn1 ( executor  ) { checkPoint += \"a\" ; executor ( ) ; checkPoint += \"b\" ; executor ( function  (  ) {  } , function  (  ) {  } ) ; checkPoint += \"c\" ; } fn1 . resolve = function  (  ) {  } ; Promise . all . call ( fn1 , [  ] ) ; assert . sameValue ( checkPoint , \"abc\" , \"executor initially called with no arguments\" ) ; checkPoint = \"\" ; function fn2 ( executor  ) { checkPoint += \"a\" ; executor ( undefined , undefined ) ; checkPoint += \"b\" ; executor ( function  (  ) {  } , function  (  ) {  } ) ; checkPoint += \"c\" ; } fn2 . resolve = function  (  ) {  } ; Promise . all . call ( fn2 , [  ] ) ; assert . sameValue ( checkPoint , \"abc\" , \"executor initially called with (undefined, undefined)\" ) ; checkPoint = \"\" ; function fn3 ( executor  ) { checkPoint += \"a\" ; executor ( undefined , function  (  ) {  } ) ; checkPoint += \"b\" ; executor ( function  (  ) {  } , function  (  ) {  } ) ; checkPoint += \"c\" ; } Object . defineProperty ( fn3 , 'resolve' , { get (  ) { throw new Test262Error ; } } ) ; assert . throws ( TypeError , function  (  ) { Promise . all . call ( fn3 , [  ] ) ; } , \"executor initially called with (undefined, function)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor initially called with (undefined, function)\" ) ; checkPoint = \"\" ; function fn4 ( executor  ) { checkPoint += \"a\" ; executor ( function  (  ) {  } , undefined ) ; checkPoint += \"b\" ; executor ( function  (  ) {  } , function  (  ) {  } ) ; checkPoint += \"c\" ; } Object . defineProperty ( fn4 , 'resolve' , { get (  ) { throw new Test262Error ; } } ) ; assert . throws ( TypeError , function  (  ) { Promise . all . call ( fn4 , [  ] ) ; } , \"executor initially called with (function, undefined)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor initially called with (function, undefined)\" ) ; checkPoint = \"\" ; function fn5 ( executor  ) { checkPoint += \"a\" ; executor ( \"invalid value\" , 123 ) ; checkPoint += \"b\" ; executor ( function  (  ) {  } , function  (  ) {  } ) ; checkPoint += \"c\" ; } Object . defineProperty ( fn5 , 'resolve' , { get (  ) { throw new Test262Error ; } } ) ; assert . throws ( TypeError , function  (  ) { Promise . all . call ( fn5 , [  ] ) ; } , \"executor initially called with (String, Number)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor initially called with (String, Number)\" ) ;",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseAllSettled",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "var promise = new Promise ( function  (  ) {  } ) ; var returnCount = 0 ; var iter = { } ; iter [ Symbol . iterator ] = function  (  ) { return { next (  ) { return { done : false , value : promise } ; } , return (  ) { returnCount += 1 ; return { } ; } } ; } ; Object . defineProperty ( promise , 'then' , { get (  ) { throw new Test262Error ( ) ; } } ) ; Promise . allSettled ( iter ) ; assert . sameValue ( returnCount , 1 ) ;",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseRace",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "function resolveFunction (  ) {  } function Constructor ( executor  ) { executor ( resolveFunction , $ERROR ) ; } Constructor . resolve = function  ( v  ) { return v ; } ; var callCount1 = 0 , callCount2 = 0 ; var p1 = { then : function  ( onFulfilled  , onRejected  ) { callCount1 += 1 ; assert . sameValue ( onFulfilled , resolveFunction , \"p1.then\" ) ; } } ; var p2 = { then : function  ( onFulfilled  , onRejected  ) { callCount2 += 1 ; assert . sameValue ( onFulfilled , resolveFunction , \"p2.then\" ) ; } } ; Promise . race . call ( Constructor , [  p1 ,  p2 ] ) ; assert . sameValue ( callCount1 , 1 , \"p1.then call count\" ) ; assert . sameValue ( callCount2 , 1 , \"p2.then call count\" ) ;",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseThen",
  "cond": "(= promise[\"PromiseIsHandled\"] false)",
  "covered": true,
  "inst": "if (= promise[\"PromiseIsHandled\"] false) ... else ...",
  "thenCovered": "var p1 = Promise . resolve ( 1 ) ; var p2 = Promise . resolve ( 1 ) ; var p3 = Promise . reject ( 1 ) ; var p4 = Promise . resolve ( 1 ) ; var resolve = Promise . resolve ; var getCount = 0 ; var callCount = 0 ; Object . defineProperty ( Promise , 'resolve' , { configurable : true , get (  ) { getCount += 1 ; return function  (  ) { callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; } } ) ; Promise . allSettled ( [  p1 ,  p2 ,  p3 ,  p4 ] ) ; assert . sameValue ( getCount , 1 , 'Got `resolve` only once for each iterated value' ) ; assert . sameValue ( callCount , 4 , '`resolve` invoked once for each iterated value' ) ;"
}, {
  "algo": "PrepareForOrdinaryCall",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "PrepareForTailCall",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] leafContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] leafContext) ... else ...",
  "thenCovered": "function callbackfn ( val  , idx  , obj  ) { return val < 10 ; } var obj = { 0 : 11 , 1 : 9 , 2 : 12 , length : \"2.5\" } ; var newArr = Array . prototype . map . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ;"
}, {
  "algo": "PrepareForTailCall",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "function callbackfn ( val  , idx  , obj  ) { return val < 10 ; } var obj = { 0 : 11 , 1 : 9 , 2 : 12 , length : \"2.5\" } ; var newArr = Array . prototype . map . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ;",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "PromiseReactionJob",
  "cond": "(= type CONST_Fulfill)",
  "covered": true,
  "elseCovered": "class FooPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . reject ( ) . finally ( ( ) => FooPromise . reject ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof FooPromise , false ) ;",
  "inst": "if (= type CONST_Fulfill) ... else ..."
}, {
  "algo": "PropertyDefinition3Contains0",
  "cond": "(is-instance-of symbol MethodDefinition)",
  "covered": true,
  "elseCovered": "var s1 = \"In getter\" ; var s2 = \"In setter\" ; var s3 = \"Modified by setter\" ; var o  ; eval ( \"o = {get foo(){ return s1;},set foo(arg){return s2 = s3}};\" ) ; assert . sameValue ( o . foo , s1 , 'o.foo' ) ; o . foo = 10 ; assert . sameValue ( s2 , s3 , 's2' ) ;",
  "inst": "if (is-instance-of symbol MethodDefinition) ... else ..."
}, {
  "algo": "PutValue",
  "cond": "(! (= __x0__ Reference))",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (! (= __x0__ Reference)) ... else ..."
}, {
  "algo": "PutValue",
  "cond": "(= __x4__ true)",
  "covered": true,
  "inst": "if (= __x4__ true) ... else ...",
  "thenCovered": "assert . throws ( ReferenceError , function  (  ) { eval ( '\"use strict\"; unresolvable = null;' ) ; } ) ;"
}, {
  "algo": "RunJobs",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] GLOBAL_context)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] GLOBAL_context) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "RunJobs",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "RunJobs",
  "cond": "__x4__",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if __x4__ ... else ..."
}, {
  "algo": "ScriptEvaluation",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] scriptContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] scriptContext) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "ScriptEvaluation",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "SetIntegrityLevel",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "var strObj = new String ( \"a\" ) ; var preCheck = Object . isExtensible ( strObj ) ; Object . seal ( strObj ) ; assert ( preCheck , 'preCheck !== true' ) ; assert ( Object . isSealed ( strObj ) , 'Object.isSealed(strObj) !== true' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "SetIntegrityLevel",
  "cond": "(! (= currentDesc undefined))",
  "covered": true,
  "inst": "if (! (= currentDesc undefined)) ... else ...",
  "thenCovered": "function tag ( templateObject  ) { previousObject = templateObject ; } var a = 1 ; var firstObject = null ; var previousObject = null ; function factory (  ) { return function  (  ) { tag `head${ a }tail` ; } ; } factory ( ) ( ) ; firstObject = previousObject ; assert ( firstObject !== null ) ; previousObject = null ; factory ( ) ( ) ; assert . sameValue ( previousObject , firstObject , 'The realm\\'s template cache is for source code locations in a function' ) ;"
}, {
  "algo": "SetRealmGlobalObject",
  "cond": "(= globalObj undefined)",
  "covered": true,
  "inst": "if (= globalObj undefined) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "SetRealmGlobalObject",
  "cond": "(= thisValue undefined)",
  "covered": true,
  "inst": "if (= thisValue undefined) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "SpeciesConstructor",
  "cond": "(= C undefined)",
  "covered": true,
  "elseCovered": "var constructorFunction  ; var promise = new class  extends Promise { constructor ( executor  ) { if ( constructorFunction ) { constructorFunction ( executor ) ; return { } ; } return super ( executor ) ; } } ( function  (  ) {  } ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; } ; promise . then ( ) ; } , \"executor not called at all\" ) ; assert . sameValue ( checkPoint , \"a\" , \"executor not called at all\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with no arguments\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with no arguments\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( undefined , undefined ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (undefined, undefined)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (undefined, undefined)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( undefined , function  (  ) {  } ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (undefined, function)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (undefined, function)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( function  (  ) {  } , undefined ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (function, undefined)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (function, undefined)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( 123 , \"invalid value\" ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (Number, String)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (Number, String)\" ) ;",
  "inst": "if (= C undefined) ... else ..."
}, {
  "algo": "SpeciesConstructor",
  "cond": "(= __x7__ true)",
  "covered": true,
  "inst": "if (= __x7__ true) ... else ...",
  "thenCovered": "var constructorFunction  ; var promise = new class  extends Promise { constructor ( executor  ) { if ( constructorFunction ) { constructorFunction ( executor ) ; return { } ; } return super ( executor ) ; } } ( function  (  ) {  } ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; } ; promise . then ( ) ; } , \"executor not called at all\" ) ; assert . sameValue ( checkPoint , \"a\" , \"executor not called at all\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with no arguments\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with no arguments\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( undefined , undefined ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (undefined, undefined)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (undefined, undefined)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( undefined , function  (  ) {  } ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (undefined, function)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (undefined, function)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( function  (  ) {  } , undefined ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (function, undefined)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (function, undefined)\" ) ; var checkPoint = \"\" ; assert . throws ( TypeError , function  (  ) { constructorFunction = function  ( executor  ) { checkPoint += \"a\" ; executor ( 123 , \"invalid value\" ) ; checkPoint += \"b\" ; } ; promise . then ( ) ; } , \"executor called with (Number, String)\" ) ; assert . sameValue ( checkPoint , \"ab\" , \"executor called with (Number, String)\" ) ;"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(! (< n str[\"length\"]))",
  "covered": true,
  "inst": "if (! (< n str[\"length\"])) ... else ...",
  "thenCovered": "var obj = new String ( \"xyz\" ) ; obj [ - 20 ] = - 20 ; obj [ 20 ] = 20 ; Object . defineProperty ( obj , \"prop1\" , { get : function  (  ) {  } , enumerable : true , configurable : true } ) ; Object . defineProperty ( obj , \"prop2\" , { get : function  (  ) {  } , enumerable : false , configurable : true } ) ; var arr = Object . keys ( obj ) ; for ( var i = 0 ; i < arr . length ; i ++ ) { assert ( obj . hasOwnProperty ( arr [ i ] ) , 'obj.hasOwnProperty(arr[i]) !== true' ) ; }"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(< j len)",
  "covered": true,
  "elseCovered": "var obj = new String ( \"xyz\" ) ; obj [ - 20 ] = - 20 ; obj [ 20 ] = 20 ; Object . defineProperty ( obj , \"prop1\" , { get : function  (  ) {  } , enumerable : true , configurable : true } ) ; Object . defineProperty ( obj , \"prop2\" , { get : function  (  ) {  } , enumerable : false , configurable : true } ) ; var arr = Object . keys ( obj ) ; for ( var i = 0 ; i < arr . length ; i ++ ) { assert ( obj . hasOwnProperty ( arr [ i ] ) , 'obj.hasOwnProperty(arr[i]) !== true' ) ; }",
  "inst": "while (< j len) { ... }"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(< arrayIndexKeys[j] arrayIndexKeys[min])",
  "covered": false,
  "inst": "if (< arrayIndexKeys[j] arrayIndexKeys[min]) ... else ..."
}, {
  "algo": "StringGetOwnProperty",
  "cond": "(= index -0.0)",
  "covered": true,
  "elseCovered": "var strObj = new String ( \"a\" ) ; var preCheck = Object . isExtensible ( strObj ) ; Object . seal ( strObj ) ; assert ( preCheck , 'preCheck !== true' ) ; assert ( Object . isSealed ( strObj ) , 'Object.isSealed(strObj) !== true' ) ;",
  "inst": "if (= index -0.0) ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "(= symbol \"super\")",
  "covered": true,
  "elseCovered": "var fromA  , fromB  ; var A = { fromA : 'a' , fromB : 'a' } ; var B = { fromB : 'b' } ; Object . setPrototypeOf ( B , A ) ; var obj = { fromA : 'c' , fromB : 'c' , method (  ) { fromA = eval ( 'super.fromA;' ) ; fromB = eval ( 'super.fromB;' ) ; } } ; Object . setPrototypeOf ( obj , B ) ; obj . method ( ) ; assert . sameValue ( fromA , 'a' ) ; assert . sameValue ( fromB , 'b' ) ;",
  "inst": "if (= symbol \"super\") ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "var fromA  , fromB  ; var A = { fromA : 'a' , fromB : 'a' } ; var B = { fromB : 'b' } ; Object . setPrototypeOf ( B , A ) ; var obj = { fromA : 'c' , fromB : 'c' , method (  ) { fromA = eval ( 'super.fromA;' ) ; fromB = eval ( 'super.fromB;' ) ; } } ; Object . setPrototypeOf ( obj , B ) ; obj . method ( ) ; assert . sameValue ( fromA , 'a' ) ; assert . sameValue ( fromB , 'b' ) ;",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "var fromA  , fromB  ; var A = { fromA : 'a' , fromB : 'a' } ; var B = { fromB : 'b' } ; Object . setPrototypeOf ( B , A ) ; var obj = { fromA : 'c' , fromB : 'c' , method (  ) { fromA = eval ( 'super.fromA;' ) ; fromB = eval ( 'super.fromB;' ) ; } } ; Object . setPrototypeOf ( obj , B ) ; obj . method ( ) ; assert . sameValue ( fromA , 'a' ) ; assert . sameValue ( fromB , 'b' ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "var fromA  , fromB  ; var A = { fromA : 'a' , fromB : 'a' } ; var B = { fromB : 'b' } ; Object . setPrototypeOf ( B , A ) ; var obj = { fromA : 'c' , fromB : 'c' , method (  ) { fromA = eval ( 'super.fromA;' ) ; fromB = eval ( 'super.fromB;' ) ; } } ; Object . setPrototypeOf ( obj , B ) ; obj . method ( ) ; assert . sameValue ( fromA , 'a' ) ; assert . sameValue ( fromB , 'b' ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "TestIntegrityLevel",
  "cond": "(! (= currentDesc undefined))",
  "covered": true,
  "inst": "if (! (= currentDesc undefined)) ... else ...",
  "thenCovered": "var strObj = new String ( \"a\" ) ; var preCheck = Object . isExtensible ( strObj ) ; Object . seal ( strObj ) ; assert ( preCheck , 'preCheck !== true' ) ; assert ( Object . isSealed ( strObj ) , 'Object.isSealed(strObj) !== true' ) ;"
}, {
  "algo": "ToInteger",
  "cond": "(= integer -0.0)",
  "covered": true,
  "elseCovered": "function callbackfn ( val  , idx  , obj  ) { return val < 10 ; } var obj = { 0 : 11 , 1 : 9 , 2 : 12 , length : \"2.5\" } ; var newArr = Array . prototype . map . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ;",
  "inst": "if (= integer -0.0) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"HasProperty\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"HasProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"DefineOwnProperty\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"DefineOwnProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Set\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"Set\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"SetPrototypeOf\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"SetPrototypeOf\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Get\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"Get\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"PreventExtensions\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"PreventExtensions\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Delete\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"Delete\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"GetOwnProperty\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"GetOwnProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"OwnPropertyKeys\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"OwnPropertyKeys\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"GetPrototypeOf\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"GetPrototypeOf\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"IsExtensible\"] absent)",
  "covered": true,
  "elseCovered": "assert . sameValue ( \"abc\\u000B\" . trim ( ) , \"abc\" , '\"abc\\u000B\".trim()' ) ;",
  "inst": "if (= obj[\"IsExtensible\"] absent) ... else ..."
}, {
  "algo": "TryStatement1VarDeclaredNames0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "var objBak = Object ; try { Object = 12 ; } finally { Object = objBak ; }",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement1VarScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "var objBak = Object ; try { Object = 12 ; } finally { Object = objBak ; }",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement2VarDeclaredNames0",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": true,
  "elseCovered": "try { y ; $ERROR ( '#1: \"y\" lead to throwing exception' ) ; } catch ( e ) {  } var c2 = 0 ; try { try { someValue ; $ERROR ( '#3.1: \"someValues\" lead to throwing exception' ) ; } finally { c2 = 1 ; } } catch ( e ) { if ( c2 !== 1 ) { $ERROR ( '#3.2: \"finally\" block must be evaluated' ) ; } } var c3 = 0 , x3 = 0 ; try { x3 = someValue ; $ERROR ( '#3.1: \"x3=someValues\" lead to throwing exception' ) ; } catch ( err ) { x3 = 1 ; } finally { c3 = 1 ; } if ( x3 !== 1 ) { $ERROR ( '#3.2: \"catch\" block must be evaluated' ) ; } if ( c3 !== 1 ) { $ERROR ( '#3.3: \"finally\" block must be evaluated' ) ; }",
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement2VarScopedDeclarations0",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": true,
  "elseCovered": "try { y ; $ERROR ( '#1: \"y\" lead to throwing exception' ) ; } catch ( e ) {  } var c2 = 0 ; try { try { someValue ; $ERROR ( '#3.1: \"someValues\" lead to throwing exception' ) ; } finally { c2 = 1 ; } } catch ( e ) { if ( c2 !== 1 ) { $ERROR ( '#3.2: \"finally\" block must be evaluated' ) ; } } var c3 = 0 , x3 = 0 ; try { x3 = someValue ; $ERROR ( '#3.1: \"x3=someValues\" lead to throwing exception' ) ; } catch ( err ) { x3 = 1 ; } finally { c3 = 1 ; } if ( x3 !== 1 ) { $ERROR ( '#3.2: \"catch\" block must be evaluated' ) ; } if ( c3 !== 1 ) { $ERROR ( '#3.3: \"finally\" block must be evaluated' ) ; }",
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "if ( 1 >>> 1 !== 0 ) { $ERROR ( '#1: 1 >>> 1 === 0. Actual: ' + ( 1 >>> 1 ) ) ; } if ( new Number ( 1 ) >>> 1 !== 0 ) { $ERROR ( '#2: new Number(1) >>> 1 === 0. Actual: ' + ( new Number ( 1 ) >>> 1 ) ) ; } if ( 1 >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#3: 1 >>> new Number(1) === 0. Actual: ' + ( 1 >>> new Number ( 1 ) ) ) ; } if ( new Number ( 1 ) >>> new Number ( 1 ) !== 0 ) { $ERROR ( '#4: new Number(1) >>> new Number(1) === 0. Actual: ' + ( new Number ( 1 ) >>> new Number ( 1 ) ) ) ; }"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "var a = [  ] ; a [ 4294967295 ] = \"not an array element\" ; assert . sameValue ( a [ 4294967295 ] , \"not an array element\" , 'a[4294967295]' ) ;"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "var arr = { 0 : 0 , 1 : 111 , 2 : 2 , length : 10 } ; Object . defineProperty ( arr , \"0\" , { get : function  (  ) { delete arr [ 1 ] ; return 0 ; } , configurable : true } ) ; Object . prototype [ 1 ] = 1 ; assert . sameValue ( Array . prototype . indexOf . call ( arr , 1 ) , 1 , 'Array.prototype.indexOf.call(arr, 1)' ) ;"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "var obj = [  ] ; obj . verifySetFunc = \"data\" ; var getFunc = function  (  ) { return obj . verifySetFunc ; } ; var setFunc = function  ( value  ) { obj . verifySetFunc = value ; } ; Object . defineProperty ( obj , \"prop\" , { get : getFunc , set : setFunc , enumerable : true , configurable : true } ) ; var desc1 = Object . getOwnPropertyDescriptor ( obj , \"prop\" ) ; Object . defineProperty ( obj , \"prop\" , { value : 1001 } ) ; var desc2 = Object . getOwnPropertyDescriptor ( obj , \"prop\" ) ; if ( ! desc1 . hasOwnProperty ( \"get\" ) ) { $ERROR ( 'Expected desc1.hasOwnProperty(\"get\") to be true, actually ' + desc1 . hasOwnProperty ( \"get\" ) ) ; } if ( ! desc2 . hasOwnProperty ( \"value\" ) ) { $ERROR ( 'Expected desc2.hasOwnProperty(\"value\") to be true, actually ' + desc2 . hasOwnProperty ( \"value\" ) ) ; } if ( typeof desc2 . get !== \"undefined\" ) { $ERROR ( 'Expected typeof desc2.get === \"undefined\" , actually ' + typeof desc2 . get ) ; } if ( typeof desc2 . set !== \"undefined\" ) { $ERROR ( 'Expected typeof desc2.set === \"undefined\" , actually ' + typeof desc2 . set ) ; } verifyEqualTo ( obj , \"prop\" , 1001 ) ; verifyNotWritable ( obj , \"prop\" ) ; verifyEnumerable ( obj , \"prop\" ) ; verifyConfigurable ( obj , \"prop\" ) ;"
}, {
  "algo": "YieldExpression0Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function * g (  ) { actual = yield ; } var expected = { } ; var iter = g ( ) ; var actual  , result  ; result = iter . next ( ) ; assert . sameValue ( result . value , undefined , 'First result `value`' ) ; assert . sameValue ( result . done , false , 'First result `done` flag' ) ; assert . sameValue ( actual , undefined , 'Value of `yield` expression (prior to continuation)' ) ; result = iter . next ( expected ) ; assert . sameValue ( result . value , undefined , 'Second result `value`' ) ; assert . sameValue ( result . done , true , 'Second result `done` flag' ) ; assert . sameValue ( actual , expected , 'Value of `yield` expression (following continuation)' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression1Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function * values (  ) { yield 1 ; $ERROR ( 'This code is unreachable (following `yield` statement).' ) ; } var iterator = values ( ) ; var i = 0 ; var result = ( function  (  ) { for ( var x of iterator ) { i ++ ; return 34 ; $ERROR ( 'This code is unreachable (following `return` statement).' ) ; } $ERROR ( 'This code is unreachable (following `for..of` statement).' ) ; } ) ( ) ; assert . sameValue ( result , 34 ) ; assert . sameValue ( i , 1 ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var thrown = new Test262Error ( ) ; var badIter = { } ; var poisonedDone = Object . defineProperty ( { } , 'done' , { get : function  (  ) { throw thrown ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , throw : function  (  ) { return poisonedDone ; } } ; } ; function * g (  ) { try { yield * badIter ; } catch ( err ) { caught = err ; } } var iter = g ( ) ; var caught  ; iter . next ( ) ; iter . throw ( ) ; assert . sameValue ( caught , thrown ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var thrown = new Test262Error ( ) ; var badIter = { } ; var poisonedDone = Object . defineProperty ( { } , 'done' , { get : function  (  ) { throw thrown ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , throw : function  (  ) { return poisonedDone ; } } ; } ; function * g (  ) { try { yield * badIter ; } catch ( err ) { caught = err ; } } var iter = g ( ) ; var caught  ; iter . next ( ) ; iter . throw ( ) ; assert . sameValue ( caught , thrown ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; var callCount = 0 ; var spyValue = Object . defineProperty ( { done : false } , 'value' , { get : function  (  ) { callCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , throw : function  (  ) { return spyValue ; } } ; } ; var delegationComplete = false ; function * g (  ) { yield * badIter ; delegationComplete = true ; } var iter = g ( ) ; iter . next ( ) ; assert . sameValue ( callCount , 0 , 'access count (first iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (first iteration)' ) ; iter . throw ( ) ; assert . sameValue ( callCount , 0 , 'access count (second iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (second iteration)' ) ; spyValue . done = true ; iter . throw ( ) ; assert . sameValue ( callCount , 1 , 'access count (final iteration)' ) ; assert . sameValue ( delegationComplete , true , 'delegation complete' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , return : function  (  ) { return 87 ; } } ; } ; function * g (  ) { try { yield * badIter ; } catch ( err ) { caught = err ; } } var iter = g ( ) ; var caught  ; iter . next ( ) ; iter . throw ( ) ; assert . sameValue ( typeof caught , 'object' ) ; assert . sameValue ( caught . constructor , TypeError ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; var throwCount = 0 ; var returnCount = 0 ; var hitNextStatement = false ; var hitCatch = false ; var hitFinally = false ; var spyResult = { next : function  (  ) { return { done : false } ; } } ; Object . defineProperty ( spyResult , 'throw' , { get : function  (  ) { throwCount += 1 ; } } ) ; Object . defineProperty ( spyResult , 'return' , { get : function  (  ) { returnCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return spyResult ; } ; function * g (  ) { try { yield * badIter ; hitNextStatement = true ; } catch ( _ ) { hitCatch = true ; } finally { hitFinally = true ; } } var iter = g ( ) ; iter . next ( ) ; iter . return ( ) ; assert . sameValue ( throwCount , 0 , '`throw` property access' ) ; assert . sameValue ( returnCount , 1 , '`return` property access' ) ; assert . sameValue ( hitFinally , true , 'Generator execution was resumed' ) ; assert . sameValue ( hitNextStatement , false , 'Abrupt completion interrupted control flow' ) ; assert . sameValue ( hitCatch , false , 'Abrupt completion not interpreted as \"throw\"' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var args  , thisValue  ; var callCount = 0 ; var spyIterator = { next : function  (  ) { return { done : false } ; } , return : function  (  ) { callCount += 1 ; args = arguments ; thisValue = this ; return { done : true } ; } } ; var spyIterable = { } ; spyIterable [ Symbol . iterator ] = function  (  ) { return spyIterator ; } ; function * g (  ) { yield * spyIterable ; } var iter = g ( ) ; iter . next ( 8888 ) ; iter . return ( 7777 ) ; assert . sameValue ( callCount , 1 ) ; assert . sameValue ( args . length , 1 ) ; assert . sameValue ( args [ 0 ] , 7777 ) ; assert . sameValue ( thisValue , spyIterator ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "var badIter = { } ; var callCount = 0 ; var spyValue = Object . defineProperty ( { done : false } , 'value' , { get : function  (  ) { callCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , return : function  (  ) { return spyValue ; } } ; } ; var normalCompletion = false ; var errorCompletion = false ; var delegationComplete = false ; function * g (  ) { try { yield * badIter ; normalCompletion = true ; } catch ( _ ) { errorCompletion = true ; } finally { delegationComplete = true ; } } var iter = g ( ) ; iter . next ( ) ; assert . sameValue ( callCount , 0 , 'access count (first iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (first iteration)' ) ; iter . return ( ) ; assert . sameValue ( callCount , 0 , 'access count (second iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (second iteration)' ) ; spyValue . done = true ; iter . return ( ) ; assert . sameValue ( callCount , 1 , 'access count (final iteration)' ) ; assert . sameValue ( delegationComplete , true , 'delegation complete' ) ; assert . sameValue ( normalCompletion , false , 'completion was abrupt' ) ; assert . sameValue ( errorCompletion , false , 'completion was not of type \"throw\"' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}]