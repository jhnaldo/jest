[{
  "algo": "ReturnStatement1Evaluation0",
  "cond": "(= __x2__ CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= __x2__ CONST_async) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var fooCalled = false ; function foo (  ) { fooCalled = true ; } var o = { } ; assert . throws ( TypeError , function  (  ) { eval ( \"o.bar( foo() );\" ) ; $ERROR ( \"o.bar does not exist!\" ) ; } ) ; assert . sameValue ( fooCalled , true , 'fooCalled' ) ;",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var fooCalled = false ; function foo (  ) { fooCalled = true ; } var o = { } ; assert . throws ( TypeError , function  (  ) { eval ( \"o.bar( foo() );\" ) ; $ERROR ( \"o.bar does not exist!\" ) ; } ) ; assert . sameValue ( fooCalled , true , 'fooCalled' ) ;",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var fooCalled = false ; function foo (  ) { fooCalled = true ; } var o = { } ; assert . throws ( TypeError , function  (  ) { eval ( \"o.bar( foo() );\" ) ; $ERROR ( \"o.bar does not exist!\" ) ; } ) ; assert . sameValue ( fooCalled , true , 'fooCalled' ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "MemberExpression2Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var fooCalled = false ; function foo (  ) { fooCalled = true ; } var o = { } ; assert . throws ( TypeError , function  (  ) { eval ( \"o.bar( foo() );\" ) ; $ERROR ( \"o.bar does not exist!\" ) ; } ) ; assert . sameValue ( fooCalled , true , 'fooCalled' ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; eval ( \"({foo : 1, get foo(){}});\" ) ;",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; eval ( \"({foo : 1, get foo(){}});\" ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "LiteralPropertyName0Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; eval ( \"({foo : 1, get foo(){}});\" ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "Literal1Evaluation0",
  "cond": "(= (get-syntax BooleanLiteral) \"true\")",
  "covered": true,
  "inst": "if (= (get-syntax BooleanLiteral) \"true\") ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;"
}, {
  "algo": "CallExpression0Evaluation0",
  "cond": "(= __x10__ true)",
  "covered": true,
  "inst": "if (= __x10__ true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;"
}, {
  "algo": "AssignmentExpression5Evaluation0",
  "cond": "(= op \"*\")",
  "covered": true,
  "inst": "if (= op \"*\") ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x  ; x = \"1\" ; x *= null ; if ( x !== 0 ) { $ERROR ( '#1: x = \"1\"; x *= null; x === 0. Actual: ' + ( x ) ) ; } x = null ; x *= \"1\" ; if ( x !== 0 ) { $ERROR ( '#2: x = null; x *= \"1\"; x === 0. Actual: ' + ( x ) ) ; } x = new String ( \"1\" ) ; x *= null ; if ( x !== 0 ) { $ERROR ( '#3: x = new String(\"1\"); x *= null; x === 0. Actual: ' + ( x ) ) ; } x = null ; x *= new String ( \"1\" ) ; if ( x !== 0 ) { $ERROR ( '#4: x = null; x *= new String(\"1\"); x === 0. Actual: ' + ( x ) ) ; }"
}, {
  "algo": "PrimaryExpression12HasName0",
  "cond": "(= __x1__ false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; class C  { static * method ( [  cover = ( function  (  ) {  } ) ,  xCover = ( 0 , function  (  ) {  } ) ]  ) { assert . sameValue ( cover . name , 'cover' ) ; assert . notSameValue ( xCover . name , 'xCover' ) ; callCount = callCount + 1 ; } } ; C . method ( [  ] ) . next ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if (= __x1__ false) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "CallExpression5Contains0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; eval ( \" Function(\\\"this.feat=1\\\").call(void 0) \" ) ; if ( this [ \"feat\" ] !== 1 ) { $ERROR ( '#1: If thisArg is null or undefined, the called function is passed the global object as the this value' ) ; }",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "IfStatement0HasCallInTailPosition0",
  "cond": "(= has true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= has true) ... else ..."
}, {
  "algo": "ArrowFunction0Contains0",
  "cond": "(! (|| (|| (|| (|| (is-instance-of symbol NewTarget) (is-instance-of symbol SuperProperty)) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\")))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var result = eval ( 'function fn() {}() => 1, 42;;' ) ; assert . sameValue ( result , 42 ) ;",
  "inst": "if (! (|| (|| (|| (|| (is-instance-of symbol NewTarget) (is-instance-of symbol SuperProperty)) (is-instance-of symbol SuperCall)) (= symbol \"super\")) (= symbol \"this\"))) ... else ..."
}, {
  "algo": "ArrowFunction0Contains0",
  "cond": "(= __x1__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var result = eval ( 'function fn() {}() => 1, 42;;' ) ; assert . sameValue ( result , 42 ) ;",
  "inst": "if (= __x1__ true) ... else ..."
}, {
  "algo": "UnaryExpression1Evaluation0",
  "cond": "(= __x3__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } verifyProperty ( BigInt , \"prototype\" , { writable : false , enumerable : false , configurable : false } ) ;",
  "inst": "if (= __x3__ true) ... else ..."
}, {
  "algo": "UnaryExpression1Evaluation0",
  "cond": "(= __x6__ true)",
  "covered": true,
  "inst": "if (= __x6__ true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } verifyProperty ( BigInt , \"prototype\" , { writable : false , enumerable : false , configurable : false } ) ;"
}, {
  "algo": "ArrowParameters0IteratorBindingInitialization0",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var plusOne = v => { v + 1 ; } ; assert . sameValue ( plusOne ( 1 ) , undefined ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "ArrowParameters0IteratorBindingInitialization0",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var plusOne = v => { v + 1 ; } ; assert . sameValue ( plusOne ( 1 ) , undefined ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { method ( [  fn = function  (  ) {  } ,  xFn = function x (  ) {  } ] = [  ] ) { assert . sameValue ( fn . name , 'fn' ) ; assert . notSameValue ( xFn . name , 'xFn' ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;"
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { method ( [  fn = function  (  ) {  } ,  xFn = function x (  ) {  } ] = [  ] ) { assert . sameValue ( fn . name , 'fn' ) ; assert . notSameValue ( xFn . name , 'xFn' ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "BindingElement1IteratorBindingInitialization1",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var initCount = 0 ; function counter (  ) { initCount += 1 ; } var callCount = 0 ; var f  ; f = ( { s : t = counter ( ) , u : v = counter ( ) , w : x = counter ( ) , y : z = counter ( ) } ) => { assert . sameValue ( t , null ) ; assert . sameValue ( v , 0 ) ; assert . sameValue ( x , false ) ; assert . sameValue ( z , '' ) ; assert . sameValue ( initCount , 0 ) ; assert . throws ( ReferenceError , function  (  ) { s ; } ) ; assert . throws ( ReferenceError , function  (  ) { u ; } ) ; assert . throws ( ReferenceError , function  (  ) { w ; } ) ; assert . throws ( ReferenceError , function  (  ) { y ; } ) ; callCount = callCount + 1 ; } ; f ( { s : null , u : 0 , w : false , y : '' } ) ; assert . sameValue ( callCount , 1 , 'arrow function invoked exactly once' ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "ArrayCreate",
  "cond": "(= length -0.0)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var testResult = false ; var initialValue = 0 ; function callbackfn ( prevVal  , curVal  , idx  , obj  ) { if ( idx === 1 ) { testResult = ( curVal === undefined ) ; } } var arr = [  0 , , 2 ] ; Object . defineProperty ( arr , \"1\" , { set : function  (  ) {  } , configurable : true } ) ; arr . reduce ( callbackfn , initialValue ) ; assert ( testResult , 'testResult !== true' ) ;",
  "inst": "if (= length -0.0) ... else ..."
}, {
  "algo": "ArraySetLength",
  "cond": "(= succeeded false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var expects = [  1 ,  2 ,  3 ] ; var s = new Set ( expects ) ; s . forEach ( function  ( value  , entry  , set  ) { var expect = expects . shift ( ) ; assert . sameValue ( value , expect ) ; assert . sameValue ( entry , expect ) ; assert . sameValue ( set , s ) ; } ) ; assert . sameValue ( expects . length , 0 , \"The value of `expects.length` is `0`\" ) ;",
  "inst": "if (= succeeded false) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(= length -0.0)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function callbackfn ( val  , idx  , obj  ) { if ( idx === 0 ) { return val === 11 ; } if ( idx === 1 ) { return val === 12 ; } return false ; } var obj = { 0 : 11 , 1 : 12 , length : 2 } ; var newArr = Array . prototype . filter . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ; assert . sameValue ( newArr [ 0 ] , 11 , 'newArr[0]' ) ; assert . sameValue ( newArr [ 1 ] , 12 , 'newArr[1]' ) ;",
  "inst": "if (= length -0.0) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(! (= thisRealm realmC))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var typedArrayConstructors = [  Float64Array ,  Float32Array ,  Int32Array ,  Int16Array ,  Int8Array ,  Uint32Array ,  Uint16Array ,  Uint8Array ,  Uint8ClampedArray ] ; var floatArrayConstructors = typedArrayConstructors . slice ( 0 , 2 ) ; var intArrayConstructors = typedArrayConstructors . slice ( 2 , 7 ) ; var TypedArray = Object . getPrototypeOf ( Int8Array ) ; function testWithTypedArrayConstructors ( f  , selected  ) { var constructors = selected || typedArrayConstructors ; for ( var i = 0 ; i < constructors . length ; ++ i ) { var constructor = constructors [ i ] ; try { f ( constructor ) ; } catch ( e ) { e . message += \" (Testing with \" + constructor . name + \".)\" ; throw e ; } } } function testTypedArrayConversions ( byteConversionValues  , fn  ) { var values = byteConversionValues . values ; var expected = byteConversionValues . expected ; testWithTypedArrayConstructors ( function  ( TA  ) { var name = TA . name . slice ( 0 , - 5 ) ; return values . forEach ( function  ( value  , index  ) { var exp = expected [ name ] [ index ] ; var initial = 0 ; if ( exp === 0 ) { initial = 1 ; } fn ( TA , value , exp , initial ) ; } ) ; } ) ; } var TypedArrayPrototype = TypedArray . prototype ; assert . sameValue ( typeof TypedArrayPrototype . lastIndexOf , 'function' ) ; assert . throws ( TypeError , function  (  ) { TypedArrayPrototype . lastIndexOf ( ) ; } ) ;",
  "inst": "if (! (= thisRealm realmC)) ... else ..."
}, {
  "algo": "ArraySpeciesCreate",
  "cond": "(= __x7__ true)",
  "covered": false,
  "inst": "if (= __x7__ true) ... else ..."
}, {
  "algo": "AssignmentElement0IteratorDestructuringAssignmentEvaluation1",
  "cond": "__x4__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x  ; var counter = 0 ; for ( [  { x } ] of [  [  { x : 2 } ] ] ) { assert . sameValue ( x , 2 ) ; counter += 1 ; } assert . sameValue ( counter , 1 ) ;",
  "inst": "if __x4__ ... else ..."
}, {
  "algo": "AssignmentRestElement0IteratorDestructuringAssignmentEvaluation0",
  "cond": "__x5__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = { } ; var iterationResult  , iter  ; iter = ( function *  (  ) { var result  ; var vals = [  33 ,  44 ,  55 ] ; result = [  ... x [ yield ] ] = vals ; assert . sameValue ( result , vals ) ; } ( ) ) ; iterationResult = iter . next ( ) ; assert . sameValue ( iterationResult . value , undefined ) ; assert . sameValue ( iterationResult . done , false ) ; assert . sameValue ( x . prop , undefined ) ; iterationResult = iter . next ( 'prop' ) ; assert . sameValue ( iterationResult . value , undefined ) ; assert . sameValue ( iterationResult . done , true ) ; assert . sameValue ( x . prop . length , 3 ) ; assert . sameValue ( x . prop [ 0 ] , 33 ) ; assert . sameValue ( x . prop [ 1 ] , 44 ) ; assert . sameValue ( x . prop [ 2 ] , 55 ) ;",
  "inst": "if __x5__ ... else ..."
}, {
  "algo": "AsyncFunctionBody0EvaluateBody0",
  "cond": "(! __x2__)",
  "covered": true,
  "inst": "if (! __x2__) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { async method (  ) {  } } ; var p = obj . method ( ) ; assert ( p instanceof Promise , \"async functions return promise instances\" ) ;"
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { async method (  ) {  } } ; var p = obj . method ( ) ; assert ( p instanceof Promise , \"async functions return promise instances\" ) ;"
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= result[\"Type\"] CONST_return)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; let called  ; async function foo (  ) { called = true ; await new Promise ( ) ; } foo ( ) ; assert ( called ) ;",
  "inst": "if (= result[\"Type\"] CONST_return) ... else ..."
}, {
  "algo": "AsyncFunctionStart",
  "cond": "(= asyncContext[\"ReturnCont\"] absent)",
  "covered": true,
  "inst": "if (= asyncContext[\"ReturnCont\"] absent) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { async method (  ) {  } } ; var p = obj . method ( ) ; assert ( p instanceof Promise , \"async functions return promise instances\" ) ;"
}, {
  "algo": "AsyncGeneratorEnqueue",
  "cond": "(|| (! (= __x1__ Object)) (= generator[\"AsyncGeneratorState\"] absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (|| (! (= __x1__ Object)) (= generator[\"AsyncGeneratorState\"] absent)) ... else ..."
}, {
  "algo": "AsyncGeneratorEnqueue",
  "cond": "(! (= state CONST_executing))",
  "covered": true,
  "inst": "if (! (= state CONST_executing)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_awaitingreturn)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= state CONST_awaitingreturn) ... else ..."
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_suspendedStart)",
  "covered": true,
  "inst": "if (= state CONST_suspendedStart) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_completed)",
  "covered": true,
  "inst": "if (= state CONST_completed) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= completion[\"Type\"] CONST_return)",
  "covered": true,
  "inst": "if (= completion[\"Type\"] CONST_return) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . return ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= state CONST_completed)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= state CONST_completed) ... else ..."
}, {
  "algo": "AsyncGeneratorResumeNext",
  "cond": "(= genContext[\"ReturnCont\"] absent)",
  "covered": true,
  "inst": "if (= genContext[\"ReturnCont\"] absent) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g (  ) {  } var result = g ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "AsyncGeneratorStart",
  "cond": "(! (= result[\"Type\"] CONST_return))",
  "covered": false,
  "inst": "if (! (= result[\"Type\"] CONST_return)) ... else ..."
}, {
  "algo": "Await",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] asyncContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "BigIntCOLONCOLONremainder",
  "cond": "(= n 0n)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function err (  ) { throw new Test262Error ( ) ; } function MyError (  ) {  } assert . sameValue ( { [ Symbol . toPrimitive ] : function  (  ) { return 2n ; } , valueOf : err , toString : err } % 2n , 0n , 'The result of (({[Symbol.toPrimitive]: function() {return 2n;}, valueOf: err, toString: err}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { [ Symbol . toPrimitive ] : function  (  ) { return 2n ; } , valueOf : err , toString : err } , 0n , 'The result of (2n % {[Symbol.toPrimitive]: function() {return 2n;}, valueOf: err, toString: err}) is 0n' ) ; assert . sameValue ( { valueOf : function  (  ) { return 2n ; } , toString : err } % 2n , 0n , 'The result of (({valueOf: function() {return 2n;}, toString: err}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : function  (  ) { return 2n ; } , toString : err } , 0n , 'The result of (2n % {valueOf: function() {return 2n;}, toString: err}) is 0n' ) ; assert . sameValue ( { toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { [ Symbol . toPrimitive ] : undefined , valueOf : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({[Symbol.toPrimitive]: undefined, valueOf: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { [ Symbol . toPrimitive ] : undefined , valueOf : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {[Symbol.toPrimitive]: undefined, valueOf: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { [ Symbol . toPrimitive ] : null , valueOf : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({[Symbol.toPrimitive]: null, valueOf: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { [ Symbol . toPrimitive ] : null , valueOf : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {[Symbol.toPrimitive]: null, valueOf: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : null , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: null, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : null , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: null, toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : 1 , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: 1, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : 1 , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: 1, toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : { } , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: {}, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : { } , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: {}, toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : function  (  ) { return { } ; } , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: function() {return {};}, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : function  (  ) { return { } ; } , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: function() {return {};}, toString: function() {return 2n;}}) is 0n' ) ; assert . sameValue ( { valueOf : function  (  ) { return Object ( 12345 ) ; } , toString : function  (  ) { return 2n ; } } % 2n , 0n , 'The result of (({valueOf: function() {return Object(12345);}, toString: function() {return 2n;}}) % 2n) is 0n' ) ; assert . sameValue ( 2n % { valueOf : function  (  ) { return Object ( 12345 ) ; } , toString : function  (  ) { return 2n ; } } , 0n , 'The result of (2n % {valueOf: function() {return Object(12345);}, toString: function() {return 2n;}}) is 0n' ) ; assert . throws ( TypeError , function  (  ) { ( { [ Symbol . toPrimitive ] : 1 } ) % 1n ; } , '({[Symbol.toPrimitive]: 1}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : 1 } ; } , '0n % {[Symbol.toPrimitive]: 1} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { [ Symbol . toPrimitive ] : { } } ) % 1n ; } , '({[Symbol.toPrimitive]: {}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : { } } ; } , '0n % {[Symbol.toPrimitive]: {}} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { [ Symbol . toPrimitive ] : function  (  ) { return Object ( 1 ) ; } } ) % 1n ; } , '({[Symbol.toPrimitive]: function() {return Object(1);}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : function  (  ) { return Object ( 1 ) ; } } ; } , '0n % {[Symbol.toPrimitive]: function() {return Object(1);}} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { [ Symbol . toPrimitive ] : function  (  ) { return { } ; } } ) % 1n ; } , '({[Symbol.toPrimitive]: function() {return {};}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : function  (  ) { return { } ; } } ; } , '0n % {[Symbol.toPrimitive]: function() {return {};}} throws TypeError' ) ; assert . throws ( MyError , function  (  ) { ( { [ Symbol . toPrimitive ] : function  (  ) { throw new MyError ( ) ; } } ) % 1n ; } , '({[Symbol.toPrimitive]: function() {throw new MyError();}}) % 1n throws MyError' ) ; assert . throws ( MyError , function  (  ) { 0n % { [ Symbol . toPrimitive ] : function  (  ) { throw new MyError ( ) ; } } ; } , '0n % {[Symbol.toPrimitive]: function() {throw new MyError();}} throws MyError' ) ; assert . throws ( MyError , function  (  ) { ( { valueOf : function  (  ) { throw new MyError ( ) ; } } ) % 1n ; } , '({valueOf: function() {throw new MyError();}}) % 1n throws MyError' ) ; assert . throws ( MyError , function  (  ) { 0n % { valueOf : function  (  ) { throw new MyError ( ) ; } } ; } , '0n % {valueOf: function() {throw new MyError();}} throws MyError' ) ; assert . throws ( MyError , function  (  ) { ( { toString : function  (  ) { throw new MyError ( ) ; } } ) % 1n ; } , '({toString: function() {throw new MyError();}}) % 1n throws MyError' ) ; assert . throws ( MyError , function  (  ) { 0n % { toString : function  (  ) { throw new MyError ( ) ; } } ; } , '0n % {toString: function() {throw new MyError();}} throws MyError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : null , toString : null } ) % 1n ; } , '({valueOf: null, toString: null}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : null , toString : null } ; } , '0n % {valueOf: null, toString: null} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : 1 , toString : 1 } ) % 1n ; } , '({valueOf: 1, toString: 1}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : 1 , toString : 1 } ; } , '0n % {valueOf: 1, toString: 1} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : { } , toString : { } } ) % 1n ; } , '({valueOf: {}, toString: {}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : { } , toString : { } } ; } , '0n % {valueOf: {}, toString: {}} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : function  (  ) { return Object ( 1 ) ; } , toString : function  (  ) { return Object ( 1 ) ; } } ) % 1n ; } , '({valueOf: function() {return Object(1);}, toString: function() {return Object(1);}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : function  (  ) { return Object ( 1 ) ; } , toString : function  (  ) { return Object ( 1 ) ; } } ; } , '0n % {valueOf: function() {return Object(1);}, toString: function() {return Object(1);}} throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { ( { valueOf : function  (  ) { return { } ; } , toString : function  (  ) { return { } ; } } ) % 1n ; } , '({valueOf: function() {return {};}, toString: function() {return {};}}) % 1n throws TypeError' ) ; assert . throws ( TypeError , function  (  ) { 0n % { valueOf : function  (  ) { return { } ; } , toString : function  (  ) { return { } ; } } ; } , '0n % {valueOf: function() {return {};}, toString: function() {return {};}} throws TypeError' ) ;",
  "inst": "if (= n 0n) ... else ..."
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { * method ( [  ... { length  } ]  ) { assert . sameValue ( length , 3 ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( [  1 ,  2 ,  3 ] ) . next ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;"
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { * method ( [  ... { length  } ]  ) { assert . sameValue ( length , 3 ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( [  1 ,  2 ,  3 ] ) . next ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "BindingRestElement1IteratorBindingInitialization0",
  "cond": "__x7__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { * method ( [  ... { length  } ]  ) { assert . sameValue ( length , 3 ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( [  1 ,  2 ,  3 ] ) . next ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if __x7__ ... else ..."
}, {
  "algo": "BreakableStatement1LabelledEvaluation0",
  "cond": "(= stmtResult[\"Target\"] CONST_empty)",
  "covered": true,
  "inst": "if (= stmtResult[\"Target\"] CONST_empty) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"b\": break; }' ) , undefined ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"b\": { 3; break; } }' ) , 3 ) ; assert . sameValue ( eval ( '4; do { switch (\"a\") { default: case \"b\": continue; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( '5; do { switch (\"a\") { default: case \"b\": { 6; continue; } } } while (false)' ) , 6 ) ;"
}, {
  "algo": "BreakableStatement1LabelledEvaluation0",
  "cond": "(= stmtResult[\"Value\"] CONST_empty)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"b\": break; }' ) , undefined ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"b\": { 3; break; } }' ) , 3 ) ; assert . sameValue ( eval ( '4; do { switch (\"a\") { default: case \"b\": continue; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( '5; do { switch (\"a\") { default: case \"b\": { 6; continue; } } } while (false)' ) , 6 ) ;",
  "inst": "if (= stmtResult[\"Value\"] CONST_empty) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTCall",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTConstruct",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x  ; x = \"1\" ; x *= null ; if ( x !== 0 ) { $ERROR ( '#1: x = \"1\"; x *= null; x === 0. Actual: ' + ( x ) ) ; } x = null ; x *= \"1\" ; if ( x !== 0 ) { $ERROR ( '#2: x = null; x *= \"1\"; x === 0. Actual: ' + ( x ) ) ; } x = new String ( \"1\" ) ; x *= null ; if ( x !== 0 ) { $ERROR ( '#3: x = new String(\"1\"); x *= null; x === 0. Actual: ' + ( x ) ) ; } x = null ; x *= new String ( \"1\" ) ; if ( x !== 0 ) { $ERROR ( '#4: x = null; x *= new String(\"1\"); x === 0. Actual: ' + ( x ) ) ; }",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "BuiltinFunctionObjectDOTConstruct",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] calleeContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] calleeContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x  ; x = \"1\" ; x *= null ; if ( x !== 0 ) { $ERROR ( '#1: x = \"1\"; x *= null; x === 0. Actual: ' + ( x ) ) ; } x = null ; x *= \"1\" ; if ( x !== 0 ) { $ERROR ( '#2: x = null; x *= \"1\"; x === 0. Actual: ' + ( x ) ) ; } x = new String ( \"1\" ) ; x *= null ; if ( x !== 0 ) { $ERROR ( '#3: x = new String(\"1\"); x *= null; x === 0. Actual: ' + ( x ) ) ; } x = null ; x *= new String ( \"1\" ) ; if ( x !== 0 ) { $ERROR ( '#4: x = null; x *= new String(\"1\"); x === 0. Actual: ' + ( x ) ) ; }"
}, {
  "algo": "CanonicalNumericIndexString",
  "cond": "(= argument \"-0\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x  ; x = \"1\" ; x *= null ; if ( x !== 0 ) { $ERROR ( '#1: x = \"1\"; x *= null; x === 0. Actual: ' + ( x ) ) ; } x = null ; x *= \"1\" ; if ( x !== 0 ) { $ERROR ( '#2: x = null; x *= \"1\"; x === 0. Actual: ' + ( x ) ) ; } x = new String ( \"1\" ) ; x *= null ; if ( x !== 0 ) { $ERROR ( '#3: x = new String(\"1\"); x *= null; x === 0. Actual: ' + ( x ) ) ; } x = null ; x *= new String ( \"1\" ) ; if ( x !== 0 ) { $ERROR ( '#4: x = null; x *= new String(\"1\"); x === 0. Actual: ' + ( x ) ) ; }",
  "inst": "if (= argument \"-0\") ... else ..."
}, {
  "algo": "CaseBlock1HasCallInTailPosition3",
  "cond": "(! (= CaseClauses1 absent))",
  "covered": true,
  "inst": "if (! (= CaseClauses1 absent)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function SwitchTest ( value  ) { var result = 0 ; switch ( value ) { case 0 : result += 2 ; case 1 : result += 4 ; break ; case 2 : result += 8 ; case isNaN ( value ) : result += 16 ; default : result += 32 ; break ; case null : result += 64 ; case isNaN : result += 128 ; break ; case Infinity : result += 256 ; case 2 + 3 : result += 512 ; break ; case undefined : result += 1024 ; } return result ; } var n = Number ( false ) ; if ( ! ( SwitchTest ( n ) === 6 ) ) { $ERROR ( \"#1: SwitchTest(Number(false)) === 6. Actual:  SwitchTest(Number(false)) ===\" + SwitchTest ( n ) ) ; } if ( ! ( SwitchTest ( parseInt ) === 32 ) ) { $ERROR ( \"#2: SwitchTest(parseInt) === 32. Actual:  SwitchTest(parseInt) ===\" + SwitchTest ( parseInt ) ) ; } if ( ! ( SwitchTest ( isNaN ) === 128 ) ) { $ERROR ( \"#3: SwitchTest(isNaN) === 128. Actual:  SwitchTest(isNaN) ===\" + SwitchTest ( isNaN ) ) ; } if ( ! ( SwitchTest ( true ) === 32 ) ) { $ERROR ( \"#6: SwitchTest(true) === 32. Actual:  SwitchTest(true) ===\" + SwitchTest ( true ) ) ; } if ( ! ( SwitchTest ( false ) === 48 ) ) { $ERROR ( \"#7: SwitchTest(false) === 48. Actual:  SwitchTest(false) ===\" + SwitchTest ( false ) ) ; } if ( ! ( SwitchTest ( null ) === 192 ) ) { $ERROR ( \"#8: SwitchTest(null) === 192. Actual:  SwitchTest(null) ===\" + SwitchTest ( null ) ) ; } if ( ! ( SwitchTest ( void 0 ) === 1024 ) ) { $ERROR ( \"#9: SwitchTest(void 0) === 1024. Actual:  SwitchTest(void 0) ===\" + SwitchTest ( void 0 ) ) ; } if ( ! ( SwitchTest ( NaN ) === 32 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 32. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; } if ( ! ( SwitchTest ( Infinity ) === 768 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 768. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; }"
}, {
  "algo": "CaseBlock1LexicallyScopedDeclarations3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"b\": break; }' ) , undefined ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"b\": { 3; break; } }' ) , 3 ) ; assert . sameValue ( eval ( '4; do { switch (\"a\") { default: case \"b\": continue; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( '5; do { switch (\"a\") { default: case \"b\": { 6; continue; } } } while (false)' ) , 6 ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseBlock1VarDeclaredNames3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"b\": break; }' ) , undefined ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"b\": { 3; break; } }' ) , 3 ) ; assert . sameValue ( eval ( '4; do { switch (\"a\") { default: case \"b\": continue; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( '5; do { switch (\"a\") { default: case \"b\": { 6; continue; } } } while (false)' ) , 6 ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseBlock1VarScopedDeclarations3",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; switch (\"a\") { default: case \"b\": break; }' ) , undefined ) ; assert . sameValue ( eval ( '2; switch (\"a\") { default: case \"b\": { 3; break; } }' ) , 3 ) ; assert . sameValue ( eval ( '4; do { switch (\"a\") { default: case \"b\": continue; } } while (false)' ) , undefined ) ; assert . sameValue ( eval ( '5; do { switch (\"a\") { default: case \"b\": { 6; continue; } } } while (false)' ) , 6 ) ;",
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "CaseClause0HasCallInTailPosition1",
  "cond": "(! (= StatementList absent))",
  "covered": true,
  "inst": "if (! (= StatementList absent)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var $MAX_ITERATIONS = 100000 ; var callCount = 0 ; ( function f ( n  ) { if ( n === 0 ) { callCount += 1 ; return ; } switch ( 0 ) { case 0 : return f ( n - 1 ) ; default :   } } ( $MAX_ITERATIONS ) ) ; assert . sameValue ( callCount , 1 ) ;"
}, {
  "algo": "CaseClauses1HasCallInTailPosition0",
  "cond": "(= has true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function SwitchTest ( value  ) { var result = 0 ; switch ( value ) { case 0 : result += 2 ; case 1 : result += 4 ; break ; case 2 : result += 8 ; case isNaN ( value ) : result += 16 ; default : result += 32 ; break ; case null : result += 64 ; case isNaN : result += 128 ; break ; case Infinity : result += 256 ; case 2 + 3 : result += 512 ; break ; case undefined : result += 1024 ; } return result ; } var n = Number ( false ) ; if ( ! ( SwitchTest ( n ) === 6 ) ) { $ERROR ( \"#1: SwitchTest(Number(false)) === 6. Actual:  SwitchTest(Number(false)) ===\" + SwitchTest ( n ) ) ; } if ( ! ( SwitchTest ( parseInt ) === 32 ) ) { $ERROR ( \"#2: SwitchTest(parseInt) === 32. Actual:  SwitchTest(parseInt) ===\" + SwitchTest ( parseInt ) ) ; } if ( ! ( SwitchTest ( isNaN ) === 128 ) ) { $ERROR ( \"#3: SwitchTest(isNaN) === 128. Actual:  SwitchTest(isNaN) ===\" + SwitchTest ( isNaN ) ) ; } if ( ! ( SwitchTest ( true ) === 32 ) ) { $ERROR ( \"#6: SwitchTest(true) === 32. Actual:  SwitchTest(true) ===\" + SwitchTest ( true ) ) ; } if ( ! ( SwitchTest ( false ) === 48 ) ) { $ERROR ( \"#7: SwitchTest(false) === 48. Actual:  SwitchTest(false) ===\" + SwitchTest ( false ) ) ; } if ( ! ( SwitchTest ( null ) === 192 ) ) { $ERROR ( \"#8: SwitchTest(null) === 192. Actual:  SwitchTest(null) ===\" + SwitchTest ( null ) ) ; } if ( ! ( SwitchTest ( void 0 ) === 1024 ) ) { $ERROR ( \"#9: SwitchTest(void 0) === 1024. Actual:  SwitchTest(void 0) ===\" + SwitchTest ( void 0 ) ) ; } if ( ! ( SwitchTest ( NaN ) === 32 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 32. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; } if ( ! ( SwitchTest ( Infinity ) === 768 ) ) { $ERROR ( \"#10: SwitchTest(NaN) === 768. Actual:  SwitchTest(NaN) ===\" + SwitchTest ( NaN ) ) ; }",
  "inst": "if (= has true) ... else ..."
}, {
  "algo": "CaseClauses1LexicallyScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; let x = 'outside' ; var probe1  , probe2  ; switch ( null ) { case null : let x = 'inside' ; probe1 = function  (  ) { return x ; } ; case null : probe2 = function  (  ) { return x ; } ; } assert . sameValue ( probe1 ( ) , 'inside' , 'from first `case` clause' ) ; assert . sameValue ( probe2 ( ) , 'inside' , 'from second `case` clause' ) ; assert . sameValue ( x , 'outside' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "CaseClauses1VarDeclaredNames0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; let x = 'outside' ; var probe1  , probe2  ; switch ( null ) { case null : let x = 'inside' ; probe1 = function  (  ) { return x ; } ; case null : probe2 = function  (  ) { return x ; } ; } assert . sameValue ( probe1 ( ) , 'inside' , 'from first `case` clause' ) ; assert . sameValue ( probe2 ( ) , 'inside' , 'from second `case` clause' ) ; assert . sameValue ( x , 'outside' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "CaseClauses1VarScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; let x = 'outside' ; var probe1  , probe2  ; switch ( null ) { case null : let x = 'inside' ; probe1 = function  (  ) { return x ; } ; case null : probe2 = function  (  ) { return x ; } ; } assert . sameValue ( probe1 ( ) , 'inside' , 'from first `case` clause' ) ; assert . sameValue ( probe2 ( ) , 'inside' , 'from second `case` clause' ) ; assert . sameValue ( x , 'outside' ) ;",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "ClassElementList0ConstructorMethod0",
  "cond": "(is-instance-of ClassElement ClassElement2)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { method ( [  fn = function  (  ) {  } ,  xFn = function x (  ) {  } ] = [  ] ) { assert . sameValue ( fn . name , 'fn' ) ; assert . notSameValue ( xFn . name , 'xFn' ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if (is-instance-of ClassElement ClassElement2) ... else ..."
}, {
  "algo": "ClassElementList0NonConstructorMethodDefinitions0",
  "cond": "(is-instance-of ClassElement ClassElement2)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { method ( [  fn = function  (  ) {  } ,  xFn = function x (  ) {  } ] = [  ] ) { assert . sameValue ( fn . name , 'fn' ) ; assert . notSameValue ( xFn . name , 'xFn' ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if (is-instance-of ClassElement ClassElement2) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(is-instance-of symbol ClassBody)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( 'class C {}' ) , undefined ) ; assert . sameValue ( eval ( '1; class C {}' ) , 1 ) ;",
  "inst": "if (is-instance-of symbol ClassBody) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(is-instance-of symbol ClassHeritage)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( 'class C {}' ) , undefined ) ; assert . sameValue ( eval ( '1; class C {}' ) , 1 ) ;",
  "inst": "if (is-instance-of symbol ClassHeritage) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(! (= ClassHeritage absent))",
  "covered": false,
  "inst": "if (! (= ClassHeritage absent)) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= ClassHeritage absent)",
  "covered": true,
  "inst": "if (= ClassHeritage absent) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( 'class C {}' ) , undefined ) ; assert . sameValue ( eval ( '1; class C {}' ) , 1 ) ;"
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= inHeritage true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( 'class C {}' ) , undefined ) ; assert . sameValue ( eval ( '1; class C {}' ) , 1 ) ;",
  "inst": "if (= inHeritage true) ... else ..."
}, {
  "algo": "ClassTail0Contains3",
  "cond": "(= ClassBody absent)",
  "covered": true,
  "inst": "if (= ClassBody absent) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( 'class C {}' ) , undefined ) ; assert . sameValue ( eval ( '1; class C {}' ) , 1 ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= realm absent)",
  "covered": true,
  "inst": "if (= realm absent) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= prototype absent)",
  "covered": true,
  "inst": "if (= prototype absent) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "CreateBuiltinFunction",
  "cond": "(= steps[\"length\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= steps[\"length\"] absent) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= newTarget undefined)",
  "covered": false,
  "inst": "if (= newTarget undefined) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= kind CONST_generator)",
  "covered": false,
  "inst": "if (= kind CONST_generator) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= kind CONST_async)",
  "covered": false,
  "inst": "if (= kind CONST_async) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(== argCount 0i)",
  "covered": false,
  "inst": "if (== argCount 0i) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(== argCount 1i)",
  "covered": false,
  "inst": "if (== argCount 1i) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(< k (- argCount 1i))",
  "covered": false,
  "inst": "while (< k (- argCount 1i)) { ... }"
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= parameters absent)",
  "covered": false,
  "inst": "if (= parameters absent) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= body absent)",
  "covered": false,
  "inst": "if (= body absent) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x6__ false)",
  "covered": false,
  "inst": "if (= __x6__ false) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(< idx len)",
  "covered": false,
  "inst": "while (< idx len) { ... }"
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(contains declNames name)",
  "covered": false,
  "inst": "if (contains declNames name) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x9__ true)",
  "covered": false,
  "inst": "if (= __x9__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x12__ true)",
  "covered": false,
  "inst": "if (= __x12__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x15__ true)",
  "covered": false,
  "inst": "if (= __x15__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x18__ true)",
  "covered": false,
  "inst": "if (= __x18__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(|| (= kind CONST_generator) (= kind CONST_asyncGenerator))",
  "covered": false,
  "inst": "if (|| (= kind CONST_generator) (= kind CONST_asyncGenerator)) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x21__ true)",
  "covered": false,
  "inst": "if (= __x21__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(|| (= kind CONST_async) (= kind CONST_asyncGenerator))",
  "covered": false,
  "inst": "if (|| (= kind CONST_async) (= kind CONST_asyncGenerator)) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= __x24__ true)",
  "covered": false,
  "inst": "if (= __x24__ true) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(< idx len)",
  "covered": false,
  "inst": "while (< idx len) { ... }"
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(contains tempList name)",
  "covered": false,
  "inst": "if (contains tempList name) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= kind CONST_generator)",
  "covered": false,
  "inst": "if (= kind CONST_generator) ... else ..."
}, {
  "algo": "CreateDynamicFunction",
  "cond": "(= kind CONST_asyncGenerator)",
  "covered": false,
  "inst": "if (= kind CONST_asyncGenerator) ... else ..."
}, {
  "algo": "CreateListFromArrayLike",
  "cond": "(= elementTypes absent)",
  "covered": true,
  "inst": "if (= elementTypes absent) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; ( function  ( obj  ) { assert . sameValue ( obj . a , 1 ) ; assert . sameValue ( obj . b , 2 ) ; assert . sameValue ( Object . keys ( obj ) . length , 2 ) ; callCount += 1 ; } . apply ( null , [  { a : 1 , b : 2 , ... undefined } ] ) ) ; assert . sameValue ( callCount , 1 ) ;"
}, {
  "algo": "CreateListFromArrayLike",
  "cond": "(! (contains elementTypes __x5__))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; ( function  ( obj  ) { assert . sameValue ( obj . a , 1 ) ; assert . sameValue ( obj . b , 2 ) ; assert . sameValue ( Object . keys ( obj ) . length , 2 ) ; callCount += 1 ; } . apply ( null , [  { a : 1 , b : 2 , ... undefined } ] ) ) ; assert . sameValue ( callCount , 1 ) ;",
  "inst": "if (! (contains elementTypes __x5__)) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTInitializeBinding",
  "cond": "(! (= envRec[\"SubMap\"][N] absent))",
  "covered": true,
  "inst": "if (! (= envRec[\"SubMap\"][N] absent)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= absent envRec[\"SubMap\"][N])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= absent envRec[\"SubMap\"][N]) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= S true)",
  "covered": false,
  "inst": "if (= S true) ... else ..."
}, {
  "algo": "DeclarativeEnvironmentRecordDOTSetMutableBinding",
  "cond": "(= S true)",
  "covered": true,
  "inst": "if (= S true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; const c = null ; var counter = 0 ; assert . throws ( TypeError , function  (  ) { for ( [  ... c ] of [  [  1 ] ] ) { counter += 1 ; } counter += 1 ; } ) ; assert . sameValue ( counter , 0 ) ;"
}, {
  "algo": "DefaultClause0HasCallInTailPosition1",
  "cond": "(! (= StatementList absent))",
  "covered": true,
  "inst": "if (! (= StatementList absent)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var $MAX_ITERATIONS = 100000 ; var callCount = 0 ; ( function f ( n  ) { if ( n === 0 ) { callCount += 1 ; return ; } switch ( 0 ) {  default : return f ( n - 1 ) ;  } } ( $MAX_ITERATIONS ) ) ; assert . sameValue ( callCount , 1 ) ;"
}, {
  "algo": "ElementList1ArrayAccumulation1",
  "cond": "(! (= Elision absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function compareArray ( a  , b  ) { if ( b . length !== a . length ) { return false ; } for ( var i = 0 ; i < a . length ; i ++ ) { if ( ! compareArray . isSameValue ( b [ i ] , a [ i ] ) ) { return false ; } } return true ; } compareArray . isSameValue = function  ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } ; compareArray . format = function  ( array  ) { return `[${ array . map ( String ) . join ( ', ' ) }]` ; } ; assert . compareArray = function  ( actual  , expected  , message  ) { var format = compareArray . format ; assert ( compareArray ( actual , expected ) , `Expected ${ format ( actual ) } and ${ format ( expected ) } to have the same contents. ${ ( message || '' ) }` ) ; } ; var arr = [  'a' ,  'b' ,  'c' ] ; var item  ; var callCount = 0 ; var gen = function *  (  ) { callCount += 1 ; yield [  ... yield yield ] ; } ; var iter = gen ( ) ; iter . next ( false ) ; item = iter . next ( [  'a' ,  'b' ,  'c' ] ) ; item = iter . next ( item . value ) ; assert ( compareArray ( item . value , arr ) ) ; assert . sameValue ( item . done , false ) ; assert . sameValue ( callCount , 1 ) ;",
  "inst": "if (! (= Elision absent)) ... else ..."
}, {
  "algo": "ElementList3ArrayAccumulation1",
  "cond": "(! (= Elision absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . throws ( Test262Error , function  (  ) { [  0 ,  ... function *  (  ) { throw new Test262Error ( ) ; } ( ) ] ; } ) ;",
  "inst": "if (! (= Elision absent)) ... else ..."
}, {
  "algo": "Elision0IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var iter = function *  (  ) {  } ( ) ; iter . next ( ) ; var callCount = 0 ; var f  ; f = function *  ( [ ,  ] = iter ) { callCount = callCount + 1 ; } ; f ( ) . next ( ) ; assert . sameValue ( callCount , 1 , 'generator function invoked exactly once' ) ;"
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= iteratorRecord[\"Done\"] false)",
  "covered": true,
  "inst": "if (= iteratorRecord[\"Done\"] false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var values = [  1 ,  2 ,  3 ,  4 ,  5 ] ; var iterCount = 0 ; for ( const [ , , ... x ] = values ; iterCount < 1 ;  ) { assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 3 ) ; assert . sameValue ( x [ 0 ] , 3 ) ; assert . sameValue ( x [ 1 ] , 4 ) ; assert . sameValue ( x [ 2 ] , 5 ) ; assert . notSameValue ( x , values ) ; iterCount += 1 ; } assert . sameValue ( iterCount , 1 , 'Iteration occurred as expected' ) ;"
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "__x3__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var values = [  1 ,  2 ,  3 ,  4 ,  5 ] ; var iterCount = 0 ; for ( const [ , , ... x ] = values ; iterCount < 1 ;  ) { assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 3 ) ; assert . sameValue ( x [ 0 ] , 3 ) ; assert . sameValue ( x [ 1 ] , 4 ) ; assert . sameValue ( x [ 2 ] , 5 ) ; assert . notSameValue ( x , values ) ; iterCount += 1 ; } assert . sameValue ( iterCount , 1 , 'Iteration occurred as expected' ) ;",
  "inst": "if __x3__ ... else ..."
}, {
  "algo": "Elision1IteratorDestructuringAssignmentEvaluation0",
  "cond": "(= next false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var values = [  1 ,  2 ,  3 ,  4 ,  5 ] ; var iterCount = 0 ; for ( const [ , , ... x ] = values ; iterCount < 1 ;  ) { assert ( Array . isArray ( x ) ) ; assert . sameValue ( x . length , 3 ) ; assert . sameValue ( x [ 0 ] , 3 ) ; assert . sameValue ( x [ 1 ] , 4 ) ; assert . sameValue ( x [ 2 ] , 5 ) ; assert . notSameValue ( x , values ) ; iterCount += 1 ; } assert . sameValue ( iterCount , 1 , 'Iteration occurred as expected' ) ;",
  "inst": "if (= next false) ... else ..."
}, {
  "algo": "EqualityExpression2Evaluation0",
  "cond": "(= r true)",
  "covered": false,
  "inst": "if (= r true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= strict false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;",
  "inst": "if (= strict false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": false,
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": false,
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= __x4__ true)",
  "covered": false,
  "inst": "if (= __x4__ true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (= thisLex varEnv))",
  "covered": false,
  "inst": "while (! (= thisLex varEnv)) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (= (typeof thisEnvRec) \"ObjectEnvironmentRecord\"))",
  "covered": false,
  "inst": "if (! (= (typeof thisEnvRec) \"ObjectEnvironmentRecord\")) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": false,
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= __x8__ true)",
  "covered": false,
  "inst": "if (= __x8__ true) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredFunctionNames fn))",
  "covered": true,
  "inst": "if (! (contains declaredFunctionNames fn)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var result = eval ( 'function fn() {}() => 1, 42;;' ) ; assert . sameValue ( result , 42 ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var result = eval ( 'function fn() {}() => 1, 42;;' ) ; assert . sameValue ( result , 42 ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= fnDefinable false)",
  "covered": false,
  "inst": "if (= fnDefinable false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredFunctionNames vn))",
  "covered": true,
  "inst": "if (! (contains declaredFunctionNames vn)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; for (var run = false; run; ) { }' ) , undefined ) ; assert . sameValue ( eval ( '2; for (var run = false; run; ) { 3; }' ) , undefined ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; for (var run = false; run; ) { }' ) , undefined ) ; assert . sameValue ( eval ( '2; for (var run = false; run; ) { 3; }' ) , undefined ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= vnDefinable false)",
  "covered": false,
  "inst": "if (= vnDefinable false) ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(! (contains declaredVarNames vn))",
  "covered": true,
  "inst": "if (! (contains declaredVarNames vn)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; for (var run = false; run; ) { }' ) , undefined ) ; assert . sameValue ( eval ( '2; for (var run = false; run; ) { 3; }' ) , undefined ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var result = eval ( 'function fn() {}() => 1, 42;;' ) ; assert . sameValue ( result , 42 ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= bindingExists false)",
  "covered": true,
  "inst": "if (= bindingExists false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var result = eval ( 'function fn() {}() => 1, 42;;' ) ; assert . sameValue ( result , 42 ) ;"
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= (typeof varEnvRec) \"GlobalEnvironmentRecord\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; for (var run = false; run; ) { }' ) , undefined ) ; assert . sameValue ( eval ( '2; for (var run = false; run; ) { 3; }' ) , undefined ) ;",
  "inst": "if (= (typeof varEnvRec) \"GlobalEnvironmentRecord\") ... else ..."
}, {
  "algo": "EvalDeclarationInstantiation",
  "cond": "(= bindingExists false)",
  "covered": true,
  "inst": "if (= bindingExists false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( eval ( '1; for (var run = false; run; ) { }' ) , undefined ) ; assert . sameValue ( eval ( '2; for (var run = false; run; ) { 3; }' ) , undefined ) ;"
}, {
  "algo": "FlattenIntoArray",
  "cond": "(! (< targetIndex (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function compareArray ( a  , b  ) { if ( b . length !== a . length ) { return false ; } for ( var i = 0 ; i < a . length ; i ++ ) { if ( ! compareArray . isSameValue ( b [ i ] , a [ i ] ) ) { return false ; } } return true ; } compareArray . isSameValue = function  ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } ; compareArray . format = function  ( array  ) { return `[${ array . map ( String ) . join ( ', ' ) }]` ; } ; assert . compareArray = function  ( actual  , expected  , message  ) { var format = compareArray . format ; assert ( compareArray ( actual , expected ) , `Expected ${ format ( actual ) } and ${ format ( expected ) } to have the same contents. ${ ( message || '' ) }` ) ; } ; var a = [  1 ,  [  2 ] ] ; var expected = a ; var depthNum = 'TestString' ; var actual = a . flat ( depthNum ) ; assert ( compareArray ( actual , expected ) , 'non integral string depthNum' ) ; depthNum = { } ; actual = a . flat ( depthNum ) ; assert ( compareArray ( actual , expected ) , 'object type depthNum' ) ; depthNum = Number . NEGATIVE_INFINITY ; actual = a . flat ( depthNum ) ; assert ( compareArray ( actual , expected ) , 'negative infinity depthNum' ) ; depthNum = + 0 ; actual = a . flat ( depthNum ) ; assert ( compareArray ( actual , expected ) , 'positive zero depthNum' ) ; depthNum = - 0 ; actual = a . flat ( depthNum ) ; assert ( compareArray ( actual , expected ) , 'negative zero depthNum' ) ; depthNum = '1' ; actual = a . flat ( depthNum ) ; expected = [  1 ,  2 ] ; assert ( compareArray ( actual , expected ) , 'integral string depthNum' ) ;",
  "inst": "if (! (< targetIndex (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind absent)",
  "covered": true,
  "inst": "if (= iteratorKind absent) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var accessed = false ; var newObj = Object . create ( { } , { prop : { enumerable : null } } ) ; for ( var property in newObj ) { if ( property === \"prop\" ) { accessed = true ; } } assert . sameValue ( accessed , false , 'accessed' ) ;"
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var accessed = false ; var newObj = Object . create ( { } , { prop : { enumerable : null } } ) ; for ( var property in newObj ) { if ( property === \"prop\" ) { accessed = true ; } } assert . sameValue ( accessed , false , 'accessed' ) ;",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(! (= __x3__ Object))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var accessed = false ; var newObj = Object . create ( { } , { prop : { enumerable : null } } ) ; for ( var property in newObj ) { if ( property === \"prop\" ) { accessed = true ; } } assert . sameValue ( accessed , false , 'accessed' ) ;",
  "inst": "if (! (= __x3__ Object)) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "__x15__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } var arr = [  ] ; arr [ 0 ] = 100 ; Object . defineProperties ( arr , { \"0\" : { value : 100 , writable : true , enumerable : true , configurable : true } } ) ; verifyEqualTo ( arr , \"0\" , 100 ) ; verifyWritable ( arr , \"0\" ) ; verifyEnumerable ( arr , \"0\" ) ; verifyConfigurable ( arr , \"0\" ) ;",
  "inst": "if __x15__ ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var poisonedProperty = Object . defineProperty ( { } , 'poisoned' , { get : function  (  ) { throw new Test262Error ( ) ; } } ) ; assert . throws ( Test262Error , function  (  ) { for ( let { poisoned  } of [  poisonedProperty ] ) { return ; } } ) ;",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iterationKind CONST_enumerate)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var poisonedProperty = Object . defineProperty ( { } , 'poisoned' , { get : function  (  ) { throw new Test262Error ( ) ; } } ) ; assert . throws ( Test262Error , function  (  ) { for ( let { poisoned  } of [  poisonedProperty ] ) { return ; } } ) ;",
  "inst": "if (= iterationKind CONST_enumerate) ... else ..."
}, {
  "algo": "ForInOfBodyEvaluation",
  "cond": "(= iteratorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * values (  ) { yield 1 ; $ERROR ( 'This code is unreachable (following `yield` statement).' ) ; } var CustomError = function  (  ) {  } ; var iterator = values ( ) ; var i = 0 ; var error = new CustomError ( ) ; assert . throws ( CustomError , function  (  ) { for ( var x of iterator ) { try { throw new Error ( ) ; } catch ( err ) { i ++ ; throw error ; $ERROR ( 'This code is unreachable (following `throw` statement).' ) ; } $ERROR ( 'This code is unreachable (following `try` statement).' ) ; } $ERROR ( 'This code is unreachable (following `for..in` statement).' ) ; } ) ; assert . sameValue ( i , 1 ) ;",
  "inst": "if (= iteratorKind CONST_async) ... else ..."
}, {
  "algo": "ForInOfHeadEvaluation",
  "cond": "(= iterationKind CONST_asynciterate)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x  ; var counter = 0 ; for ( { y : x = 1 } of [  { y : 2 } ] ) { assert . sameValue ( x , 2 ) ; counter += 1 ; } assert . sameValue ( counter , 1 ) ;",
  "inst": "if (= iterationKind CONST_asynciterate) ... else ..."
}, {
  "algo": "FormalParameters4ContainsExpression0",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var value  ; function rest ( a  , ... b ) { arguments [ 0 ] = 2 ; value = a ; } rest ( 1 ) ; assert . sameValue ( value , 1 ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "FromPropertyDescriptor",
  "cond": "(! (= Desc[\"Enumerable\"] absent))",
  "covered": true,
  "inst": "if (! (= Desc[\"Enumerable\"] absent)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;"
}, {
  "algo": "FromPropertyDescriptor",
  "cond": "(! (= Desc[\"Configurable\"] absent))",
  "covered": true,
  "inst": "if (! (= Desc[\"Configurable\"] absent)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "__x1__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if __x1__ ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(! (contains functionNames fn))",
  "covered": true,
  "inst": "if (! (contains functionNames fn)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } ( function  (  ) { delete arguments [ 0 ] ; function getFunc (  ) { return 10 ; } function setFunc ( value  ) { this . setVerifyHelpProp = value ; } Object . defineProperty ( arguments , \"0\" , { get : getFunc , set : setFunc , enumerable : false , configurable : false } ) ; verifyEqualTo ( arguments , \"0\" , getFunc ( ) ) ; verifyWritable ( arguments , \"0\" , \"setVerifyHelpProp\" ) ; verifyNotEnumerable ( arguments , \"0\" ) ; verifyNotConfigurable ( arguments , \"0\" ) ; } ( 0 , 1 , 2 ) ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(contains parameterNames \"arguments\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (contains parameterNames \"arguments\") ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (contains functionNames \"arguments\") (contains lexicalNames \"arguments\"))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (|| (contains functionNames \"arguments\") (contains lexicalNames \"arguments\")) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (= strict true) (= hasParameterExpressions false))",
  "covered": true,
  "inst": "if (|| (= strict true) (= hasParameterExpressions false)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= alreadyDeclared false)",
  "covered": true,
  "inst": "if (= alreadyDeclared false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= hasDuplicates true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= hasDuplicates true) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (= strict true) (= simpleParameterList false))",
  "covered": true,
  "inst": "if (|| (= strict true) (= simpleParameterList false)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= strict true)",
  "covered": true,
  "inst": "if (= strict true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= hasDuplicates true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= hasDuplicates true) ... else ..."
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(! (contains instantiatedVarNames n))",
  "covered": true,
  "inst": "if (! (contains instantiatedVarNames n)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 'outside' ; var probeParams  , probeBody  ; ( function  ( _ = probeParams = function  (  ) { return x ; } ) { var x = 'inside' ; probeBody = function  (  ) { return x ; } ; } ( ) ) ; assert . sameValue ( probeParams ( ) , 'outside' ) ; assert . sameValue ( probeBody ( ) , 'inside' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(|| (! (contains parameterBindings n)) (contains functionNames n))",
  "covered": true,
  "inst": "if (|| (! (contains parameterBindings n)) (contains functionNames n)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 'outside' ; var probeParams  , probeBody  ; ( function  ( _ = probeParams = function  (  ) { return x ; } ) { var x = 'inside' ; probeBody = function  (  ) { return x ; } ; } ( ) ) ; assert . sameValue ( probeParams ( ) , 'outside' ) ; assert . sameValue ( probeBody ( ) , 'inside' ) ;"
}, {
  "algo": "FunctionDeclarationInstantiation",
  "cond": "(= strict false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= strict false) ... else ..."
}, {
  "algo": "FunctionEnvironmentRecordDOTGetSuperBase",
  "cond": "(= home undefined)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function ID ( x  ) { return x ; } var value  ; var proto = { m ( name  , v  ) { value = name + ' ' + v ; } } ; var object = { set [ 'a' ] ( v  ) { super . m ( 'a' , v ) ; } , set [ ID ( 'b' ) ] ( v  ) { super . m ( 'b' , v ) ; } , set [ 0 ] ( v  ) { super . m ( '0' , v ) ; } , set [ ID ( 1 ) ] ( v  ) { super . m ( '1' , v ) ; } , } ; Object . setPrototypeOf ( object , proto ) ; object . a = 2 ; assert . sameValue ( value , 'a 2' , \"The value of `value` is `'a 2'`, after executing `object.a = 2;`\" ) ; object . b = 3 ; assert . sameValue ( value , 'b 3' , \"The value of `value` is `'b 3'`, after executing `object.b = 3;`\" ) ; object [ 0 ] = 4 ; assert . sameValue ( value , '0 4' , \"The value of `value` is `'0 4'`, after executing `object[0] = 4;`\" ) ; object [ 1 ] = 5 ; assert . sameValue ( value , '1 5' , \"The value of `value` is `'1 5'`, after executing `object[1] = 5;`\" ) ;",
  "inst": "if (= home undefined) ... else ..."
}, {
  "algo": "FunctionEnvironmentRecordDOTHasSuperBinding",
  "cond": "(= envRec[\"ThisBindingStatus\"] CONST_lexical)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . throws ( ReferenceError , function  (  ) { ( 0 , eval ) ( 'typeof x; const x = null;' ) ; } ) ;",
  "inst": "if (= envRec[\"ThisBindingStatus\"] CONST_lexical) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTfrom",
  "cond": "(! (< k (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var C = function  (  ) { Object . defineProperty ( this , '0' , { writable : true , configurable : false } ) ; } ; var closeCount = 0 ; var items = { } ; var nextResult = { done : false } ; items [ Symbol . iterator ] = function  (  ) { return { return : function  (  ) { closeCount += 1 ; } , next : function  (  ) { var result = nextResult ; nextResult = { done : true } ; return result ; } } ; } ; assert . throws ( TypeError , function  (  ) { Array . from . call ( C , items ) ; } ) ; assert . sameValue ( closeCount , 1 ) ;",
  "inst": "if (! (< k (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTfrom",
  "cond": "(= __x28__ true)",
  "covered": true,
  "inst": "if (= __x28__ true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var items = { length : 1 , } ; var A1 = function  ( _length  ) { this . length = 0 ; Object . preventExtensions ( this ) ; } ; assert . throws ( TypeError , function  (  ) { Array . from . call ( A1 , items ) ; } ) ; var A2 = function  ( _length  ) { Object . defineProperty ( this , \"0\" , { writable : true , configurable : false , } ) ; } ; assert . throws ( TypeError , function  (  ) { Array . from . call ( A2 , items ) ; } ) ;"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTconcat",
  "cond": "(! (< n (- 9007199254740992i 1i)))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; Array . prototype [ 1 ] = 1 ; var x = [  0 ] ; x . length = 2 ; var arr = x . concat ( ) ; if ( arr [ 0 ] !== 0 ) { $ERROR ( '#1: Array.prototype[1] = 1; x = [0]; x.length = 2; var arr = x.concat(); arr[0] === 0. Actual: ' + ( arr [ 0 ] ) ) ; } if ( arr [ 1 ] !== 1 ) { $ERROR ( '#2: Array.prototype[1] = 1; x = [0]; x.length = 2; var arr = x.concat(); arr[1] === 1. Actual: ' + ( arr [ 1 ] ) ) ; } if ( arr . hasOwnProperty ( '1' ) !== true ) { $ERROR ( '#3: Array.prototype[1] = 1; x = [0]; x.length = 2; var arr = x.concat(); arr.hasOwnProperty(\\'1\\') === true. Actual: ' + ( arr . hasOwnProperty ( '1' ) ) ) ; } Object . prototype [ 1 ] = 1 ; Object . prototype . length = 2 ; Object . prototype . concat = Array . prototype . concat ; x = { 0 : 0 } ; var arr = x . concat ( ) ; if ( arr [ 0 ] !== x ) { $ERROR ( '#4: Object.prototype[1] = 1; Object.prototype.length = 2; Object.prototype.concat = Array.prototype.concat; x = {0:0}; var arr = x.concat(); arr[0] === x. Actual: ' + ( arr [ 0 ] ) ) ; } if ( arr [ 1 ] !== 1 ) { $ERROR ( '#5: Object.prototype[1] = 1; Object.prototype.length = 2; Object.prototype.concat = Array.prototype.concat; x = {0:0}; var arr = x.concat(); arr[1] === 1. Actual: ' + ( arr [ 1 ] ) ) ; } if ( arr . hasOwnProperty ( '1' ) !== false ) { $ERROR ( '#6: Object.prototype[1] = 1; Object.prototype.length = 2; Object.prototype.concat = Array.prototype.concat; x = {0:0}; var arr = x.concat(); arr.hasOwnProperty(\\'1\\') === false. Actual: ' + ( arr . hasOwnProperty ( '1' ) ) ) ; }",
  "inst": "if (! (< n (- 9007199254740992i 1i))) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTfind",
  "cond": "(= __x4__ false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o = { length : 1 } ; Object . defineProperty ( o , 0 , { get : function  (  ) { throw new Test262Error ( ) ; } } ) ; assert . throws ( Test262Error , function  (  ) { [  ] . find . call ( o , function  (  ) {  } ) ; } ) ;",
  "inst": "if (= __x4__ false) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTfindIndex",
  "cond": "(= __x4__ false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o = { length : 1 } ; Object . defineProperty ( o , 0 , { get : function  (  ) { throw new Test262Error ( ) ; } } ) ; assert . throws ( Test262Error , function  (  ) { [  ] . findIndex . call ( o , function  (  ) {  } ) ; } ) ;",
  "inst": "if (= __x4__ false) ... else ..."
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTslice",
  "cond": "(= kPresent true)",
  "covered": true,
  "inst": "if (= kPresent true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var typedArrayConstructors = [  Float64Array ,  Float32Array ,  Int32Array ,  Int16Array ,  Int8Array ,  Uint32Array ,  Uint16Array ,  Uint8Array ,  Uint8ClampedArray ] ; var floatArrayConstructors = typedArrayConstructors . slice ( 0 , 2 ) ; var intArrayConstructors = typedArrayConstructors . slice ( 2 , 7 ) ; var TypedArray = Object . getPrototypeOf ( Int8Array ) ; function testWithTypedArrayConstructors ( f  , selected  ) { var constructors = selected || typedArrayConstructors ; for ( var i = 0 ; i < constructors . length ; ++ i ) { var constructor = constructors [ i ] ; try { f ( constructor ) ; } catch ( e ) { e . message += \" (Testing with \" + constructor . name + \".)\" ; throw e ; } } } function testTypedArrayConversions ( byteConversionValues  , fn  ) { var values = byteConversionValues . values ; var expected = byteConversionValues . expected ; testWithTypedArrayConstructors ( function  ( TA  ) { var name = TA . name . slice ( 0 , - 5 ) ; return values . forEach ( function  ( value  , index  ) { var exp = expected [ name ] [ index ] ; var initial = 0 ; if ( exp === 0 ) { initial = 1 ; } fn ( TA , value , exp , initial ) ; } ) ; } ) ; } var TypedArrayPrototype = TypedArray . prototype ; assert . sameValue ( typeof TypedArrayPrototype . lastIndexOf , 'function' ) ; assert . throws ( TypeError , function  (  ) { TypedArrayPrototype . lastIndexOf ( ) ; } ) ;"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTsplice",
  "cond": "(= fromPresent true)",
  "covered": true,
  "inst": "if (= fromPresent true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } var a = [  1 ] ; a . constructor = { } ; a . constructor [ Symbol . species ] = function  ( len  ) { var q = new Array ( 0 ) ; Object . defineProperty ( q , 0 , { value : 0 , writable : false , configurable : true , enumerable : false , } ) ; return q ; } ; var r = a . splice ( 0 ) ; verifyProperty ( r , 0 , { value : 1 , writable : true , configurable : true , enumerable : true , } ) ;"
}, {
  "algo": "GLOBALDOTArrayDOTprototypeDOTtoString",
  "cond": "(= result false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { } ; Object . defineProperty ( obj , [  1 ,  2 ] , { } ) ; assert ( obj . hasOwnProperty ( \"1,2\" ) , 'obj.hasOwnProperty(\"1,2\") !== true' ) ;",
  "inst": "if (= result false) ... else ..."
}, {
  "algo": "GLOBALDOTAwaitFulfilledFunctions",
  "cond": "(= asyncContext[\"ReturnCont\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;",
  "inst": "if (= asyncContext[\"ReturnCont\"] absent) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x NaN)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x NaN) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x Infinity)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTBigIntDOTprototypeDOTtoString",
  "cond": "(= x Infinity)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; for ( let r = 2 ; r <= 36 ; r ++ ) { assert . sameValue ( ( 0n ) . toString ( r ) , \"0\" , \"0, radix \" + r ) ; assert . sameValue ( ( - 1n ) . toString ( r ) , \"-1\" , \"-1, radix \" + r ) ; assert . sameValue ( ( 1n ) . toString ( r ) , \"1\" , \"1, radix \" + r ) ; }",
  "inst": "if (= x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTbind",
  "cond": "(= targetHasLength true)",
  "covered": true,
  "inst": "if (= targetHasLength true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var func = function  (  ) { return new Boolean ( arguments . length === 1 && arguments [ 0 ] === 1 ) ; } ; var NewFunc = Function . prototype . bind . call ( func , { } , 1 ) ; var newInstance = new NewFunc ( ) ; assert . sameValue ( newInstance . valueOf ( ) , true , 'newInstance.valueOf()' ) ;"
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTbind",
  "cond": "(! (= __x6__ Number))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var func = function  (  ) { return new Boolean ( arguments . length === 1 && arguments [ 0 ] === 1 ) ; } ; var NewFunc = Function . prototype . bind . call ( func , { } , 1 ) ; var newInstance = new NewFunc ( ) ; assert . sameValue ( newInstance . valueOf ( ) , true , 'newInstance.valueOf()' ) ;",
  "inst": "if (! (= __x6__ Number)) ... else ..."
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTtoString",
  "cond": "(&& (= T \"String\") available)",
  "covered": true,
  "inst": "if (&& (= T \"String\") available) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = { } ; if ( isNaN ( -- x ) !== true ) { $ERROR ( '#1: var x = {}; --x === Not-a-Number. Actual: ' + ( -- x ) ) ; } var x = function  (  ) { return 1 ; } ; if ( isNaN ( -- x ) !== true ) { $ERROR ( '#2: var x = function(){return 1}; --x === Not-a-Number. Actual: ' + ( -- x ) ) ; }"
}, {
  "algo": "GLOBALDOTFunctionDOTprototypeDOTtoString",
  "cond": "__x2__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . throws ( TypeError , function  (  ) { Function . prototype . toString . call ( { } ) ; } ) ;",
  "inst": "if __x2__ ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(! (= __x0__ Object))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { method ( [  fn = function  (  ) {  } ,  xFn = function x (  ) {  } ] = [  ] ) { assert . sameValue ( fn . name , 'fn' ) ; assert . notSameValue ( xFn . name , 'xFn' ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if (! (= __x0__ Object)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(! (= a[\"TypedArrayName\"] absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var callCount = 0 ; var C = class   { method ( [  fn = function  (  ) {  } ,  xFn = function x (  ) {  } ] = [  ] ) { assert . sameValue ( fn . name , 'fn' ) ; assert . notSameValue ( xFn . name , 'xFn' ) ; callCount = callCount + 1 ; } } ; new C ( ) . method ( ) ; assert . sameValue ( callCount , 1 , 'method invoked exactly once' ) ;",
  "inst": "if (! (= a[\"TypedArrayName\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_ArrayIteratorPrototypeDOTnext",
  "cond": "(= __x5__ true)",
  "covered": false,
  "inst": "if (= __x5__ true) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_StringIteratorPrototypeDOTnext",
  "cond": "(! (= __x0__ Object))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var counter = 0 ; for ( [ , ] of [  'string literal' ] ) { counter += 1 ; } assert . sameValue ( counter , 1 ) ;",
  "inst": "if (! (= __x0__ Object)) ... else ..."
}, {
  "algo": "GLOBALDOTINTRINSIC_StringIteratorPrototypeDOTnext",
  "cond": "(= s undefined)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var counter = 0 ; for ( [ , ] of [  'string literal' ] ) { counter += 1 ; } assert . sameValue ( counter , 1 ) ;",
  "inst": "if (= s undefined) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTisSafeInteger",
  "cond": "(! (< (- 9007199254740992i 1i) __x2__))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( Number . isSafeInteger ( 9007199254740992 ) , false , \"2**53\" ) ; assert . sameValue ( Number . isSafeInteger ( - 9007199254740992 ) , false , \"-(2**53)\" ) ;",
  "inst": "if (! (< (- 9007199254740992i 1i) __x2__)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(< x 0i)",
  "covered": false,
  "inst": "if (< x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(== x Infinity)",
  "covered": false,
  "inst": "if (== x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(|| (< f 0i) (< 100i f))",
  "covered": false,
  "inst": "if (|| (< f 0i) (< 100i f)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(== x 0i)",
  "covered": false,
  "inst": "if (== x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(! (= fractionDigits undefined))",
  "covered": false,
  "inst": "if (! (= fractionDigits undefined)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(! (== f 0i))",
  "covered": false,
  "inst": "if (! (== f 0i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(== e 0i)",
  "covered": false,
  "inst": "if (== e 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoExponential",
  "cond": "(< 0i e)",
  "covered": false,
  "inst": "if (< 0i e) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(|| (< f 0i) (< 100i f))",
  "covered": false,
  "inst": "if (|| (< f 0i) (< 100i f)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(< x 0i)",
  "covered": false,
  "inst": "if (< x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(! (< x 9223372036854775807i))",
  "covered": false,
  "inst": "if (! (< x 9223372036854775807i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(! (== f 0i))",
  "covered": false,
  "inst": "if (! (== f 0i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoFixed",
  "cond": "(! (< f k))",
  "covered": false,
  "inst": "if (! (< f k)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(= precision undefined)",
  "covered": false,
  "inst": "if (= precision undefined) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(< x 0i)",
  "covered": false,
  "inst": "if (< x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(== x Infinity)",
  "covered": false,
  "inst": "if (== x Infinity) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(|| (< p 1i) (< 100i p))",
  "covered": false,
  "inst": "if (|| (< p 1i) (< 100i p)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(== x 0i)",
  "covered": false,
  "inst": "if (== x 0i) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(|| (< e (- 6i)) (! (< e p)))",
  "covered": false,
  "inst": "if (|| (< e (- 6i)) (! (< e p))) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(! (== p 1i))",
  "covered": false,
  "inst": "if (! (== p 1i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(< 0i e)",
  "covered": false,
  "inst": "if (< 0i e) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(== e (- p 1i))",
  "covered": false,
  "inst": "if (== e (- p 1i)) ... else ..."
}, {
  "algo": "GLOBALDOTNumberDOTprototypeDOTtoPrecision",
  "cond": "(! (< e 0i))",
  "covered": false,
  "inst": "if (! (< e 0i)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTfreeze",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var errObj = new SyntaxError ( ) ; Object . freeze ( errObj ) ; assert ( Object . isFrozen ( errObj ) , 'Object.isFrozen(errObj) !== true' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTgetOwnPropertyDescriptors",
  "cond": "(! (= descriptor undefined))",
  "covered": true,
  "inst": "if (! (= descriptor undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function fakeObjectGetOwnPropertyDescriptor (  ) { $ERROR ( 'The overriden version of Object.getOwnPropertyDescriptor was called!' ) ; } Object . getOwnPropertyDescriptor = fakeObjectGetOwnPropertyDescriptor ; assert . sameValue ( Object . getOwnPropertyDescriptor , fakeObjectGetOwnPropertyDescriptor , 'Sanity check failed: could not modify the global Object.getOwnPropertyDescriptor' ) ; assert . sameValue ( Object . keys ( Object . getOwnPropertyDescriptors ( { a : 1 } ) ) . length , 1 , 'Expected object with 1 key to have 1 descriptor' ) ;"
}, {
  "algo": "GLOBALDOTObjectDOTpreventExtensions",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { } ; Object . defineProperty ( obj , \"foo\" , { value : 12 , writable : true , configurable : false } ) ; Object . preventExtensions ( obj ) ; assert . sameValue ( Object . isFrozen ( obj ) , false , 'Object.isFrozen(obj)' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTprototypeDOTtoString",
  "cond": "(! (= O[\"DateValue\"] absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } verifyProperty ( BigInt , \"prototype\" , { writable : false , enumerable : false , configurable : false } ) ;",
  "inst": "if (! (= O[\"DateValue\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTprototypeDOTtoString",
  "cond": "(! (= O[\"RegExpMatcher\"] absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } verifyProperty ( BigInt , \"prototype\" , { writable : false , enumerable : false , configurable : false } ) ;",
  "inst": "if (! (= O[\"RegExpMatcher\"] absent)) ... else ..."
}, {
  "algo": "GLOBALDOTObjectDOTseal",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } var proto = { } ; Object . defineProperty ( proto , \"foo\" , { get : function  (  ) { return 0 ; } , configurable : true } ) ; var ConstructFun = function  (  ) {  } ; ConstructFun . prototype = proto ; var obj = new ConstructFun ( ) ; Object . defineProperty ( obj , \"foo\" , { value : 10 , configurable : true } ) ; assert ( Object . isExtensible ( obj ) ) ; Object . seal ( obj ) ; verifyNotConfigurable ( obj , \"foo\" ) ; assert . sameValue ( obj . foo , 10 ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "GLOBALDOTPromise",
  "cond": "__x7__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var poisonedThen = Object . defineProperty ( new Promise ( function  (  ) {  } ) , 'then' , { get : function  (  ) { throw new Test262Error ( ) ; } } ) ; assert . throws ( Test262Error , function  (  ) { Promise . prototype . finally . call ( poisonedThen ) ; } ) ; assert . throws ( Test262Error , function  (  ) { poisonedThen . finally ( ) ; } ) ;",
  "inst": "if __x7__ ... else ..."
}, {
  "algo": "GLOBALDOTPromiseDOTallSettledRejectElementFunctions",
  "cond": "(= alreadyCalled[\"Value\"] true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var p1 = Promise . resolve ( 1 ) ; var p2 = Promise . resolve ( 1 ) ; var p3 = Promise . reject ( 1 ) ; var p4 = Promise . resolve ( 1 ) ; var resolve = Promise . resolve ; var getCount = 0 ; var callCount = 0 ; Object . defineProperty ( Promise , 'resolve' , { configurable : true , get (  ) { getCount += 1 ; return function  (  ) { callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; } } ) ; Promise . allSettled ( [  p1 ,  p2 ,  p3 ,  p4 ] ) ; assert . sameValue ( getCount , 1 , 'Got `resolve` only once for each iterated value' ) ; assert . sameValue ( callCount , 4 , '`resolve` invoked once for each iterated value' ) ;",
  "inst": "if (= alreadyCalled[\"Value\"] true) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseDOTallSettledRejectElementFunctions",
  "cond": "(= remainingElementsCount[\"Value\"] 0i)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var p1 = Promise . resolve ( 1 ) ; var p2 = Promise . resolve ( 1 ) ; var p3 = Promise . reject ( 1 ) ; var p4 = Promise . resolve ( 1 ) ; var resolve = Promise . resolve ; var getCount = 0 ; var callCount = 0 ; Object . defineProperty ( Promise , 'resolve' , { configurable : true , get (  ) { getCount += 1 ; return function  (  ) { callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; } } ) ; Promise . allSettled ( [  p1 ,  p2 ,  p3 ,  p4 ] ) ; assert . sameValue ( getCount , 1 , 'Got `resolve` only once for each iterated value' ) ; assert . sameValue ( callCount , 4 , '`resolve` invoked once for each iterated value' ) ;",
  "inst": "if (= remainingElementsCount[\"Value\"] 0i) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseResolveFunctions",
  "cond": "(= __x2__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { async method (  ) {  } } ; var p = obj . method ( ) ; assert ( p instanceof Promise , \"async functions return promise instances\" ) ;",
  "inst": "if (= __x2__ true) ... else ..."
}, {
  "algo": "GLOBALDOTPromiseResolveFunctions",
  "cond": "__x9__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var executor = null ; var callCount = 0 ; class SubPromise extends Promise { constructor ( a  ) { super ( a ) ; executor = a ; callCount += 1 ; } } var instance = Promise . all . call ( SubPromise , [  ] ) ; assert . sameValue ( instance . constructor , SubPromise ) ; assert . sameValue ( instance instanceof SubPromise , true ) ; assert . sameValue ( callCount , 1 ) ; assert . sameValue ( typeof executor , 'function' ) ;",
  "inst": "if __x9__ ... else ..."
}, {
  "algo": "GLOBALDOTSetDOTprototypeDOTdelete",
  "cond": "__x4__",
  "covered": true,
  "inst": "if __x4__ ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var s = new Set ( ) ; assert . sameValue ( s . size , 0 , \"The value of `s.size` is `0`\" ) ; s . add ( 1 ) ; assert . sameValue ( s . size , 1 , \"The value of `s.size` is `1`, after executing `s.add(1)`\" ) ; var result = s . delete ( 1 ) ; assert . sameValue ( s . size , 0 , \"The value of `s.size` is `0`, after executing `s.delete(1)`\" ) ; assert . sameValue ( result , true , \"The result of `s.delete(1)` is `true`\" ) ;"
}, {
  "algo": "GLOBALDOTStringDOTfromCharCode",
  "cond": "(< nextIndex length)",
  "covered": false,
  "inst": "while (< nextIndex length) { ... }"
}, {
  "algo": "GLOBALDOTStringDOTfromCodePoint",
  "cond": "(< nextIndex length)",
  "covered": false,
  "inst": "while (< nextIndex length) { ... }"
}, {
  "algo": "GLOBALDOTStringDOTfromCodePoint",
  "cond": "(= __x1__ false)",
  "covered": false,
  "inst": "if (= __x1__ false) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTfromCodePoint",
  "cond": "(|| (< nextCP 0i) (< 1114111i nextCP))",
  "covered": false,
  "inst": "if (|| (< nextCP 0i) (< 1114111i nextCP)) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTfromCodePoint",
  "cond": "(< __x6__ __x5__[\"length\"])",
  "covered": false,
  "inst": "while (< __x6__ __x5__[\"length\"]) { ... }"
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTcharCodeAt",
  "cond": "(|| (< position 0i) (! (< position size)))",
  "covered": false,
  "inst": "if (|| (< position 0i) (! (< position size))) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTendsWith",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . sameValue ( 'word' . endsWith ( 'd' , 3 ) , false , '\"word\".endsWith(\"d\", 3)' ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTincludes",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var str = 'The future is cool!' ; assert . sameValue ( str . includes ( 'The future' , 1 ) , false , 'Returns false on str.includes(\"The future\", 1)' ) ; assert . sameValue ( str . includes ( str , 1 ) , false , 'Returns false on str.includes(str, 1)' ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { } ; var returnVal = { } ; var callCount = 0 ; var thisVal  , args  ; obj [ Symbol . matchAll ] = function  (  ) { callCount ++ ; thisVal = this ; args = arguments ; return returnVal ; } ; var str = '' ; assert . sameValue ( str . matchAll ( obj ) , returnVal ) ; assert . sameValue ( callCount , 1 , 'Invokes the method exactly once' ) ; assert . sameValue ( thisVal , obj ) ; assert . notSameValue ( args , undefined ) ; assert . sameValue ( args . length , 1 ) ; assert . sameValue ( args [ 0 ] , str ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(! (contains __x5__ \"g\"))",
  "covered": false,
  "inst": "if (! (contains __x5__ \"g\")) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTmatchAll",
  "cond": "(! (= matcher undefined))",
  "covered": true,
  "inst": "if (! (= matcher undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { } ; var returnVal = { } ; var callCount = 0 ; var thisVal  , args  ; obj [ Symbol . matchAll ] = function  (  ) { callCount ++ ; thisVal = this ; args = arguments ; return returnVal ; } ; var str = '' ; assert . sameValue ( str . matchAll ( obj ) , returnVal ) ; assert . sameValue ( callCount , 1 , 'Invokes the method exactly once' ) ; assert . sameValue ( thisVal , obj ) ; assert . notSameValue ( args , undefined ) ; assert . sameValue ( args . length , 1 ) ; assert . sameValue ( args [ 0 ] , str ) ;"
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTreplace",
  "cond": "(! (|| (= searchValue undefined) (= searchValue null)))",
  "covered": false,
  "inst": "if (! (|| (= searchValue undefined) (= searchValue null))) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTreplace",
  "cond": "(! (= replacer undefined))",
  "covered": false,
  "inst": "if (! (= replacer undefined)) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTreplace",
  "cond": "(= functionalReplace false)",
  "covered": false,
  "inst": "if (= functionalReplace false) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTreplace",
  "cond": "(= functionalReplace true)",
  "covered": false,
  "inst": "if (= functionalReplace true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTprototypeDOTstartsWith",
  "cond": "(= isRegExp true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var str = 'The future is cool!' ; assert ( str . startsWith ( '' ) , 'str.startsWith(\"\") returns true' ) ; assert ( str . startsWith ( '' , str . length ) , 'str.startsWith(\"\", str.length) returns true' ) ; assert ( str . startsWith ( '' ) , 'str.startsWith(\"\") returns true' ) ; assert ( str . startsWith ( '' , Infinity ) , 'str.startsWith(\"\", Infinity) returns true' ) ;",
  "inst": "if (= isRegExp true) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTraw",
  "cond": "(! (< 0i literalSegments))",
  "covered": false,
  "inst": "if (! (< 0i literalSegments)) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTraw",
  "cond": "(== (+ nextIndex 1i) literalSegments)",
  "covered": false,
  "inst": "if (== (+ nextIndex 1i) literalSegments) ... else ..."
}, {
  "algo": "GLOBALDOTStringDOTraw",
  "cond": "(< nextIndex numberOfSubstitutions)",
  "covered": false,
  "inst": "if (< nextIndex numberOfSubstitutions) ... else ..."
}, {
  "algo": "GLOBALDOTSymbolDOTkeyFor",
  "cond": "(= cond true)",
  "covered": true,
  "inst": "if (= cond true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var canonical = Symbol . for ( 's' ) ; assert . sameValue ( Symbol . keyFor ( canonical ) , 's' ) ;"
}, {
  "algo": "GLOBALDOTSyntaxError",
  "cond": "(= NewTarget undefined)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var errObj = new SyntaxError ( ) ; Object . freeze ( errObj ) ; assert ( Object . isFrozen ( errObj ) , 'Object.isFrozen(errObj) !== true' ) ;",
  "inst": "if (= NewTarget undefined) ... else ..."
}, {
  "algo": "GLOBALDOTWeakMapDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var map = new WeakMap ( ) ; var key = { } ; assert . sameValue ( map . get ( key ) , undefined , 'returns undefined if key is not on the weakmap' ) ; map . set ( key , 1 ) ; map . set ( { } , 2 ) ; map . delete ( key ) ; map . set ( { } , 3 ) ; assert . sameValue ( map . get ( key ) , undefined , 'returns undefined if key was deleted' ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTadd",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var s = new WeakSet ( ) ; var foo = { } ; var bar = { } ; var baz = { } ; s . add ( foo ) ; s . add ( bar ) ; s . add ( baz ) ; assert ( s . has ( foo ) ) ; assert ( s . has ( bar ) ) ; assert ( s . has ( baz ) ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var foo = { } ; var bar = { } ; var s = new WeakSet ( ) ; assert . sameValue ( s . has ( foo ) , false ) ; s . add ( foo ) ; assert . sameValue ( s . has ( bar ) , false ) ; s . delete ( foo ) ; assert . sameValue ( s . has ( foo ) , false ) ;"
}, {
  "algo": "GLOBALDOTWeakSetDOTprototypeDOTdelete",
  "cond": "__x6__",
  "covered": true,
  "inst": "if __x6__ ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var foo = { } ; var bar = { } ; var s = new WeakSet ( ) ; assert . sameValue ( s . has ( foo ) , false ) ; s . add ( foo ) ; assert . sameValue ( s . has ( bar ) , false ) ; s . delete ( foo ) ; assert . sameValue ( s . has ( foo ) , false ) ;"
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(! (== R 0i))",
  "covered": false,
  "inst": "if (! (== R 0i)) ... else ..."
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(|| (< R 2i) (< 36i R))",
  "covered": false,
  "inst": "if (|| (< R 2i) (< 36i R)) ... else ..."
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(! (== R 16i))",
  "covered": false,
  "inst": "if (! (== R 16i)) ... else ..."
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(= stripPrefix true)",
  "covered": false,
  "inst": "if (= stripPrefix true) ... else ..."
}, {
  "algo": "GLOBALDOTparseInt",
  "cond": "(= Z[\"length\"] 0i)",
  "covered": false,
  "inst": "if (= Z[\"length\"] 0i) ... else ..."
}, {
  "algo": "GeneratorResumeAbrupt",
  "cond": "(= genContext[\"ReturnCont\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; const iter = ( function *  (  ) { yield ; yield ; } ) ( ) ; function fn (  ) { for ( const [ ,  ] = iter ;  ;  ) { return ; } } fn ( ) ; assert . sameValue ( iter . next ( ) . done , true , 'iteration occurred as expected' ) ;",
  "inst": "if (= genContext[\"ReturnCont\"] absent) ... else ..."
}, {
  "algo": "GeneratorStart",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { } ; var falseCount = 0 ; var stringCount = 0 ; var nanCount = 0 ; var zeroCount = 0 ; var nullCount = 0 ; var objCount = 0 ; var callCount = 0 ; function * ref ( aFalse = falseCount += 1 , aString = stringCount += 1 , aNaN = nanCount += 1 , a0 = zeroCount += 1 , aNull = nullCount += 1 , aObj = objCount += 1 ) { assert . sameValue ( aFalse , false ) ; assert . sameValue ( aString , '' ) ; assert . sameValue ( aNaN , NaN ) ; assert . sameValue ( a0 , 0 ) ; assert . sameValue ( aNull , null ) ; assert . sameValue ( aObj , obj ) ; callCount = callCount + 1 ; } ref ( false , '' , NaN , 0 , null , obj ) . next ( ) ; assert . sameValue ( callCount , 1 , 'generator function invoked exactly once' ) ; assert . sameValue ( falseCount , 0 , 'initializer not evaluated: false' ) ; assert . sameValue ( stringCount , 0 , 'initializer not evaluated: string' ) ; assert . sameValue ( nanCount , 0 , 'initializer not evaluated: NaN' ) ; assert . sameValue ( zeroCount , 0 , 'initializer not evaluated: 0' ) ; assert . sameValue ( nullCount , 0 , 'initializer not evaluated: null' ) ; assert . sameValue ( objCount , 0 , 'initializer not evaluated: object' ) ;"
}, {
  "algo": "GeneratorYield",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] genContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function compareArray ( a  , b  ) { if ( b . length !== a . length ) { return false ; } for ( var i = 0 ; i < a . length ; i ++ ) { if ( ! compareArray . isSameValue ( b [ i ] , a [ i ] ) ) { return false ; } } return true ; } compareArray . isSameValue = function  ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } ; compareArray . format = function  ( array  ) { return `[${ array . map ( String ) . join ( ', ' ) }]` ; } ; assert . compareArray = function  ( actual  , expected  , message  ) { var format = compareArray . format ; assert ( compareArray ( actual , expected ) , `Expected ${ format ( actual ) } and ${ format ( expected ) } to have the same contents. ${ ( message || '' ) }` ) ; } ; var arr = [  'a' ,  'b' ,  'c' ] ; var item  ; var callCount = 0 ; var gen = function *  (  ) { callCount += 1 ; yield [  ... yield yield ] ; } ; var iter = gen ( ) ; iter . next ( false ) ; item = iter . next ( [  'a' ,  'b' ,  'c' ] ) ; item = iter . next ( item . value ) ; assert ( compareArray ( item . value , arr ) ) ; assert . sameValue ( item . done , false ) ; assert . sameValue ( callCount , 1 ) ;"
}, {
  "algo": "GetActiveScriptOrModule",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "GetActiveScriptOrModule",
  "cond": "(! (< k 0i))",
  "covered": true,
  "inst": "while (! (< k 0i)) { ... }",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= (typeof obj) \"BoundFunctionExoticObject\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class FooPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . resolve ( ) . finally ( ( ) => FooPromise . resolve ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof FooPromise , false ) ;",
  "inst": "if (= (typeof obj) \"BoundFunctionExoticObject\") ... else ..."
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= (typeof obj) \"ProxyExoticObject\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class FooPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . resolve ( ) . finally ( ( ) => FooPromise . resolve ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof FooPromise , false ) ;",
  "inst": "if (= (typeof obj) \"ProxyExoticObject\") ... else ..."
}, {
  "algo": "GetFunctionRealm",
  "cond": "(= obj[\"ProxyHandler\"] null)",
  "covered": false,
  "inst": "if (= obj[\"ProxyHandler\"] null) ... else ..."
}, {
  "algo": "GetIterator",
  "cond": "(= method undefined)",
  "covered": true,
  "inst": "if (= method undefined) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } async function * asyncg (  ) { yield * g ( ) ; } var result = asyncg ( ) . next ( ) ; assert ( result instanceof Promise ) ;"
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%String.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%String.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Array.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Array.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Boolean.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Boolean.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Number.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Number.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Map.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Map.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Set.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Set.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%WeakMap.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%WeakMap.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%WeakSet.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%WeakSet.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Error.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%Error.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%EvalError.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%EvalError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%ReferenceError.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%ReferenceError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%SyntaxError.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%SyntaxError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%TypeError.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%TypeError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%URIError.prototype%\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function * g (  ) {  } var GeneratorPrototype = Object . getPrototypeOf ( g ) . prototype ; g . prototype = null ; assert . sameValue ( Object . getPrototypeOf ( g ( ) ) , GeneratorPrototype ) ;",
  "inst": "if (= intrinsicDefaultProto \"%URIError.prototype%\") ... else ..."
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%AsyncGenerator.prototype%\")",
  "covered": true,
  "inst": "if (= intrinsicDefaultProto \"%AsyncGenerator.prototype%\") ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; async function * g ( a = ( g . prototype = null ) ) {  } var oldPrototype = g . prototype ; var it = g ( ) ; assert . notSameValue ( Object . getPrototypeOf ( it ) , oldPrototype ) ;"
}, {
  "algo": "GetPrototypeFromConstructor",
  "cond": "(= intrinsicDefaultProto \"%Promise.prototype%\")",
  "covered": false,
  "inst": "if (= intrinsicDefaultProto \"%Promise.prototype%\") ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x4__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class A  {  } class B extends A { method (  ) {  } static method (  ) {  } ; } assert . sameValue ( typeof B , \"function\" ) ; assert . sameValue ( typeof B . prototype . method , \"function\" ) ; assert . sameValue ( typeof B . method , \"function\" ) ;",
  "inst": "if (= __x4__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x6__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class A  {  } class B extends A { method (  ) {  } static method (  ) {  } ; } assert . sameValue ( typeof B , \"function\" ) ; assert . sameValue ( typeof B . prototype . method , \"function\" ) ; assert . sameValue ( typeof B . method , \"function\" ) ;",
  "inst": "if (= __x6__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= hasRestrictedGlobal true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class A  {  } class B extends A { method (  ) {  } static method (  ) {  } ; } assert . sameValue ( typeof B , \"function\" ) ; assert . sameValue ( typeof B . prototype . method , \"function\" ) ; assert . sameValue ( typeof B . method , \"function\" ) ;",
  "inst": "if (= hasRestrictedGlobal true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= __x12__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= __x12__ true) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= fnDefinable false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= fnDefinable false) ... else ..."
}, {
  "algo": "GlobalDeclarationInstantiation",
  "cond": "(= vnDefinable false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= vnDefinable false) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCanDeclareGlobalFunction",
  "cond": "(= existingProp[\"Configurable\"] true)",
  "covered": true,
  "inst": "if (= existingProp[\"Configurable\"] true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function Array (  ) {  } var o = { x : 1 , y : 2 } ; var a = Object . keys ( o ) ; var s = Object . prototype . toString . call ( a ) ; assert . sameValue ( s , '[object Array]' , 's' ) ;"
}, {
  "algo": "GlobalEnvironmentRecordDOTCanDeclareGlobalFunction",
  "cond": "(&& (&& (= result true) (= existingProp[\"Writable\"] true)) (= existingProp[\"Enumerable\"] true))",
  "covered": false,
  "inst": "if (&& (&& (= result true) (= existingProp[\"Writable\"] true)) (= existingProp[\"Enumerable\"] true)) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(|| (= existingProp undefined) (= existingProp[\"Configurable\"] true))",
  "covered": true,
  "inst": "if (|| (= existingProp undefined) (= existingProp[\"Configurable\"] true)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(! (= ObjRec[\"SubMap\"][N] absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (! (= ObjRec[\"SubMap\"][N] absent)) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalFunctionBinding",
  "cond": "(! (contains varDeclaredNames N))",
  "covered": true,
  "inst": "if (! (contains varDeclaredNames N)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateGlobalVarBinding",
  "cond": "(! (contains varDeclaredNames N))",
  "covered": true,
  "inst": "if (! (contains varDeclaredNames N)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateImmutableBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; const [  x = 23 ] = [ , ] ; assert . sameValue ( x , 23 ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTCreateMutableBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class A  {  } class B extends A { method (  ) {  } static method (  ) {  } ; } assert . sameValue ( typeof B , \"function\" ) ; assert . sameValue ( typeof B . prototype . method , \"function\" ) ; assert . sameValue ( typeof B . method , \"function\" ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTHasRestrictedGlobalProperty",
  "cond": "(= existingProp undefined)",
  "covered": true,
  "inst": "if (= existingProp undefined) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class A  {  } class B extends A { method (  ) {  } static method (  ) {  } ; } assert . sameValue ( typeof B , \"function\" ) ; assert . sameValue ( typeof B . prototype . method , \"function\" ) ; assert . sameValue ( typeof B . method , \"function\" ) ;"
}, {
  "algo": "GlobalEnvironmentRecordDOTHasRestrictedGlobalProperty",
  "cond": "(= existingProp[\"Configurable\"] true)",
  "covered": false,
  "inst": "if (= existingProp[\"Configurable\"] true) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTHasVarDeclaration",
  "cond": "(contains varDeclaredNames N)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class A  {  } class B extends A { method (  ) {  } static method (  ) {  } ; } assert . sameValue ( typeof B , \"function\" ) ; assert . sameValue ( typeof B . prototype . method , \"function\" ) ; assert . sameValue ( typeof B . method , \"function\" ) ;",
  "inst": "if (contains varDeclaredNames N) ... else ..."
}, {
  "algo": "GlobalEnvironmentRecordDOTInitializeBinding",
  "cond": "(= __x0__ true)",
  "covered": true,
  "inst": "if (= __x0__ true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class A  {  } class B extends A { method (  ) {  } static method (  ) {  } ; } assert . sameValue ( typeof B , \"function\" ) ; assert . sameValue ( typeof B . prototype . method , \"function\" ) ; assert . sameValue ( typeof B . method , \"function\" ) ;"
}, {
  "algo": "InitializeBoundName",
  "cond": "(! (= environment undefined))",
  "covered": true,
  "inst": "if (! (= environment undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "InstanceofOperator",
  "cond": "(= __x6__ false)",
  "covered": true,
  "inst": "if (= __x6__ false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var MyFunct = function  (  ) {  } ; var __my__funct = new MyFunct ; if ( ! ( __my__funct instanceof MyFunct ) ) { $ERROR ( '#1 Only Function objects implement [[HasInstance]] and consequently can be proper ShiftExpression for The instanceof operator' ) ; } if ( __my__funct instanceof Function ) { $ERROR ( '#2 Only Function objects implement [[HasInstance]] and consequently can be proper ShiftExpression for The instanceof operator' ) ; } if ( ! ( __my__funct instanceof Object ) ) { $ERROR ( '#3 Only Function objects implement [[HasInstance]] and consequently can be proper ShiftExpression for The instanceof operator' ) ; } try { __my__funct instanceof __my__funct ; $ERROR ( '#4 Only Function objects implement [[HasInstance]] and consequently can be proper ShiftExpression for The instanceof operator' ) ; } catch ( e ) { if ( e instanceof TypeError !== true ) { $ERROR ( '#4 Only Function objects implement [[HasInstance]] and consequently can be proper ShiftExpression for The instanceof operator' ) ; } }"
}, {
  "algo": "IsAccessorDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsArray",
  "cond": "(= (typeof argument) \"ProxyExoticObject\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function callbackfn ( val  , idx  , obj  ) { if ( idx === 0 ) { return val === 11 ; } if ( idx === 1 ) { return val === 12 ; } return false ; } var obj = { 0 : 11 , 1 : 12 , length : 2 } ; var newArr = Array . prototype . filter . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ; assert . sameValue ( newArr [ 0 ] , 11 , 'newArr[0]' ) ; assert . sameValue ( newArr [ 1 ] , 12 , 'newArr[1]' ) ;",
  "inst": "if (= (typeof argument) \"ProxyExoticObject\") ... else ..."
}, {
  "algo": "IsArray",
  "cond": "(= argument[\"ProxyHandler\"] null)",
  "covered": false,
  "inst": "if (= argument[\"ProxyHandler\"] null) ... else ..."
}, {
  "algo": "IsDataDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsDuplicate",
  "cond": "(= list[i] list[j])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= list[i] list[j]) ... else ..."
}, {
  "algo": "IsGenericDescriptor",
  "cond": "(= Desc undefined)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= Desc undefined) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of __x1__ AsyncConciseBody)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (is-instance-of __x1__ AsyncConciseBody) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of __x3__ AsyncConciseBody)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (is-instance-of __x3__ AsyncConciseBody) ... else ..."
}, {
  "algo": "IsInTailPosition",
  "cond": "(is-instance-of body AsyncConciseBody)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (is-instance-of body AsyncConciseBody) ... else ..."
}, {
  "algo": "IsNonNegativeInteger",
  "cond": "(&& (= __x0__ true) (! (< argument 0i)))",
  "covered": true,
  "inst": "if (&& (= __x0__ true) (! (< argument 0i))) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "IsPropertyKey",
  "cond": "(= __x2__ Symbol)",
  "covered": true,
  "inst": "if (= __x2__ Symbol) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "IsRegExp",
  "cond": "(! (= matcher undefined))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { toString : function  (  ) { throw new Test262Error ( ) ; } } ; assert . throws ( Test262Error , function  (  ) { '' . startsWith ( obj ) ; } ) ;",
  "inst": "if (! (= matcher undefined)) ... else ..."
}, {
  "algo": "IsRegExp",
  "cond": "(! (= argument[\"RegExpMatcher\"] absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { toString : function  (  ) { throw new Test262Error ( ) ; } } ; assert . throws ( Test262Error , function  (  ) { '' . startsWith ( obj ) ; } ) ;",
  "inst": "if (! (= argument[\"RegExpMatcher\"] absent)) ... else ..."
}, {
  "algo": "LabelledItem0TopLevelVarDeclaredNames0",
  "cond": "(is-instance-of Statement Statement10)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; var uriReserved = [  \";\" ,  \"/\" ,  \"?\" ,  \":\" ,  \"@\" ,  \"&\" ,  \"=\" ,  \"+\" ,  \"$\" ,  \",\" ] ; l : for ( var indexB1 = 0x00 ; indexB1 <= 0x7F ; indexB1 ++ ) { count ++ ; var hexB1 = decimalToPercentHexString ( indexB1 ) ; var index = indexB1 ; var hex = String . fromCharCode ( index ) ; for ( var indexC = 0 ; indexC < uriReserved . length ; indexC ++ ) { if ( hex === uriReserved [ indexC ] ) continue l ; } if ( hex === \"#\" ) continue ; if ( decodeURI ( hexB1 ) === hex ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (is-instance-of Statement Statement10) ... else ..."
}, {
  "algo": "LabelledItem0TopLevelVarScopedDeclarations0",
  "cond": "(is-instance-of Statement Statement10)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; var uriReserved = [  \";\" ,  \"/\" ,  \"?\" ,  \":\" ,  \"@\" ,  \"&\" ,  \"=\" ,  \"+\" ,  \"$\" ,  \",\" ] ; l : for ( var indexB1 = 0x00 ; indexB1 <= 0x7F ; indexB1 ++ ) { count ++ ; var hexB1 = decimalToPercentHexString ( indexB1 ) ; var index = indexB1 ; var hex = String . fromCharCode ( index ) ; for ( var indexC = 0 ; indexC < uriReserved . length ; indexC ++ ) { if ( hex === uriReserved [ indexC ] ) continue l ; } if ( hex === \"#\" ) continue ; if ( decodeURI ( hexB1 ) === hex ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (is-instance-of Statement Statement10) ... else ..."
}, {
  "algo": "MakeBasicObject",
  "cond": "(contains internalSlotsList \"Extensible\")",
  "covered": true,
  "inst": "if (contains internalSlotsList \"Extensible\") ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "MemberExpression3HasCallInTailPosition0",
  "cond": "(= this call)",
  "covered": true,
  "inst": "if (= this call) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var $MAX_ITERATIONS = 100000 ; ( function  (  ) { var finished = false ; function f ( _  , n  ) { if ( n === 0 ) { finished = true ; return ; } return f `${ n - 1 }` ; } f ( null , $MAX_ITERATIONS ) ; return finished ; } ( ) ) ;"
}, {
  "algo": "ObjectEnvironmentRecordDOTGetBindingValue",
  "cond": "(= value false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= value false) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTGetBindingValue",
  "cond": "(= S false)",
  "covered": false,
  "inst": "if (= S false) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= envRec[\"withEnvironment\"] false)",
  "covered": true,
  "inst": "if (= envRec[\"withEnvironment\"] false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= __x4__ Object)",
  "covered": false,
  "inst": "if (= __x4__ Object) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTHasBinding",
  "cond": "(= blocked true)",
  "covered": false,
  "inst": "if (= blocked true) ... else ..."
}, {
  "algo": "ObjectEnvironmentRecordDOTInitializeBinding",
  "cond": "(! (= envRec[\"SubMap\"][N] absent))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (! (= envRec[\"SubMap\"][N] absent)) ... else ..."
}, {
  "algo": "OrdinaryCallBindThis",
  "cond": "(= thisMode CONST_strict)",
  "covered": true,
  "inst": "if (= thisMode CONST_strict) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "OrdinaryCallBindThis",
  "cond": "(|| (= thisArgument undefined) (= thisArgument null))",
  "covered": false,
  "inst": "if (|| (= thisArgument undefined) (= thisArgument null)) ... else ..."
}, {
  "algo": "OrdinaryFunctionCreate",
  "cond": "(= Strict true)",
  "covered": true,
  "inst": "if (= Strict true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(= __x0__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function ID ( x  ) { return x ; } var value  ; var proto = { m ( name  , v  ) { value = name + ' ' + v ; } } ; var object = { set [ 'a' ] ( v  ) { super . m ( 'a' , v ) ; } , set [ ID ( 'b' ) ] ( v  ) { super . m ( 'b' , v ) ; } , set [ 0 ] ( v  ) { super . m ( '0' , v ) ; } , set [ ID ( 1 ) ] ( v  ) { super . m ( '1' , v ) ; } , } ; Object . setPrototypeOf ( object , proto ) ; object . a = 2 ; assert . sameValue ( value , 'a 2' , \"The value of `value` is `'a 2'`, after executing `object.a = 2;`\" ) ; object . b = 3 ; assert . sameValue ( value , 'b 3' , \"The value of `value` is `'b 3'`, after executing `object.b = 3;`\" ) ; object [ 0 ] = 4 ; assert . sameValue ( value , '0 4' , \"The value of `value` is `'0 4'`, after executing `object[0] = 4;`\" ) ; object [ 1 ] = 5 ; assert . sameValue ( value , '1 5' , \"The value of `value` is `'1 5'`, after executing `object[1] = 5;`\" ) ;",
  "inst": "if (= __x0__ true) ... else ..."
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(= __x3__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function ID ( x  ) { return x ; } var value  ; var proto = { m ( name  , v  ) { value = name + ' ' + v ; } } ; var object = { set [ 'a' ] ( v  ) { super . m ( 'a' , v ) ; } , set [ ID ( 'b' ) ] ( v  ) { super . m ( 'b' , v ) ; } , set [ 0 ] ( v  ) { super . m ( '0' , v ) ; } , set [ ID ( 1 ) ] ( v  ) { super . m ( '1' , v ) ; } , } ; Object . setPrototypeOf ( object , proto ) ; object . a = 2 ; assert . sameValue ( value , 'a 2' , \"The value of `value` is `'a 2'`, after executing `object.a = 2;`\" ) ; object . b = 3 ; assert . sameValue ( value , 'b 3' , \"The value of `value` is `'b 3'`, after executing `object.b = 3;`\" ) ; object [ 0 ] = 4 ; assert . sameValue ( value , '0 4' , \"The value of `value` is `'0 4'`, after executing `object[0] = 4;`\" ) ; object [ 1 ] = 5 ; assert . sameValue ( value , '1 5' , \"The value of `value` is `'1 5'`, after executing `object[1] = 5;`\" ) ;",
  "inst": "if (= __x3__ true) ... else ..."
}, {
  "algo": "OrdinarySetPrototypeOf",
  "cond": "(! (= p[\"GetProtoTypeOf\"] OrdinaryObjectDOTGetPrototypeOf))",
  "covered": true,
  "inst": "if (! (= p[\"GetProtoTypeOf\"] OrdinaryObjectDOTGetPrototypeOf)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function ID ( x  ) { return x ; } var value  ; var proto = { m ( name  , v  ) { value = name + ' ' + v ; } } ; var object = { set [ 'a' ] ( v  ) { super . m ( 'a' , v ) ; } , set [ ID ( 'b' ) ] ( v  ) { super . m ( 'b' , v ) ; } , set [ 0 ] ( v  ) { super . m ( '0' , v ) ; } , set [ ID ( 1 ) ] ( v  ) { super . m ( '1' , v ) ; } , } ; Object . setPrototypeOf ( object , proto ) ; object . a = 2 ; assert . sameValue ( value , 'a 2' , \"The value of `value` is `'a 2'`, after executing `object.a = 2;`\" ) ; object . b = 3 ; assert . sameValue ( value , 'b 3' , \"The value of `value` is `'b 3'`, after executing `object.b = 3;`\" ) ; object [ 0 ] = 4 ; assert . sameValue ( value , '0 4' , \"The value of `value` is `'0 4'`, after executing `object[0] = 4;`\" ) ; object [ 1 ] = 5 ; assert . sameValue ( value , '1 5' , \"The value of `value` is `'1 5'`, after executing `object[1] = 5;`\" ) ;"
}, {
  "algo": "OrdinarySetWithOwnDescriptor",
  "cond": "(= __x9__ true)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= __x9__ true) ... else ..."
}, {
  "algo": "OrdinarySetWithOwnDescriptor",
  "cond": "(= existingDescriptor[\"Writable\"] false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= existingDescriptor[\"Writable\"] false) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "(= F[\"ConstructorKind\"] CONST_derived)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . throws ( ReferenceError , function  (  ) { ( 0 , eval ) ( 'typeof x; const x = null;' ) ; } ) ;",
  "inst": "if (= F[\"ConstructorKind\"] CONST_derived) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "__x17__",
  "covered": true,
  "inst": "if __x17__ ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= strictEval true)",
  "covered": true,
  "inst": "if (= strictEval true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= runningContext null)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;",
  "inst": "if (= runningContext null) ... else ..."
}, {
  "algo": "PerformEval",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] evalContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] evalContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;"
}, {
  "algo": "PerformEval",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "PerformPromiseAll",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } var resolveElementFunction  ; var thenable = { then : function  ( fulfill  ) { resolveElementFunction = fulfill ; } } ; function NotPromise ( executor  ) { executor ( function  (  ) {  } , function  (  ) {  } ) ; } NotPromise . resolve = function  ( v  ) { return v ; } ; Promise . all . call ( NotPromise , [  thenable ] ) ; assert . sameValue ( resolveElementFunction . length , 1 ) ; verifyNotEnumerable ( resolveElementFunction , \"length\" ) ; verifyNotWritable ( resolveElementFunction , \"length\" ) ; verifyConfigurable ( resolveElementFunction , \"length\" ) ;",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseAllSettled",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function checkSequence ( arr  , message  ) { arr . forEach ( function  ( e  , i  ) { if ( e !== ( i + 1 ) ) { $ERROR ( ( message ? message : \"Steps in unexpected sequence:\" ) + \" '\" + arr . join ( ',' ) + \"'\" ) ; } } ) ; return true ; } function checkSettledPromises ( settleds  , expected  , message  ) { const prefix = message ? `${ message }: ` : '' ; assert . sameValue ( Array . isArray ( settleds ) , true , `${ prefix }Settled values is an array` ) ; assert . sameValue ( settleds . length , expected . length , `${ prefix }The settled values has a different length than expected` ) ; settleds . forEach ( ( settled , i ) => { assert . sameValue ( Object . prototype . hasOwnProperty . call ( settled , 'status' ) , true , `${ prefix }The settled value has a property status` ) ; assert . sameValue ( settled . status , expected [ i ] . status , `${ prefix }status for item ${ i }` ) ; if ( settled . status === 'fulfilled' ) { assert . sameValue ( Object . prototype . hasOwnProperty . call ( settled , 'value' ) , true , `${ prefix }The fulfilled promise has a property named value` ) ; assert . sameValue ( Object . prototype . hasOwnProperty . call ( settled , 'reason' ) , false , `${ prefix }The fulfilled promise has no property named reason` ) ; assert . sameValue ( settled . value , expected [ i ] . value , `${ prefix }value for item ${ i }` ) ; } else { assert . sameValue ( settled . status , 'rejected' , `${ prefix }Valid statuses are only fulfilled or rejected` ) ; assert . sameValue ( Object . prototype . hasOwnProperty . call ( settled , 'value' ) , false , `${ prefix }The fulfilled promise has no property named value` ) ; assert . sameValue ( Object . prototype . hasOwnProperty . call ( settled , 'reason' ) , true , `${ prefix }The fulfilled promise has a property named reason` ) ; assert . sameValue ( settled . reason , expected [ i ] . reason , `${ prefix }Reason value for item ${ i }` ) ; } } ) ; } var callCount = 0 ; function Constructor ( executor  ) { function resolve ( values  ) { callCount += 1 ; checkSettledPromises ( values , [  { status : 'fulfilled' , value : 'expectedValue' } ] , 'values' ) ; } executor ( resolve , $ERROR ) ; } Constructor . resolve = function  ( v  ) { return v ; } ; var p1 = { then ( onFulfilled  , onRejected  ) { onFulfilled ( 'expectedValue' ) ; onFulfilled ( 'unexpectedValue' ) ; } } ; assert . sameValue ( callCount , 0 , 'callCount before call to all()' ) ; Promise . allSettled . call ( Constructor , [  p1 ] ) ; assert . sameValue ( callCount , 1 , 'callCount after call to all()' ) ;",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseRace",
  "cond": "(= __x2__ false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var p1 = new Promise ( function  (  ) {  } ) ; var p2 = new Promise ( function  (  ) {  } ) ; var p3 = new Promise ( function  (  ) {  } ) ; var resolve = Promise . resolve ; var callCount = 0 ; var current = p1 ; var next = p2 ; var afterNext = p3 ; Promise . resolve = function  ( nextValue  ) { assert . sameValue ( nextValue , current , '`resolve` invoked with next iterated value' ) ; assert . sameValue ( arguments . length , 1 , '`resolve` invoked with a single argument' ) ; assert . sameValue ( this , Promise , '`this` value set to the constructor' ) ; current = next ; next = afterNext ; afterNext = null ; callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; Promise . race ( [  p1 ,  p2 ,  p3 ] ) ; assert . sameValue ( callCount , 3 , '`resolve` invoked once for each iterated value' ) ;",
  "inst": "if (= __x2__ false) ... else ..."
}, {
  "algo": "PerformPromiseThen",
  "cond": "(= promise[\"PromiseIsHandled\"] false)",
  "covered": true,
  "inst": "if (= promise[\"PromiseIsHandled\"] false) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var p1 = Promise . resolve ( 1 ) ; var p2 = Promise . resolve ( 1 ) ; var p3 = Promise . reject ( 1 ) ; var p4 = Promise . resolve ( 1 ) ; var resolve = Promise . resolve ; var getCount = 0 ; var callCount = 0 ; Object . defineProperty ( Promise , 'resolve' , { configurable : true , get (  ) { getCount += 1 ; return function  (  ) { callCount += 1 ; return resolve . apply ( Promise , arguments ) ; } ; } } ) ; Promise . all ( [  p1 ,  p2 ,  p3 ,  p4 ] ) ; assert . sameValue ( getCount , 1 , 'Got `resolve` only once for each iterated value' ) ; assert . sameValue ( callCount , 4 , '`resolve` invoked once for each iterated value' ) ;"
}, {
  "algo": "PrepareForOrdinaryCall",
  "cond": "(= callerContext null)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= callerContext null) ... else ..."
}, {
  "algo": "PrepareForTailCall",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] leafContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] leafContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function callbackfn ( val  , idx  , obj  ) { if ( idx === 0 ) { return val === 11 ; } if ( idx === 1 ) { return val === 12 ; } return false ; } var obj = { 0 : 11 , 1 : 12 , length : 2 } ; var newArr = Array . prototype . filter . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ; assert . sameValue ( newArr [ 0 ] , 11 , 'newArr[0]' ) ; assert . sameValue ( newArr [ 1 ] , 12 , 'newArr[1]' ) ;"
}, {
  "algo": "PrepareForTailCall",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function callbackfn ( val  , idx  , obj  ) { if ( idx === 0 ) { return val === 11 ; } if ( idx === 1 ) { return val === 12 ; } return false ; } var obj = { 0 : 11 , 1 : 12 , length : 2 } ; var newArr = Array . prototype . filter . call ( obj , callbackfn ) ; assert . sameValue ( newArr . length , 2 , 'newArr.length' ) ; assert . sameValue ( newArr [ 0 ] , 11 , 'newArr[0]' ) ; assert . sameValue ( newArr [ 1 ] , 12 , 'newArr[1]' ) ;",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "PromiseReactionJob",
  "cond": "(= type CONST_Fulfill)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; class FooPromise extends Promise { static get [ Symbol . species ] ( ) { return Promise ; } } var p = Promise . reject ( ) . finally ( ( ) => FooPromise . reject ( ) ) ; assert . sameValue ( p instanceof Promise , true ) ; assert . sameValue ( p instanceof FooPromise , false ) ;",
  "inst": "if (= type CONST_Fulfill) ... else ..."
}, {
  "algo": "PropertyDefinition3Contains0",
  "cond": "(is-instance-of symbol MethodDefinition)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var o  ; eval ( \"o = {set foo(arg){return 1;}};\" ) ; var desc = Object . getOwnPropertyDescriptor ( o , \"foo\" ) ; assert . sameValue ( desc . enumerable , true , 'desc.enumerable' ) ; assert . sameValue ( desc . configurable , true , 'desc.configurable' ) ;",
  "inst": "if (is-instance-of symbol MethodDefinition) ... else ..."
}, {
  "algo": "PutValue",
  "cond": "(! (= __x0__ Reference))",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (! (= __x0__ Reference)) ... else ..."
}, {
  "algo": "PutValue",
  "cond": "(= __x4__ true)",
  "covered": true,
  "inst": "if (= __x4__ true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; assert . throws ( ReferenceError , function  (  ) { b = 11 ; } ) ;"
}, {
  "algo": "RunJobs",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] GLOBAL_context)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] GLOBAL_context) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "RunJobs",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "RunJobs",
  "cond": "__x4__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if __x4__ ... else ..."
}, {
  "algo": "ScriptEvaluation",
  "cond": "(= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] scriptContext)",
  "covered": true,
  "inst": "if (= GLOBAL_executionStack[(- GLOBAL_executionStack[\"length\"] 1i)] scriptContext) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "ScriptEvaluation",
  "cond": "(= GLOBAL_executionStack[\"length\"] 0i)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;",
  "inst": "if (= GLOBAL_executionStack[\"length\"] 0i) ... else ..."
}, {
  "algo": "SetIntegrityLevel",
  "cond": "(= status false)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var errObj = new SyntaxError ( ) ; Object . freeze ( errObj ) ; assert ( Object . isFrozen ( errObj ) , 'Object.isFrozen(errObj) !== true' ) ;",
  "inst": "if (= status false) ... else ..."
}, {
  "algo": "SetIntegrityLevel",
  "cond": "(! (= currentDesc undefined))",
  "covered": true,
  "inst": "if (! (= currentDesc undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; [  'z' ] . forEach ( function  (  ) { Object . freeze ( Array . prototype . forEach ) ; } ) ;"
}, {
  "algo": "SetRealmGlobalObject",
  "cond": "(= globalObj undefined)",
  "covered": true,
  "inst": "if (= globalObj undefined) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "SetRealmGlobalObject",
  "cond": "(= thisValue undefined)",
  "covered": true,
  "inst": "if (= thisValue undefined) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "SpeciesConstructor",
  "cond": "(= C undefined)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var poisonedThen = Object . defineProperty ( new Promise ( function  (  ) {  } ) , 'then' , { get : function  (  ) { throw new Test262Error ( ) ; } } ) ; assert . throws ( Test262Error , function  (  ) { Promise . prototype . finally . call ( poisonedThen ) ; } ) ; assert . throws ( Test262Error , function  (  ) { poisonedThen . finally ( ) ; } ) ;",
  "inst": "if (= C undefined) ... else ..."
}, {
  "algo": "SpeciesConstructor",
  "cond": "(= __x7__ true)",
  "covered": true,
  "inst": "if (= __x7__ true) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var poisonedThen = Object . defineProperty ( new Promise ( function  (  ) {  } ) , 'then' , { get : function  (  ) { throw new Test262Error ( ) ; } } ) ; assert . throws ( Test262Error , function  (  ) { Promise . prototype . finally . call ( poisonedThen ) ; } ) ; assert . throws ( Test262Error , function  (  ) { poisonedThen . finally ( ) ; } ) ;"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(! (< n str[\"length\"]))",
  "covered": true,
  "inst": "if (! (< n str[\"length\"])) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function compareArray ( a  , b  ) { if ( b . length !== a . length ) { return false ; } for ( var i = 0 ; i < a . length ; i ++ ) { if ( ! compareArray . isSameValue ( b [ i ] , a [ i ] ) ) { return false ; } } return true ; } compareArray . isSameValue = function  ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } ; compareArray . format = function  ( array  ) { return `[${ array . map ( String ) . join ( ', ' ) }]` ; } ; assert . compareArray = function  ( actual  , expected  , message  ) { var format = compareArray . format ; assert ( compareArray ( actual , expected ) , `Expected ${ format ( actual ) } and ${ format ( expected ) } to have the same contents. ${ ( message || '' ) }` ) ; } ; var str = new String ( \"abc\" ) ; str [ 5 ] = \"de\" ; var expected = [  \"0\" ,  \"1\" ,  \"2\" ,  \"5\" ,  \"length\" ] ; var actual = Object . getOwnPropertyNames ( str ) ; assert ( compareArray ( actual , expected ) , 'compareArray(actual, expected) !== true' ) ;"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(< j len)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function compareArray ( a  , b  ) { if ( b . length !== a . length ) { return false ; } for ( var i = 0 ; i < a . length ; i ++ ) { if ( ! compareArray . isSameValue ( b [ i ] , a [ i ] ) ) { return false ; } } return true ; } compareArray . isSameValue = function  ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } ; compareArray . format = function  ( array  ) { return `[${ array . map ( String ) . join ( ', ' ) }]` ; } ; assert . compareArray = function  ( actual  , expected  , message  ) { var format = compareArray . format ; assert ( compareArray ( actual , expected ) , `Expected ${ format ( actual ) } and ${ format ( expected ) } to have the same contents. ${ ( message || '' ) }` ) ; } ; var str = new String ( \"abc\" ) ; str [ 5 ] = \"de\" ; var expected = [  \"0\" ,  \"1\" ,  \"2\" ,  \"5\" ,  \"length\" ] ; var actual = Object . getOwnPropertyNames ( str ) ; assert ( compareArray ( actual , expected ) , 'compareArray(actual, expected) !== true' ) ;",
  "inst": "while (< j len) { ... }"
}, {
  "algo": "StringExoticObjectDOTOwnPropertyKeys",
  "cond": "(< arrayIndexKeys[j] arrayIndexKeys[min])",
  "covered": false,
  "inst": "if (< arrayIndexKeys[j] arrayIndexKeys[min]) ... else ..."
}, {
  "algo": "StringGetOwnProperty",
  "cond": "(= index -0.0)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= index -0.0) ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "(= symbol \"super\")",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var superProp = null ; var o = { test262 : null , method (  ) { superProp = eval ( 'super.test262;' ) ; } } ; o . method ( ) ; assert . sameValue ( superProp , undefined ) ; Object . setPrototypeOf ( o , { test262 : 262 } ) ; o . method ( ) ; assert . sameValue ( superProp , 262 ) ;",
  "inst": "if (= symbol \"super\") ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "(is-instance-of symbol ReservedWord)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var superProp = null ; var o = { test262 : null , method (  ) { superProp = eval ( 'super.test262;' ) ; } } ; o . method ( ) ; assert . sameValue ( superProp , undefined ) ; Object . setPrototypeOf ( o , { test262 : 262 } ) ; o . method ( ) ; assert . sameValue ( superProp , 262 ) ;",
  "inst": "if (is-instance-of symbol ReservedWord) ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var superProp = null ; var o = { test262 : null , method (  ) { superProp = eval ( 'super.test262;' ) ; } } ; o . method ( ) ; assert . sameValue ( superProp , undefined ) ; Object . setPrototypeOf ( o , { test262 : 262 } ) ; o . method ( ) ; assert . sameValue ( superProp , 262 ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "SuperProperty1Contains0",
  "cond": "__x0__",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var superProp = null ; var o = { test262 : null , method (  ) { superProp = eval ( 'super.test262;' ) ; } } ; o . method ( ) ; assert . sameValue ( superProp , undefined ) ; Object . setPrototypeOf ( o , { test262 : 262 } ) ; o . method ( ) ; assert . sameValue ( superProp , 262 ) ;",
  "inst": "if __x0__ ... else ..."
}, {
  "algo": "TestIntegrityLevel",
  "cond": "(! (= currentDesc undefined))",
  "covered": true,
  "inst": "if (! (= currentDesc undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var obj = { } ; Object . defineProperty ( obj , \"foo\" , { value : 12 , writable : true , configurable : false } ) ; Object . preventExtensions ( obj ) ; assert . sameValue ( Object . isFrozen ( obj ) , false , 'Object.isFrozen(obj)' ) ;"
}, {
  "algo": "ToInteger",
  "cond": "(= integer -0.0)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var testResult = false ; var initialValue = 0 ; function callbackfn ( prevVal  , curVal  , idx  , obj  ) { if ( idx === 1 ) { testResult = ( curVal === undefined ) ; } } var arr = [  0 , , 2 ] ; Object . defineProperty ( arr , \"1\" , { set : function  (  ) {  } , configurable : true } ) ; arr . reduce ( callbackfn , initialValue ) ; assert ( testResult , 'testResult !== true' ) ;",
  "inst": "if (= integer -0.0) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"HasProperty\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"HasProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"DefineOwnProperty\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"DefineOwnProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Set\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"Set\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"SetPrototypeOf\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"SetPrototypeOf\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Get\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"Get\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"PreventExtensions\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"PreventExtensions\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"Delete\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"Delete\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"GetOwnProperty\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"GetOwnProperty\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"OwnPropertyKeys\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"OwnPropertyKeys\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"GetPrototypeOf\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"GetPrototypeOf\"] absent) ... else ..."
}, {
  "algo": "ToObject",
  "cond": "(= obj[\"IsExtensible\"] absent)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function decimalToHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; n >>>= 0 ; var s = \"\" ; while ( n ) { s = hex [ n & 0xf ] + s ; n >>>= 4 ; } while ( s . length < 4 ) { s = \"0\" + s ; } return s ; } function decimalToPercentHexString ( n  ) { var hex = \"0123456789ABCDEF\" ; return \"%\" + hex [ ( n >> 4 ) & 0xf ] + hex [ n & 0xf ] ; } var errorCount = 0 ; var count = 0 ; var indexP  ; var indexO = 0 ; for ( var indexB1 = 0xE0 ; indexB1 <= 0xEF ; indexB1 ++ ) { var hexB1 = decimalToPercentHexString ( indexB1 ) ; for ( var indexB2 = 0x80 ; indexB2 <= 0xBF ; indexB2 ++ ) { if ( ( indexB1 === 0xE0 ) && ( indexB2 <= 0x9F ) ) continue ; if ( ( indexB1 === 0xED ) && ( 0xA0 <= indexB2 ) ) continue ; var hexB1_B2 = hexB1 + decimalToPercentHexString ( indexB2 ) ; for ( var indexB3 = 0x80 ; indexB3 <= 0xBF ; indexB3 ++ ) { count ++ ; var hexB1_B2_B3 = hexB1_B2 + decimalToPercentHexString ( indexB3 ) ; var index = ( indexB1 & 0x0F ) * 0x1000 + ( indexB2 & 0x3F ) * 0x40 + ( indexB3 & 0x3F ) ; if ( decodeURI ( hexB1_B2_B3 ) === String . fromCharCode ( index ) ) continue ; if ( indexO === 0 ) { indexO = index ; } else { if ( ( index - indexP ) !== 1 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } indexO = index ; } } indexP = index ; errorCount ++ ; } } } if ( errorCount > 0 ) { if ( ( indexP - indexO ) !== 0 ) { var hexP = decimalToHexString ( indexP ) ; var hexO = decimalToHexString ( indexO ) ; $ERROR ( '#' + hexO + '-' + hexP + ' ' ) ; } else { var hexP = decimalToHexString ( indexP ) ; $ERROR ( '#' + hexP + ' ' ) ; } $ERROR ( 'Total error: ' + errorCount + ' bad Unicode character in ' + count + ' ' ) ; }",
  "inst": "if (= obj[\"IsExtensible\"] absent) ... else ..."
}, {
  "algo": "TryStatement1VarDeclaredNames0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var c1 = 0 , fin = 0 ; for ( var i = 0 ; i < 5 ; i ++ ) { try { c1 += 1 ; break ; } catch ( er1 ) {  } finally { fin = 1 ; } fin = - 1 ; c1 += 2 ; } ; if ( fin !== 1 ) { $ERROR ( '#1.1: \"finally\" block must be evaluated' ) ; } if ( c1 !== 1 ) { $ERROR ( '#1.2: \"try{break}catch finally\" must work correctly' ) ; } var c2 = 0 , fin2 = 0 ; for ( var i = 0 ; i < 5 ; i ++ ) { try { throw \"ex1\" ; } catch ( er1 ) { c2 += 1 ; break ; } finally { fin2 = 1 ; } c2 += 2 ; fin2 = - 1 ; } ; if ( fin2 !== 1 ) { $ERROR ( '#2.1: \"finally\" block must be evaluated' ) ; } if ( c2 !== 1 ) { $ERROR ( '#2.2: \"try catch{break} finally\" must work correctly' ) ; } var c3 = 0 , fin3 = 0 ; for ( var i = 0 ; i < 5 ; i ++ ) { try { throw \"ex1\" ; } catch ( er1 ) { c3 += 1 ; } finally { fin3 = 1 ; break ; } c3 += 2 ; fin3 = 0 ; } ; if ( fin3 !== 1 ) { $ERROR ( '#3.1: \"finally\" block must be evaluated' ) ; } if ( c3 !== 1 ) { $ERROR ( '#3.2: \"try catch finally{break}\" must work correctly' ) ; } var c4 = 0 , fin4 = 0 ; for ( var i = 0 ; i < 5 ; i ++ ) { try { c4 += 1 ; break ; } finally { fin4 = 1 ; } fin4 = - 1 ; c4 += 2 ; } ; if ( fin4 !== 1 ) { $ERROR ( '#4.1: \"finally\" block must be evaluated' ) ; } if ( c4 !== 1 ) { $ERROR ( '#4.2: \"try{break} finally\" must work correctly' ) ; } for ( var i = 0 ; i < 5 ; i ++ ) { try { throw \"ex1\" ; } catch ( er1 ) { break ; } } ; if ( i !== 0 ) { $ERROR ( '#5: \"try catch{break}\" must work correctly' ) ; } var c6 = 0 ; for ( var c6 = 0 ; c6 < 5 ;  ) { try { c6 += 1 ; break ; } catch ( er1 ) {  } c6 += 2 ; } ; if ( c6 !== 1 ) { $ERROR ( '#6: \"try{break} catch\" must work correctly' ) ; } var c7 = 0 , fin7 = 0 ; try { for ( var c7 = 0 ; c7 < 5 ;  ) { try { c7 += 1 ; throw \"ex1\" ; } finally { fin7 = 1 ; break ; } fin7 = - 1 ; c7 += 2 ; } } catch ( ex1 ) { c7 = 10 ; } if ( fin7 !== 1 ) { $ERROR ( '#7.1: \"finally\" block must be evaluated' ) ; } if ( c7 !== 1 ) { $ERROR ( '#7.2: \"try finally{break}\" must work correctly' ) ; }",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement1VarScopedDeclarations0",
  "cond": "(< __x3__ __x2__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var c1 = 0 , fin = 0 ; for ( var i = 0 ; i < 5 ; i ++ ) { try { c1 += 1 ; break ; } catch ( er1 ) {  } finally { fin = 1 ; } fin = - 1 ; c1 += 2 ; } ; if ( fin !== 1 ) { $ERROR ( '#1.1: \"finally\" block must be evaluated' ) ; } if ( c1 !== 1 ) { $ERROR ( '#1.2: \"try{break}catch finally\" must work correctly' ) ; } var c2 = 0 , fin2 = 0 ; for ( var i = 0 ; i < 5 ; i ++ ) { try { throw \"ex1\" ; } catch ( er1 ) { c2 += 1 ; break ; } finally { fin2 = 1 ; } c2 += 2 ; fin2 = - 1 ; } ; if ( fin2 !== 1 ) { $ERROR ( '#2.1: \"finally\" block must be evaluated' ) ; } if ( c2 !== 1 ) { $ERROR ( '#2.2: \"try catch{break} finally\" must work correctly' ) ; } var c3 = 0 , fin3 = 0 ; for ( var i = 0 ; i < 5 ; i ++ ) { try { throw \"ex1\" ; } catch ( er1 ) { c3 += 1 ; } finally { fin3 = 1 ; break ; } c3 += 2 ; fin3 = 0 ; } ; if ( fin3 !== 1 ) { $ERROR ( '#3.1: \"finally\" block must be evaluated' ) ; } if ( c3 !== 1 ) { $ERROR ( '#3.2: \"try catch finally{break}\" must work correctly' ) ; } var c4 = 0 , fin4 = 0 ; for ( var i = 0 ; i < 5 ; i ++ ) { try { c4 += 1 ; break ; } finally { fin4 = 1 ; } fin4 = - 1 ; c4 += 2 ; } ; if ( fin4 !== 1 ) { $ERROR ( '#4.1: \"finally\" block must be evaluated' ) ; } if ( c4 !== 1 ) { $ERROR ( '#4.2: \"try{break} finally\" must work correctly' ) ; } for ( var i = 0 ; i < 5 ; i ++ ) { try { throw \"ex1\" ; } catch ( er1 ) { break ; } } ; if ( i !== 0 ) { $ERROR ( '#5: \"try catch{break}\" must work correctly' ) ; } var c6 = 0 ; for ( var c6 = 0 ; c6 < 5 ;  ) { try { c6 += 1 ; break ; } catch ( er1 ) {  } c6 += 2 ; } ; if ( c6 !== 1 ) { $ERROR ( '#6: \"try{break} catch\" must work correctly' ) ; } var c7 = 0 , fin7 = 0 ; try { for ( var c7 = 0 ; c7 < 5 ;  ) { try { c7 += 1 ; throw \"ex1\" ; } finally { fin7 = 1 ; break ; } fin7 = - 1 ; c7 += 2 ; } } catch ( ex1 ) { c7 = 10 ; } if ( fin7 !== 1 ) { $ERROR ( '#7.1: \"finally\" block must be evaluated' ) ; } if ( c7 !== 1 ) { $ERROR ( '#7.2: \"try finally{break}\" must work correctly' ) ; }",
  "inst": "while (< __x3__ __x2__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement2VarDeclaredNames0",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var $MAX_ITERATIONS = 100000 ; var callCount = 0 ; ( function f ( n  ) { if ( n === 0 ) { callCount += 1 ; return ; } try {  } catch ( err ) {  } finally { return f ( n - 1 ) ; } } ( $MAX_ITERATIONS ) ) ; assert . sameValue ( callCount , 1 ) ;",
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "TryStatement2VarScopedDeclarations0",
  "cond": "(< __x7__ __x6__[\"length\"])",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var $MAX_ITERATIONS = 100000 ; var callCount = 0 ; ( function f ( n  ) { if ( n === 0 ) { callCount += 1 ; return ; } try {  } catch ( err ) {  } finally { return f ( n - 1 ) ; } } ( $MAX_ITERATIONS ) ) ; assert . sameValue ( callCount , 1 ) ;",
  "inst": "while (< __x7__ __x6__[\"length\"]) { ... }"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var x = 0 ; var callCount = 0 ; function * f ( x = y , y  ) { callCount = callCount + 1 ; } assert . throws ( ReferenceError , function  (  ) { f ( ) ; } ) ; assert . sameValue ( callCount , 0 , 'generator function body not evaluated' ) ;"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function verifyProperty ( obj  , name  , desc  , options  ) { assert ( arguments . length > 2 , 'verifyProperty should receive at least 3 arguments: obj, name, and descriptor' ) ; var originalDesc = Object . getOwnPropertyDescriptor ( obj , name ) ; var nameStr = String ( name ) ; if ( desc === undefined ) { assert . sameValue ( originalDesc , undefined , \"obj['\" + nameStr + \"'] descriptor should be undefined\" ) ; return true ; } assert ( Object . prototype . hasOwnProperty . call ( obj , name ) , \"obj should have an own property \" + nameStr ) ; assert . notSameValue ( desc , null , \"The desc argument should be an object or undefined, null\" ) ; assert . sameValue ( typeof desc , \"object\" , \"The desc argument should be an object or undefined, \" + String ( desc ) ) ; var failures = [  ] ; if ( Object . prototype . hasOwnProperty . call ( desc , 'value' ) ) { if ( ! isSameValue ( desc . value , originalDesc . value ) ) { failures . push ( \"descriptor value should be \" + desc . value ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'enumerable' ) ) { if ( desc . enumerable !== originalDesc . enumerable || desc . enumerable !== isEnumerable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . enumerable ? '' : 'not ' ) + 'be enumerable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'writable' ) ) { if ( desc . writable !== originalDesc . writable || desc . writable !== isWritable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . writable ? '' : 'not ' ) + 'be writable' ) ; } } if ( Object . prototype . hasOwnProperty . call ( desc , 'configurable' ) ) { if ( desc . configurable !== originalDesc . configurable || desc . configurable !== isConfigurable ( obj , name ) ) { failures . push ( 'descriptor should ' + ( desc . configurable ? '' : 'not ' ) + 'be configurable' ) ; } } assert ( ! failures . length , failures . join ( '; ' ) ) ; if ( options && options . restore ) { Object . defineProperty ( obj , name , originalDesc ) ; } return true ; } function isConfigurable ( obj  , name  ) { var hasOwnProperty = Object . prototype . hasOwnProperty ; try { delete obj [ name ] ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } return ! hasOwnProperty . call ( obj , name ) ; } function isEnumerable ( obj  , name  ) { var stringCheck = false ; if ( typeof name === \"string\" ) { for ( var x in obj ) { if ( x === name ) { stringCheck = true ; break ; } } } else { stringCheck = true ; } return stringCheck && Object . prototype . hasOwnProperty . call ( obj , name ) && Object . prototype . propertyIsEnumerable . call ( obj , name ) ; } function isSameValue ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } var __isArray = Array . isArray ; function isWritable ( obj  , name  , verifyProp  , value  ) { var unlikelyValue = __isArray ( obj ) && name === \"length\" ? Math . pow ( 2 , 32 ) - 1 : \"unlikelyValue\" ; var newValue = value || unlikelyValue ; var hadValue = Object . prototype . hasOwnProperty . call ( obj , name ) ; var oldValue = obj [ name ] ; var writeSucceeded  ; try { obj [ name ] = newValue ; } catch ( e ) { if ( ! ( e instanceof TypeError ) ) { $ERROR ( \"Expected TypeError, got \" + e ) ; } } writeSucceeded = isSameValue ( obj [ verifyProp || name ] , newValue ) ; if ( writeSucceeded ) { if ( hadValue ) { obj [ name ] = oldValue ; } else { delete obj [ name ] ; } } return writeSucceeded ; } function verifyEqualTo ( obj  , name  , value  ) { if ( ! isSameValue ( obj [ name ] , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to equal \" + value + \", actually \" + obj [ name ] ) ; } } function verifyWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:true.\" ) ; } if ( ! isWritable ( obj , name , verifyProp , value ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be writable, but was not.\" ) ; } } function verifyNotWritable ( obj  , name  , verifyProp  , value  ) { if ( ! verifyProp ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . writable , \"Expected obj[\" + String ( name ) + \"] to have writable:false.\" ) ; } if ( isWritable ( obj , name , verifyProp ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be writable, but was.\" ) ; } } function verifyEnumerable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:true.\" ) ; if ( ! isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be enumerable, but was not.\" ) ; } } function verifyNotEnumerable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . enumerable , \"Expected obj[\" + String ( name ) + \"] to have enumerable:false.\" ) ; if ( isEnumerable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be enumerable, but was.\" ) ; } } function verifyConfigurable ( obj  , name  ) { assert ( Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:true.\" ) ; if ( ! isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] to be configurable, but was not.\" ) ; } } function verifyNotConfigurable ( obj  , name  ) { assert ( ! Object . getOwnPropertyDescriptor ( obj , name ) . configurable , \"Expected obj[\" + String ( name ) + \"] to have configurable:false.\" ) ; if ( isConfigurable ( obj , name ) ) { $ERROR ( \"Expected obj[\" + String ( name ) + \"] NOT to be configurable, but was.\" ) ; } } ( function  (  ) { function getFunc1 (  ) { return 10 ; } Object . defineProperty ( arguments , \"0\" , { get : getFunc1 , enumerable : true , configurable : true } ) ; function getFunc2 (  ) { return 20 ; } Object . defineProperty ( arguments , \"0\" , { get : getFunc2 , enumerable : false , configurable : false } ) ; verifyEqualTo ( arguments , \"0\" , getFunc2 ( ) ) ; verifyNotEnumerable ( arguments , \"0\" ) ; verifyNotConfigurable ( arguments , \"0\" ) ; } ( 0 , 1 , 2 ) ) ;"
}, {
  "algo": "ValidateAndApplyPropertyDescriptor",
  "cond": "(! (= O undefined))",
  "covered": true,
  "inst": "if (! (= O undefined)) ... else ...",
  "thenCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function compareArray ( a  , b  ) { if ( b . length !== a . length ) { return false ; } for ( var i = 0 ; i < a . length ; i ++ ) { if ( ! compareArray . isSameValue ( b [ i ] , a [ i ] ) ) { return false ; } } return true ; } compareArray . isSameValue = function  ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } ; compareArray . format = function  ( array  ) { return `[${ array . map ( String ) . join ( ', ' ) }]` ; } ; assert . compareArray = function  ( actual  , expected  , message  ) { var format = compareArray . format ; assert ( compareArray ( actual , expected ) , `Expected ${ format ( actual ) } and ${ format ( expected ) } to have the same contents. ${ ( message || '' ) }` ) ; } ; var obj = { } ; Object . defineProperty ( obj , \"a\" , { get : function  (  ) {  } , set : function  ( _value  ) {  } , enumerable : true , configurable : true , } ) ; obj . b = 2 ; Object . defineProperty ( obj , \"a\" , { value : 1 } ) ; assert . compareArray ( Object . keys ( obj ) , [  \"a\" ,  \"b\" ] ) ; var fn = ( ) => {  } ; fn . a = 1 ; Object . defineProperty ( fn , \"length\" , { enumerable : true } ) ; assert . compareArray ( Object . keys ( fn ) , [  \"length\" ,  \"a\" ] ) ;"
}, {
  "algo": "YieldExpression0Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function compareArray ( a  , b  ) { if ( b . length !== a . length ) { return false ; } for ( var i = 0 ; i < a . length ; i ++ ) { if ( ! compareArray . isSameValue ( b [ i ] , a [ i ] ) ) { return false ; } } return true ; } compareArray . isSameValue = function  ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } ; compareArray . format = function  ( array  ) { return `[${ array . map ( String ) . join ( ', ' ) }]` ; } ; assert . compareArray = function  ( actual  , expected  , message  ) { var format = compareArray . format ; assert ( compareArray ( actual , expected ) , `Expected ${ format ( actual ) } and ${ format ( expected ) } to have the same contents. ${ ( message || '' ) }` ) ; } ; var arr = [  'a' ,  'b' ,  'c' ] ; var item  ; var callCount = 0 ; var gen = function *  (  ) { callCount += 1 ; yield [  ... yield yield ] ; } ; var iter = gen ( ) ; iter . next ( false ) ; item = iter . next ( [  'a' ,  'b' ,  'c' ] ) ; item = iter . next ( item . value ) ; assert ( compareArray ( item . value , arr ) ) ; assert . sameValue ( item . done , false ) ; assert . sameValue ( callCount , 1 ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression1Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; function compareArray ( a  , b  ) { if ( b . length !== a . length ) { return false ; } for ( var i = 0 ; i < a . length ; i ++ ) { if ( ! compareArray . isSameValue ( b [ i ] , a [ i ] ) ) { return false ; } } return true ; } compareArray . isSameValue = function  ( a  , b  ) { if ( a === 0 && b === 0 ) return 1 / a === 1 / b ; if ( a !== a && b !== b ) return true ; return a === b ; } ; compareArray . format = function  ( array  ) { return `[${ array . map ( String ) . join ( ', ' ) }]` ; } ; assert . compareArray = function  ( actual  , expected  , message  ) { var format = compareArray . format ; assert ( compareArray ( actual , expected ) , `Expected ${ format ( actual ) } and ${ format ( expected ) } to have the same contents. ${ ( message || '' ) }` ) ; } ; var arr = [  'a' ,  'b' ,  'c' ] ; var item  ; var callCount = 0 ; var gen = function *  (  ) { callCount += 1 ; yield [  ... yield yield ] ; } ; var iter = gen ( ) ; iter . next ( false ) ; item = iter . next ( [  'a' ,  'b' ,  'c' ] ) ; item = iter . next ( item . value ) ; assert ( compareArray ( item . value , arr ) ) ; assert . sameValue ( item . done , false ) ; assert . sameValue ( callCount , 1 ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var quickIter = { } ; var exprValue  , nextReceived  , done  , iter  ; quickIter [ Symbol . iterator ] = function  (  ) { return { next : function  ( x  ) { nextReceived = x ; return { done : done , value : 3333 } ; } } ; } ; function * g (  ) { exprValue = yield * quickIter ; } done = true ; iter = g ( ) ; iter . next ( 4444 ) ; assert . sameValue ( nextReceived , undefined , 'received value (previously-exhausted iterator)' ) ; assert . sameValue ( exprValue , 3333 , 'expression value (previously-exhausted iterator)' ) ; done = false ; exprValue = null ; iter = g ( ) ; iter . next ( 2222 ) ; done = true ; iter . next ( 5555 ) ; assert . sameValue ( nextReceived , 5555 , 'received value' ) ; assert . sameValue ( exprValue , 3333 , 'expression value' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var badIter = { } ; var callCount = 0 ; var spyValue = Object . defineProperty ( { done : false } , 'value' , { get : function  (  ) { callCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , throw : function  (  ) { return spyValue ; } } ; } ; var delegationComplete = false ; function * g (  ) { yield * badIter ; delegationComplete = true ; } var iter = g ( ) ; iter . next ( ) ; assert . sameValue ( callCount , 0 , 'access count (first iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (first iteration)' ) ; iter . throw ( ) ; assert . sameValue ( callCount , 0 , 'access count (second iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (second iteration)' ) ; spyValue . done = true ; iter . throw ( ) ; assert . sameValue ( callCount , 1 , 'access count (final iteration)' ) ; assert . sameValue ( delegationComplete , true , 'delegation complete' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var badIter = { } ; var callCount = 0 ; var spyValue = Object . defineProperty ( { done : false } , 'value' , { get : function  (  ) { callCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , throw : function  (  ) { return spyValue ; } } ; } ; var delegationComplete = false ; function * g (  ) { yield * badIter ; delegationComplete = true ; } var iter = g ( ) ; iter . next ( ) ; assert . sameValue ( callCount , 0 , 'access count (first iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (first iteration)' ) ; iter . throw ( ) ; assert . sameValue ( callCount , 0 , 'access count (second iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (second iteration)' ) ; spyValue . done = true ; iter . throw ( ) ; assert . sameValue ( callCount , 1 , 'access count (final iteration)' ) ; assert . sameValue ( delegationComplete , true , 'delegation complete' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var badIter = { } ; var throwCount = 0 ; var returnCount = 0 ; var spyResult = { next : function  (  ) { return { done : false } ; } } ; Object . defineProperty ( spyResult , 'throw' , { get : function  (  ) { throwCount += 1 ; } } ) ; Object . defineProperty ( spyResult , 'return' , { get : function  (  ) { returnCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return spyResult ; } ; function * g (  ) { try { yield * badIter ; } catch ( err ) { caught = err ; } } var iter = g ( ) ; var caught  ; iter . next ( ) ; iter . throw ( ) ; assert . sameValue ( throwCount , 1 , '`throw` property access' ) ; assert . sameValue ( returnCount , 1 , '`return` property access' ) ; assert . sameValue ( typeof caught , 'object' ) ; assert . sameValue ( caught . constructor , TypeError ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var badIter = { } ; var throwCount = 0 ; var returnCount = 0 ; var hitNextStatement = false ; var hitCatch = false ; var hitFinally = false ; var spyResult = { next : function  (  ) { return { done : false } ; } } ; Object . defineProperty ( spyResult , 'throw' , { get : function  (  ) { throwCount += 1 ; } } ) ; Object . defineProperty ( spyResult , 'return' , { get : function  (  ) { returnCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return spyResult ; } ; function * g (  ) { try { yield * badIter ; hitNextStatement = true ; } catch ( _ ) { hitCatch = true ; } finally { hitFinally = true ; } } var iter = g ( ) ; iter . next ( ) ; iter . return ( ) ; assert . sameValue ( throwCount , 0 , '`throw` property access' ) ; assert . sameValue ( returnCount , 1 , '`return` property access' ) ; assert . sameValue ( hitFinally , true , 'Generator execution was resumed' ) ; assert . sameValue ( hitNextStatement , false , 'Abrupt completion interrupted control flow' ) ; assert . sameValue ( hitCatch , false , 'Abrupt completion not interpreted as \"throw\"' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var thrown = new Test262Error ( ) ; var badIter = { } ; var poisonedValue = Object . defineProperty ( { done : true } , 'value' , { get : function  (  ) { throw thrown ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , return : function  (  ) { return poisonedValue ; } } ; } ; function * g (  ) { try { yield * badIter ; } catch ( err ) { caught = err ; } } var iter = g ( ) ; var caught  ; iter . next ( ) ; iter . return ( ) ; assert . sameValue ( caught , thrown ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}, {
  "algo": "YieldExpression2Evaluation0",
  "cond": "(= generatorKind CONST_async)",
  "covered": true,
  "elseCovered": "function Test262Error ( message  ) { this . message = message || \"\" ; } Test262Error . prototype . toString = function  (  ) { return \"Test262Error: \" + this . message ; } ; var $ERROR  ; $ERROR = function $ERROR ( message  ) { throw new Test262Error ( message ) ; } ; function $DONOTEVALUATE (  ) { throw \"Test262: This statement should not be evaluated.\" ; } function assert ( mustBeTrue  , message  ) { if ( mustBeTrue === true ) { return ; } if ( message === undefined ) { message = 'Expected true but got ' + assert . _toString ( mustBeTrue ) ; } $ERROR ( message ) ; } assert . _isSameValue = function  ( a  , b  ) { if ( a === b ) { return a !== 0 || 1 / a === 1 / b ; } return a !== a && b !== b ; } ; assert . sameValue = function  ( actual  , expected  , message  ) { try { if ( assert . _isSameValue ( actual , expected ) ) { return ; } } catch ( error ) { $ERROR ( message + ' (_isSameValue operation threw) ' + error ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( expected ) + '») to be true' ; $ERROR ( message ) ; } ; assert . notSameValue = function  ( actual  , unexpected  , message  ) { if ( ! assert . _isSameValue ( actual , unexpected ) ) { return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } message += 'Expected SameValue(«' + assert . _toString ( actual ) + '», «' + assert . _toString ( unexpected ) + '») to be false' ; $ERROR ( message ) ; } ; assert . throws = function  ( expectedErrorConstructor  , func  , message  ) { if ( typeof func !== \"function\" ) { $ERROR ( 'assert.throws requires two arguments: the error constructor ' + 'and a function to run' ) ; return ; } if ( message === undefined ) { message = '' ; } else { message += ' ' ; } try { func ( ) ; } catch ( thrown ) { if ( typeof thrown !== 'object' || thrown === null ) { message += 'Thrown value was not an object!' ; $ERROR ( message ) ; } else if ( thrown . constructor !== expectedErrorConstructor ) { message += 'Expected a ' + expectedErrorConstructor . name + ' but got a ' + thrown . constructor . name ; $ERROR ( message ) ; } return ; } message += 'Expected a ' + expectedErrorConstructor . name + ' to be thrown but no exception was thrown at all' ; $ERROR ( message ) ; } ; assert . _toString = function  ( value  ) { try { if ( value === 0 && 1 / value === - Infinity ) { return '-0' ; } return String ( value ) ; } catch ( err ) { if ( err . name === 'TypeError' ) { return Object . prototype . toString . call ( value ) ; } throw err ; } } ; var badIter = { } ; var callCount = 0 ; var spyValue = Object . defineProperty ( { done : false } , 'value' , { get : function  (  ) { callCount += 1 ; } } ) ; badIter [ Symbol . iterator ] = function  (  ) { return { next : function  (  ) { return { done : false } ; } , return : function  (  ) { return spyValue ; } } ; } ; var normalCompletion = false ; var errorCompletion = false ; var delegationComplete = false ; function * g (  ) { try { yield * badIter ; normalCompletion = true ; } catch ( _ ) { errorCompletion = true ; } finally { delegationComplete = true ; } } var iter = g ( ) ; iter . next ( ) ; assert . sameValue ( callCount , 0 , 'access count (first iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (first iteration)' ) ; iter . return ( ) ; assert . sameValue ( callCount , 0 , 'access count (second iteration)' ) ; assert . sameValue ( delegationComplete , false , 'delegation ongoing (second iteration)' ) ; spyValue . done = true ; iter . return ( ) ; assert . sameValue ( callCount , 1 , 'access count (final iteration)' ) ; assert . sameValue ( delegationComplete , true , 'delegation complete' ) ; assert . sameValue ( normalCompletion , false , 'completion was abrupt' ) ; assert . sameValue ( errorCompletion , false , 'completion was not of type \"throw\"' ) ;",
  "inst": "if (= generatorKind CONST_async) ... else ..."
}]