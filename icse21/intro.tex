\section{Introduction}\label{sec:intro}

In Peter O'Hearn's keynote speech in ICSE 2020, he quoted the following from
Mark Zuckerberg's Letter to Investors~\cite{mzletter}:
\begin{quote}
  The Hacker Way is an approach to building that involves continuous improvement
  and iteration.  Hackers believe that somethings can always be better, and that
  nothing is ever complete.
\end{quote}
Indeed, modern programming follows the continuous integration (CI) and
continuous deployment (CD) approach~\cite{cicd} rather than the traditional waterfall model.
Instead of a sequential model that divides software development into
several phases, each of which takes time, CI/CD amounts to a cycle of
quick software development, deployment, and back to development with
feedback. Even the development of programming languages uses the CI/CD approach.

Consider JavaScript, which is one of the most widely used programming languages
not only for client-side but also for server-side programming~\cite{nodejs} and
even for embedded systems~\cite{moddable,espruino,tessel2}.  Various JavaScript
engines provide diverse extensions to adapt to fast-changing user demands.  At
the same time, ECMAScript, the official specification that describes the syntax and
semantics of JavaScript, is annually updated since ECMAScript 6 (ES6,
2015)~\cite{es6} to support new language features in response to user demands.
Such updates in both the specification and implementations in tandem make it
difficult for them to be in sync.

Another example is Solidity~\cite{officialSolDoc}, the standard smart contract programming language
for the Ethereum blockchain.  The Solidity language specification is continuously
updated, and the Solidity compiler is also frequently released.  According to
Hwang and Ryu~\cite{solidity-gap}, the average number of days between consecutive
releases from Solidity 0.1.2 to 0.5.7 is 27.  In most cases, the Solidity compiler reflects
updates in the specification, but even the specification is revised
according to the semantics implemented in the compiler.  As in JavaScript,
bidirectional effects in the specification and the implementation make
it hard to guarantee their correspondence.

The conventional approach to build a programming language is uni-directional from
a language specification to its implementation.  The specification is believed to
be correct and the conformance of an implementation to the specification is
checked by dynamic testing.  Unlike in the conventional approach, in the modern CI/CD
approach, the specification may not be the Oracle, because both the
specification and the implementation can co-evolve.  In this setting, both the
specification and the implementation may contain bugs, and guaranteeing their
correctness is a challenging task.

In this paper, we propose a novel \textit{$N$+1-differential testing},
which enables testing of co-evolving specifications and their implementations.
differential testing~\cite{nversion} is a testing technique, which
executes $N$ implementations of a specification concurrently for each
input, and detects a problem when the outputs are in disagreement.
In addition to $N$ implementations, our approach tests the
specification as well.  The $N$+1-differential testing
consists of three steps: 1) to automatically synthesize
programs guided by the syntax and semantics from a given language
specification, 2) to generate conformance tests by injecting
assertions to the synthesized programs
to check their final program states, and 3) to find and localize bugs in
the specification and implementations via executing the conformance tests on multiple implementations.

Given a language specification and $N$ existing real-world
implementations of the specification, we
automatically generate a conformance test suite from the specification with
assertions in each test code to make sure that the result of running the code
conforms to the specification semantics.  Then, we run the test suite for $N$
implementations of the specification.  Because generated tests strictly comply
with the specification, they reflect specification errors as well, if any.  When
one of the implementations fails in running a test, it is highly likely that the
implementation has a bug, which is the traditional differential testing.  When
most of the implementations fail in running a test, it is highly likely that
the specification has a bug.  By automatically generating a rich set of test
code from the specification and running them with implementations of the
specification, we can find and localize bugs either in the specification written
in a natural language or in its implementations.

To show the practicality of the proposed approach, we present $\tool$, which
performs $N$+1-differential testing for modern JavaScript engines and ECMAScript.
We implement $\tool$ by extending $\jiset$~\cite{jiset}, which is a JavaScript
IR-based semantics extraction toolchain, to utilize syntax and semantics
automatically extracted from a given ECMAScript.  Using the extracted syntax,
our tool automatically synthesizes initial seed programs and expands the program
pool by mutating specific target programs guided by semantics coverage.  Then,
the tool generates conformance tests by injecting assertions to synthesized
JavaScript programs.  Finally, $\tool$ detects and localizes bugs via execution
results of the tests on $N$ JavaScript engines.  We evaluate our tool with four
JavaScript engines (GraalJS\cite{graaljs}, QuickJS\cite{qjs}, Moddable
XS\cite{xs}, and Google V8\cite{v8}) that support all modern JavaScript language
features and the most recent version of ECMAScript (ES11, 2020).

Our main contributions are as follows:
\begin{itemize}
  \item Present \textit{$N$+1-differential testing}, a novel solution to the new
    problem of the co-evolving language specification and implementation.
  \item Implement our solution in a tool $\tool$ for JavaScript engines with
    ECMAScript.  It is the first tool that automatically generates conformance
    tests for JavaScript engines from ECMAScript.  We first measure the coverage
    of Test262, the official conformance tests, \inred{and the conformance tests
    generated by our tool defeats the coverage of Test262.}
  \item Evaluate $\tool$ with four modern JavaScript engines and the most recent
    version of ECMAScript, ES11.  Using the generated conformance test
    suite, our tool found and localized \inred{XX} engine bugs in four different
    engines and \inred{X} specification bugs in ES11.
\end{itemize}
