\section{Introduction}\label{sec:intro}
\begin{itemize}
\item In Peter O'Hearn's keynote speech in ICSE 2020, he quoted the
following from Mark Z. Letter to Investors:
\begin{quote}
The Hacker Way is an approach to building that involves continuous
improvement and iteration.
Hackers believe that somethings can always be better, and that nothing
is ever complete.
\end{quote}

\item Indeed, modern programming follows the CI/CD approach rather than the
traditional waterfall model.
Even the development of modern programming languages uses the CI/CD approach.

\item Consider JavaScript, which is one of the most widely used
programming languages.  Various JavaScript engines provide diverse
extensions to adapt to fast-changing user demands.
At the same time, ECMAScript, the official specification that
describes syntax and semantics of JavaScript, is annually updated since
ECMAScript 6 (ES6, 2015) to support new language features in response
to user demands.  Such updates in both the specification and
implementation in tandem make it difficult for them to be in synch.

\item Another example is Solidity, the standard smart
contract programming language for Ethereum blockchain. The Solidity
language specification is continuously released, and the Solidity
compiler is also frequently released. While the compiler reflects
the updates in the specification in most cases, even the specification
is revised according to the semantics implemented in the compiler.

\item Conventional approaches to build a language are uni-directional
  from a language specification to its implementation. The
  specification is believed to be correct and the conformance of the
  implementation to the specification is checked by dynamic testing.

\item Unlike conventional approaches, in the modern CI/CD approaches,
the specification may not be the Oracle, because both the
specification and the implementation can co-evolve. In this setting, both
the specification and the implementation may have bugs, and
guaranteeing their correctness is non-trivial.

\item In this paper, we present a novel ``n+1-version testing'' to
resolve the problem. Our approach consists of three
steps: 1) to automatically generate JavaScript programs guided by
syntax from a specification written in a natural language, 2)
to mutate them to increase branch coverage in ECMAScript, and 3) to inject
assertions into them to check their final program states.

Given a language specification and $n$ existing
real-world implementations, we automatically generate a test suite from
the specification, which covers the entire grammar of the
specification with assertions in each test code to make sure that the
result of running the code conforms to the specification semantics.
Then, we run the test suite for $n$ implementations of the
specification. Because generated tests strictly comply with ECMAScript,
they reflect specification errors as well, if any.
 When one of the implementations fails in running a test,
it is highly likely that the implementation has a bug, which is the
traditional $n$-version testing. When most of the implementations fails
in running a test, it is highly likely that the specification has a
bug. By automatically generating a rich set of test code from the
specification and running them with the implementation of the
specification, we can find bugs in either the specification written in
natural language or in its implementation.

\item Contributions
\begin{itemize}
\item Propose a novel solution to the new problem of the co-evolving
  language specification and implementation.
\item Present $\tool$ that automatically generates a rich set of test
code directly from a language specification written in natural language.
It the first tool that automatically
generates conformance tests for JavaScript engines from ECMAScript.
We first measure the branch coverage of Test262, the official
        conformance tests, and the conformance tests generated by our tool
        defeats the coverage of Test262.
\item Report bugs in the ECMAScript specification and real-world
JavaScript engines.
We applied our tool to \inred{X} JavaScript engines that support the
        latest version of ECMAScript (ES11, 2020).  Based on the test results,
        we found \inred{XX} errors in \inred{XX} and \inred{XX} errors in
        \inred{XX}. Moreover, we found \inred{XX} specification errors in
        ES11.
\end{itemize}

\item Evaluation
\begin{itemize}
\item {\bf RQ1 (Completeness of Test Generation)}
Coverage compared to Test262
%, the official conformance test suite for ECMAScript
\item {\bf RQ2 (Effectiveness of Test Generation)}
Performance in test code generation
\item {\bf RQ3 (Bug Detection in JavaScript Engines)}
\item {\bf RQ4 (Bug Detection in ECMAScript)}
\end{itemize}
\end{itemize}
