\section{Introduction}\label{sec:intro}

In Peter O'Hearn's keynote speech in ICSE 2020, he quoted the following from
Mark Z. Letter to Investors:
\begin{quote}
  The Hacker Way is an approach to building that involves continuous improvement
  and iteration.  Hackers believe that somethings can always be better, and that
  nothing is ever complete.
\end{quote}
Indeed, modern programming follows the continuous integration (CI) and
continuous deployment (CD) approach rather than the traditional waterfall model.
Even the development of modern programming languages uses the CI/CD approach.

Consider JavaScript, which is one of the most widely used programming languages
not only for client-side but also for server-side programming\cite{nodejs} and
even for embedded systems\cite{moddable,espruino,tessel2}.  Various JavaScript
engines provide diverse extensions to adapt to fast-changing user demands.  At
the same time, ECMAScript, the official specification that describes syntax and
semantics of JavaScript, is annually updated since ECMAScript 6 (ES6,
2015)\cite{es6} to support new language features in response to user demands.
Such updates in both the specification and implementation in tandem make it
difficult for them to be in sync.

Another example is Solidity, the standard smart contract programming language
for Ethereum blockchain. The Solidity language specification is continuously
released, and the Solidity compiler is also frequently released.  According to
Hwang et al.\cite{solidity-gap}, the average number of days between consecutive
releases from Solidity 0.1.2 to 0.5.7 is 27. While the compiler reflects the
updates in the specification in most cases, even the specification is revised
according to the semantics implemented in the compiler.

Conventional approaches to build a programming language are uni-directional from
a language specification to its implementation. The specification is believed to
be correct and the conformance of the implementation to the specification is
checked by dynamic testing.  Unlike conventional approaches, in the modern CI/CD
approaches, the specification may not be the Oracle, because both the
specification and the implementation can co-evolve. In this setting, both the
specification and the implementation may have bugs, and guaranteeing their
correctness is non-trivial.

In this paper, we present a novel \textit{$N$+1-version testing} to resolve the
problem. Our approach consists of three steps: 1) to automatically synthesize
programs guided by the syntax and semantics from the given language
specification, 2) to generate conformance tests by injecting assertions to them
to check their final program states, and 3) to find and localize the
specification bugs via executing programs on multiple implementations.

Given a language specification and $N$ existing real-world implementations, we
automatically generate a conformance test suite from the specification with
assertions in each test code to make sure that the result of running the code
conforms to the specification semantics.  Then, we run the test suite for $N$
implementations of the specification. Because generated tests strictly comply
with the specification, they reflect specification errors as well, if any.  When
one of the implementations fails in running a test, it is highly likely that the
implementation has a bug, which is the traditional $N$-version testing. When
most of the implementations fails in running a test, it is highly likely that
the specification has a bug.  By automatically generating a rich set of test
code from the specification and running them with the implementation of the
specification, we can find and localize bugs in either the specification written
in natural language or in its implementations.

We propose a tool $\tool$ that performs $N$+1-version testing for modern
JavaScript engines and ECMAScript.  We utilize the mechanized specification
extracted from ECMAScript via $\jiset$\cite{jiset}, which is a JavaScript
IR-based semantics extraction toolchain.

Our main contributions are as follows:
\begin{itemize}
  \item Present \textit{$N$+1-verison testing}, a novel solution to the new
    problem of the co-evolving language specification and implementation.
  \item Implement our solution in a tool $\tool$ for JavaScript engines with
    ECMAScript.  It is the first tool that automatically generates conformance
    tests for JavaScript engines from ECMAScript.  We first measure the coverage
    of Test262, the official conformance tests, \inred{and the conformance tests
    generated by our tool defeats the coverage of Test262.}
  \item Evaluate $\tool$ with four JavaScript engines that support all modern
    JavaScript language features and the most recent version of ECMAScript
    (ES11, 2020).  Using the generated conformance test suite, our tool found
    and localize \inred{XX} engine bugs in four different engines and \inred{X}
    specification bugs in ES11.
\end{itemize}
