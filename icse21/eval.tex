\section{Evaluation}\label{sec:eval}

\begin{figure*}[t]
  \centering
  \begin{subfigure}[t]{0.48\textwidth}
    \includegraphics[width=\textwidth]{img/stmt-coverage.pdf}
    \caption{The statement coverage}
    \label{fig:stmt-coverage}
  \end{subfigure}
  \quad
  \begin{subfigure}[t]{0.48\textwidth}
    \includegraphics[width=\textwidth]{img/branch-coverage.pdf}
    \caption{The branch coverage}
    \label{fig:branch-coverage}
  \end{subfigure}
  \caption{The semantics coverage changes during the test generation phase}
  \label{fig:sem-coverage}
  \vspace*{-1em}
\end{figure*}

To evaluate $\tool$ that performs the $N$+1-differential testing of JavaScript
engines and specification, we applied our tool to four JavaScript engines that
fully support modern JavaScript features and the most recent specification,
ECMAScript 2020 (ES11, 2020).  We targeted the following four JavaScript
engines and all of them supports
ES11\footnote{https://github.com/graalvm/graaljs\#current-status}\footnote{https://bellard.org/quickjs/}\footnote{https://blog.moddable.com/blog/xs10/}\footnote{https://v8.dev/}:
\begin{itemize}
  \item \textbf{GraalJS(v20.1.0):} A JavaScript implementation built on
    GraalVM\cite{graaljs}, which is a Java Virtual Machine (JVM) based on
    HotSpot/OpenJDK developed by Oracle.
  \item \textbf{QuickJS(2020-04-12):} A small and embedded JavaScript engine developed by
    Fabrice Bellard and Charlie Gordon\cite{qjs}.
  \item \textbf{Moddable XS(v10.2.1):} A JavaScript engine at the center of the Moddable
    SDK\cite{xs}, which is a combination of development tools and runtime
    software to create applications for microcontrollers.
  \item \textbf{V8(v8.5):} The Google's open source high-performance JavaScript and
    WebAssembly engine\cite{v8}, written in C++.
\end{itemize}
To extract mechanized specification from ECMAScript, we utilize the tool
$\jiset$, which is a JavaScript IR-based semantics extraction toolchain.
automatically extracted from a given ECMAScript.  To focus on the semantics of
core JavaScript semantics, we only consider the semantics of strict mode
JavaScript codes that pass syntax checking including the EarlyError rules.  To
filter out the JavaScript codes that are not strict or fail the syntax checking,
we utilize the syntax checker of the most reliable JavaScript engine, V8.
We performed our experiments on a machine equipped with 4.0GHz Intel(R) Core(TM)
i7-6700k and 32GB of RAM (Samsung DDR4 2133MHz 8GB*4).  We evaluated our tool
based on the following four research questions:
\begin{itemize}
  \item {\bf RQ1 (Coverage of Generated Tests)} The semantics coverage compared
    to Test262, the manually written official conformance test suite for
    ECMAScript.
  \item {\bf RQ2 (Bug Detection in JavaScript Engines)} The number of bugs in
    four JavaScript engines detected by $\tool$.
  \item {\bf RQ3 (Bug Detection in ECMAScript)} The number of specification bugs
    in ES11 detected by $\tool$.
\end{itemize}


\subsection{Coverage of Generated Tests}

For the first step, we synthesize seed programs via \textsf{Seed Synthesizer}
based on the syntax of ES11.  It synthesizes \inred{1,112} JavaScript programs
in about \inred{10} seconds and covers \inred{97.25\% (395/406)} of reachable
alternatives in syntax productions.  The seed programs becomes the initial
program pool and it gradually grows via \textsf{Target Selector} and
\textsf{Program Mutator}.  Figure~\ref{fig:sem-coverage} shows the change of
semantics coverage of the program pool during the iterative process in
\inred{45} hours.  The left and right graphs show the statement and branch
coverages, respectively.  The red line for each graph denotes the coverage of
tests of Test262.  For the statement coverage, \inred{29,728} statements exist
in ES11 and tests in Test262 covers \inred{22,425 (75.43\%)} statements.  The
initial program pool covers \inred{12,766 (42.94\%)} statements and the final
program pool covers \inred{21,249 (71.48\%)} statements.  For branch coverage,
\inred{11,448} branches exist in ES11 and tests in Test262 covers \inred{7,944
(69.39\%)} branches.  The initial program pool covers \inred{3,986 (34.82\%)}
branches and the final program pool covers \inred{7,476 (65.30\%)} branches.

\begin{table}
  \caption{The number of successes and covered branches for mutation methods}
  \label{table:mutation-method}
  \vspace*{-1em}
  \small
  \[
    \begin{array}{l?r|r}
      \telembf{c?}{Mutation Methods}      & \telembf{c|}{Success} & \telembf{c}{Branch (Avg.)}\\\toprule\\[-1.4em]
      \text{Nearest Syntax Tree Mutation} & \rtext{436}           & \rtext{1,450 (3.33)}\\\hline
      \text{Random Mutation}              & \rtext{320}           & \rtext{910   (2.84)}\\\hline
      \text{Statement Insertion}          & \rtext{201}           & \rtext{672   (3.34)}\\\hline
      \text{Object Substitution}          & \rtext{162}           & \rtext{453   (2.80)}\\\hline
      \text{String Substitution}          & \rtext{4}             & \rtext{5     (1.25)}\\\hline
      \hline
      \telembf{c?}{Total}                 & \rtext{1,123}         & \rtext{3,490 (3.11)}\\
    \end{array}
  \]
  \vspace*{-1.5em}
\end{table}

Table~\ref{table:mutation-method} shows the number of successes and covered
branches for each mutation method during the test generation phase. In total,
$\tool$ succeeds to synthesize \inred{1,123} programs that covers \inred{3,490}
more branches than the initial program pool.  Among five mutation methods, the
nearest syntax tree mutation is the most contributed method (\inred{436}
successes and \inred{1,450} covered branches) and the least one is the string
substitution (\inred{4} successes and \inred{5} covered branches).  On average,
\inred{3.11} branches are covered by one successful mutation.

Finally, $\tool$ generates \inred{X,XXX} JavaScript programs and the average
length of generated programs is \inred{XX.XX}.  After injecting asseritons by
\textsf{Asseriton Injector}, generated programs become conformance tests and
their average length is \inred{XXX.XX}.  Compared to Test262, the number of
generated tests are much smaller and their sizes also shorter than that of tests
in Test262.  Test262 provides \inred{XX,XXX} tests for the same range of
semantics and their average size is \inred{XXX.XX}.


\subsection{Bug Detection in JavaScript Engines}

We introduced six different kinds of assertions used in \textsf{Asseriton
Injector}: exceptions (\textsf{Exc}), variable values (\textsf{Var}), object
values (\textsf{Obj}), property descriptors (\textsf{Desc}), property orders
(\textsf{Ord}), and internal methods and slots (\textsf{In}).

\begin{table}
  \caption{The number of engine bugs detected by $\tool$}
  \label{table:engine-bug}
  \vspace*{-1em}
  \small
  \[
    \begin{array}{l?r|r|r|r|r|r?r}
      \telembf{c?}{Engines} &
      \telemsf{c|}{Exc} &
      \telemsf{c|}{Var} &
      \telemsf{c|}{Obj} &
      \telemsf{c|}{Desc} &
      \telemsf{c|}{Ord} &
      \telemsf{c?}{In} &
      \telembf{c}{Total}\\\toprule\\[-1.4em]

      \text{GraalJS}      & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0}\\\hline
      \text{QuickJS}      & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0}\\\hline
      \text{Moddable XS}  & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0}\\\hline
      \text{V8}           & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0}\\\hline
      \hline
      \telembf{c?}{Total} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0} & \inred{0}
    \end{array}
  \]
  \vspace*{-1.5em}
\end{table}


\subsection{Bug Detection in ECMAScript}

\begin{table*}[t]
  \centering
  \caption{Specification bugs in ECMAScript 2020 (ES11) detected by $\tool$}
  \label{table:spec-bug}
  \vspace*{-.5em}
  \small
  \begin{tabular}{c?l|c|c|c|r|r}
    \telembf{c?}{\bf Name} &
    \telembf{c}{\bf Description} &
    \telembf{c}{\bf Lang} &
    \telembf{c}{\bf Created} &
    \telembf{c}{\bf Resolved} &
    \telembf{c}{\bf Existed} &
    \telembf{c}{\bf \# Fails} \\\toprule\\[-1.4em]

    ES11-1 &
    \makecell[l]{} &
    \inred{O} &
    \inred{XXXX-XX-XX} &
    \inred{XXXX-XX-XX} &
    \inred{X,XXX} days &
    \inred{X,XXX} \\\hline

    ES11-2 &
    \makecell[l]{} &
    \inred{O} &
    \inred{XXXX-XX-XX} &
    \inred{XXXX-XX-XX} &
    \inred{X,XXX} days &
    \inred{X,XXX} \\\hline

    ES11-3 &
    \makecell[l]{} &
    \inred{O} &
    \inred{XXXX-XX-XX} &
    \inred{XXXX-XX-XX} &
    \inred{X,XXX} days &
    \inred{X,XXX} \\\hline

    ES11-4 &
    \makecell[l]{} &
    \inred{O} &
    \inred{XXXX-XX-XX} &
    \inred{XXXX-XX-XX} &
    \inred{X,XXX} days &
    \inred{X,XXX} \\\hline

    ES11-5 &
    \makecell[l]{} &
    \inred{O} &
    \inred{XXXX-XX-XX} &
    \inred{XXXX-XX-XX} &
    \inred{X,XXX} days &
    \inred{X,XXX} \\\hline

    ES11-6 &
    \makecell[l]{} &
    \inred{O} &
    \inred{XXXX-XX-XX} &
    \inred{XXXX-XX-XX} &
    \inred{X,XXX} days &
    \inred{X,XXX} \\\hline

    ES11-7 &
    \makecell[l]{} &
    \inred{O} &
    \inred{XXXX-XX-XX} &
    \inred{XXXX-XX-XX} &
    \inred{X,XXX} days &
    \inred{X,XXX}
  \end{tabular}
\end{table*}

\inred{TODO}
