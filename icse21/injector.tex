\subsection{Assertion Injector}

After generating JavaScript programs, \textsf{Assertion Injector} injects
assertions to them based on the final state of the program according to
ECMAScript.  It first obtains the final state of a given program from the
mechanized specification and injects six different kinds of assertions to the
program.  We carefully implement helper functions for assertions in JavaScript
not to affect the semantics of the original program and inject them in the front
of the given program.  Moreover, in order to check the final state after
executing all asynchronous jobs assigned in the job queue, we enclose assertions
with \code{setTimeout} to wait 100ms when the program uses asynchronous features
such as \code{Promise} or \code{async}:
\begin{lstlisting}[style=myJSstyle]
// a given program
setTimeout(() => {
  // injected assertions
}, 100)
\end{lstlisting}


\subsubsection{Exceptions}

JavaScript supports both internal exceptions, such as \code{SyntaxError} and
\code{TypeError}, and custom exceptions with the keyword \code{throw}.  We could
catch such exceptions using \code{try-catch} statements.  However, it might
change the semantics of a given program.  For example,
\begin{lstlisting}[style=myJSstyle]
var x; function x() {}
\end{lstlisting}
does not throw any exception but
\begin{lstlisting}[style=myJSstyle]
try { var x; function x() {} } catch (e) {}
\end{lstlisting}
throws a \code{SyntaxError} because the same name of a variable and a function
declaration is not allowed in \code{try-catch} blocks.

To resolve this problem, we utilize the comment in the first line.  If the
program throws an internal exception, we tag its name in the comment.
Otherwise, we tag \code{Throw} for a custom exception and \code{Normal} for
the normal termination.  Using the tag in the comment, we checked the execution
result of the program in each engine.  For example, ES11 says that the example
JavaScript program in Figure~\ref{fig:example-algo} normally terminates thus the
program is modified as follows:
\begin{lstlisting}[style=myJSstyle]
// Normal
var obj = { valueOf: () => { throw 'err'; } };
var result = 42 == obj;
\end{lstlisting}


\subsubsection{Variable Values}

We injected assertions that compare values stored in variables with expected
values.  To focus on newly introduced variables during the execution, we do not
compare pre-defined variables such as built-in objects.  It detects variables
introduced by not only variable declarations (\code{var}) but also lexcial
(\code{let} or \code{const}) and function declarations.  We discriminate
\code{-0} and \code{+0} using division by zero because \code{-0/0} and
\code{+0/0} produce positive and negative infinity values, respectively.  For
object values, we use other assertions to deeply check them.  For example, the
following code is an example that checks whether the value of the variable
\code{x} is \code{3}.
\begin{lstlisting}[style=myJSstyle]
var x = 1 + 2;
$assert.sameValue(x, 3);
\end{lstlisting}


\subsubsection{Object Values}

To check the equality between two object values, we keep the representative path
for each object.  If the injector meets an object in the first time, it injects
assertions for its properties will be explained in the remaining the section and
stores the current path.  Otherwise, the injector adds assertions to compare the
current path and the representative path.
\begin{lstlisting}[style=myJSstyle]
var x = {}, y = {}, z = { p: x, q: y };
$assert.sameValue(z.p, x);
$assert.sameValue(z.q, y);
\end{lstlisting}
For example, in the above code, the injector meets two different new objects
stored in the variables \code{x} and \code{y} thus it stores the paths \code{x}
and \code{y}.  Then, the object in \code{z} is also a new object but its
properties \code{z.p} and \code{z.q} stores already visited objects.  Thus, the
injector inserts two assertions that check whether \code{z.p} and \code{x} have
a same object and \code{z.q} and \code{y} have a same object.  To handle
built-in objects, we store all paths of built-in objects before traversing the
state.


\subsubsection{Property Descriptors}

JavaScript supports two different kinds of object properties: \textit{data
property} and \textit{accessor property}.  Each property consists of four
different attributes [[Value]], [[Writable]], [[Enumerable]], and
[[Configurable]] for data properties and [[Get]], [[Set]], [[Enumerable]], and
[[Configurable]] for accessor properties.  We could access them using the
\code{Object.getOwnPropertyDescriptor} built-in function.  It takes an object
and a value that represents a property key, and returns an object that
represents the property descriptor.  We implement a helper
\code{\$verifyProperty} to check attributes of each property for each object.
For example, the following code checks attributes of the data property
\code{x.p}.
\begin{lstlisting}[style=myJSstyle]
var x = { p: 42 };
$verifyProperty(x, "p", {
  value: 42.0,
  writable: true,
  enumerable: true,
  configurable: true
});
\end{lstlisting}


\subsubsection{Property Orders}

Since ECMAScript 2015 (ES6), the order between object properties is defined in
the specification.  Thus, we check the order by using the \code{Reflect.ownKeys}
built-in function that returns an array that consists of own property keys for a
given object.  We implement a helper \code{\$assert.compareArray} that takes two
different arrays and compare their length and contents.  For example, the
following program is an example that checks the order between properties of
the object in \code{x}.
\begin{lstlisting}[style=myJSstyle]
var x = {
  [Symbol.match]: 0,
  p: 0, 3: 0, q: 0
}
$assert.compareArray(
  Reflect.ownKeys(x),
  ['3', 'p', 'q', Symbol.match]
);
\end{lstlisting}


\subsubsection{Internal Methods and Slots}

JavaScript objects have internal methods and slots that we cannot direcly
access.  However, several internal methods and slots are accessible using
indirect ways.  We target four internal slots with their appropriate indirect
getters as follows:
\[
  \begin{array}{|l|l|}\hline
    \text{Name}           & \text{Indirect Getter}\\\hline
    \text{[[Prototype]]}  & \code{Object.getPrototypeOf(x)}\\\hline
    \text{[[Extensible]]} & \code{Object.isExtensible(x)}\\\hline
    \text{[[Call]]}       & \code{typeof f === 'function'}\\\hline
    \text{[[Construct]]}  & \code{Reflect.construct(function()\string{\string},[],x)}\\\hline
  \end{array}
\]

The internal slot [[Prototype]] represents the prototype object of an object.
We extracts it using a built-in function \code{Object.getPrototypeOf}.  In the
similar way, we use \code{Object.isExtensible(x)} for [[Extensible]] slot.  The
internal methods [[Call]] and [[Construct]] represents whether a given object is
a function or a constructor.  However, methods stored in [[Call]] and
[[Construct]] are not JavaScript values thus we only check the their existence
using two helpers \code{\$assert.callable} and \code{\$assert.constructable}.  For
[[Call]] method, we use the \code{typeof} operator because it returns the string
\code{"function"} if and only if the given value is an object has the [[Call]]
internal method.  For [[Construct]] method, we use the \code{Reflect.construct}
built-in function that checks the existence of [[Construct]] methods and invokes
it.  To preserve the current state, we pass a given object as the third argument
to only check the existence of [[Construct]] and pass another dummy function
\code{funcion()\string{\string}} as the first argument whose [[Construct]]
invoked by \code{Reflect.construct}.  For example, the following code describes
how the injector injects assertions related to internal methods and slots:
\begin{lstlisting}[style=myJSstyle]
function f() {}
$assert.sameValue(Object.getPrototypeOf(f),
                  Function.prototype);
$assert.sameValue(Object.isExtensible(x), true);
$assert.callable(f);
$assert.constructable(f);
\end{lstlisting}
